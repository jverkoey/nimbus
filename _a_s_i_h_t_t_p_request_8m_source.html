<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Nimbus: /Users/featherless/workbench/ios/nimbus/src/ASIHTTPRequest/src/ASIHTTPRequest.m Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />


<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-24278774-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
</head>
<body>
<div id="page">
<div style="position:relative">
<div id="top"><!-- do not remove this div! -->

<div id="titlearea">
<a style="float: right;margin-right:20px;margin-top:20px" href='http://www.pledgie.com/campaigns/15519'><img alt='Click here to support Nimbus development and make a donation at www.pledgie.com !' src='http://www.pledgie.com/campaigns/15519.png?skin_name=chrome' border='0' /></a>
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Nimbus
   &#160;<span id="projectnumber">0.3.4.1 - <a href="http://github.com/jverkoey/nimbus">Nimbus is proudly hosted on Github</a></span>
   </div>
   <div id="projectbrief">An iOS framework whose growth is bounded by O(documentation).</div>
  </td>
  
  
  
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.4-20110629 -->
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('_a_s_i_h_t_t_p_request_8m.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">/Users/featherless/workbench/ios/nimbus/src/ASIHTTPRequest/src/ASIHTTPRequest.m</div>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">//</span>
<a name="l00002"></a>00002 <span class="comment">//  ASIHTTPRequest.m</span>
<a name="l00003"></a>00003 <span class="comment">//</span>
<a name="l00004"></a>00004 <span class="comment">//  Created by Ben Copsey on 04/10/2007.</span>
<a name="l00005"></a>00005 <span class="comment">//  Copyright 2007-2011 All-Seeing Interactive. All rights reserved.</span>
<a name="l00006"></a>00006 <span class="comment">//</span>
<a name="l00007"></a>00007 <span class="comment">//  A guide to the main features is available at:</span>
<a name="l00008"></a>00008 <span class="comment">//  http://allseeing-i.com/ASIHTTPRequest</span>
<a name="l00009"></a>00009 <span class="comment">//</span>
<a name="l00010"></a>00010 <span class="comment">//  Portions are based on the ImageClient example from Apple:</span>
<a name="l00011"></a>00011 <span class="comment">//  See: http://developer.apple.com/samplecode/ImageClient/listing37.html</span>
<a name="l00012"></a>00012 
<a name="l00013"></a>00013 <span class="preprocessor">#import &quot;ASIHTTPRequest.h&quot;</span>
<a name="l00014"></a>00014 
<a name="l00015"></a>00015 <span class="preprocessor">#if TARGET_OS_IPHONE</span>
<a name="l00016"></a>00016 <span class="preprocessor"></span><span class="preprocessor">#import &quot;Reachability.h&quot;</span>
<a name="l00017"></a>00017 <span class="preprocessor">#import &quot;ASIAuthenticationDialog.h&quot;</span>
<a name="l00018"></a>00018 <span class="preprocessor">#import &lt;MobileCoreServices/MobileCoreServices.h&gt;</span>
<a name="l00019"></a>00019 <span class="preprocessor">#else</span>
<a name="l00020"></a>00020 <span class="preprocessor"></span><span class="preprocessor">#import &lt;SystemConfiguration/SystemConfiguration.h&gt;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#endif</span>
<a name="l00022"></a>00022 <span class="preprocessor"></span><span class="preprocessor">#import &quot;ASIInputStream.h&quot;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#import &quot;ASIDataDecompressor.h&quot;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#import &quot;ASIDataCompressor.h&quot;</span>
<a name="l00025"></a>00025 
<a name="l00026"></a>00026 <span class="comment">// Automatically set on build</span>
<a name="l00027"></a>00027 <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *ASIHTTPRequestVersion = <span class="stringliteral">@&quot;v1.8.1-8 2011-06-05&quot;</span>;
<a name="l00028"></a>00028 
<a name="l00029"></a>00029 <span class="keyword">static</span> <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *defaultUserAgent = nil;
<a name="l00030"></a>00030 
<a name="l00031"></a>00031 <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a>* <span class="keyword">const</span> NetworkRequestErrorDomain = <span class="stringliteral">@&quot;ASIHTTPRequestErrorDomain&quot;</span>;
<a name="l00032"></a>00032 
<a name="l00033"></a>00033 <span class="keyword">static</span> <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *ASIHTTPRequestRunLoopMode = <span class="stringliteral">@&quot;ASIHTTPRequestRunLoopMode&quot;</span>;
<a name="l00034"></a>00034 
<a name="l00035"></a>00035 <span class="keyword">static</span> <span class="keyword">const</span> CFOptionFlags kNetworkEvents =  kCFStreamEventHasBytesAvailable | kCFStreamEventEndEncountered | kCFStreamEventErrorOccurred;
<a name="l00036"></a>00036 
<a name="l00037"></a>00037 <span class="comment">// In memory caches of credentials, used on when useSessionPersistence is YES</span>
<a name="l00038"></a>00038 <span class="keyword">static</span> NSMutableArray *sessionCredentialsStore = nil;
<a name="l00039"></a>00039 <span class="keyword">static</span> NSMutableArray *sessionProxyCredentialsStore = nil;
<a name="l00040"></a>00040 
<a name="l00041"></a>00041 <span class="comment">// This lock mediates access to session credentials</span>
<a name="l00042"></a>00042 <span class="keyword">static</span> NSRecursiveLock *sessionCredentialsLock = nil;
<a name="l00043"></a>00043 
<a name="l00044"></a>00044 <span class="comment">// We keep track of cookies we have received here so we can remove them from the sharedHTTPCookieStorage later</span>
<a name="l00045"></a>00045 <span class="keyword">static</span> NSMutableArray *sessionCookies = nil;
<a name="l00046"></a>00046 
<a name="l00047"></a>00047 <span class="comment">// The number of times we will allow requests to redirect before we fail with a redirection error</span>
<a name="l00048"></a>00048 <span class="keyword">const</span> <span class="keywordtype">int</span> RedirectionLimit = 5;
<a name="l00049"></a>00049 
<a name="l00050"></a>00050 <span class="comment">// The default number of seconds to use for a timeout</span>
<a name="l00051"></a>00051 <span class="keyword">static</span> NSTimeInterval defaultTimeOutSeconds = 10;
<a name="l00052"></a>00052 
<a name="l00053"></a>00053 <span class="keyword">static</span> <span class="keywordtype">void</span> ReadStreamClientCallBack(CFReadStreamRef readStream, CFStreamEventType type, <span class="keywordtype">void</span> *clientCallBackInfo) {
<a name="l00054"></a>00054     [((ASIHTTPRequest*)clientCallBackInfo) handleNetworkEvent: type];
<a name="l00055"></a>00055 }
<a name="l00056"></a>00056 
<a name="l00057"></a>00057 <span class="comment">// This lock prevents the operation from being cancelled while it is trying to update the progress, and vice versa</span>
<a name="l00058"></a>00058 <span class="keyword">static</span> NSRecursiveLock *progressLock;
<a name="l00059"></a>00059 
<a name="l00060"></a>00060 <span class="keyword">static</span> NSError *ASIRequestCancelledError;
<a name="l00061"></a>00061 <span class="keyword">static</span> NSError *ASIRequestTimedOutError;
<a name="l00062"></a>00062 <span class="keyword">static</span> NSError *ASIAuthenticationError;
<a name="l00063"></a>00063 <span class="keyword">static</span> NSError *ASIUnableToCreateRequestError;
<a name="l00064"></a>00064 <span class="keyword">static</span> NSError *ASITooMuchRedirectionError;
<a name="l00065"></a>00065 
<a name="l00066"></a>00066 <span class="keyword">static</span> NSMutableArray *bandwidthUsageTracker = nil;
<a name="l00067"></a>00067 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> averageBandwidthUsedPerSecond = 0;
<a name="l00068"></a>00068 
<a name="l00069"></a>00069 <span class="comment">// These are used for queuing persistent connections on the same connection</span>
<a name="l00070"></a>00070 
<a name="l00071"></a>00071 <span class="comment">// Incremented every time we specify we want a new connection</span>
<a name="l00072"></a>00072 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nextConnectionNumberToCreate = 0;
<a name="l00073"></a>00073 
<a name="l00074"></a>00074 <span class="comment">// An array of connectionInfo dictionaries.</span>
<a name="l00075"></a>00075 <span class="comment">// When attempting a persistent connection, we look here to try to find an existing connection to the same server that is currently not in use</span>
<a name="l00076"></a>00076 <span class="keyword">static</span> NSMutableArray *persistentConnectionsPool = nil;
<a name="l00077"></a>00077 
<a name="l00078"></a>00078 <span class="comment">// Mediates access to the persistent connections pool</span>
<a name="l00079"></a>00079 <span class="keyword">static</span> NSRecursiveLock *connectionsLock = nil;
<a name="l00080"></a>00080 
<a name="l00081"></a>00081 <span class="comment">// Each request gets a new id, we store this rather than a ref to the request itself in the connectionInfo dictionary.</span>
<a name="l00082"></a>00082 <span class="comment">// We do this so we don&#39;t have to keep the request around while we wait for the connection to expire</span>
<a name="l00083"></a>00083 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nextRequestID = 0;
<a name="l00084"></a>00084 
<a name="l00085"></a>00085 <span class="comment">// Records how much bandwidth all requests combined have used in the last second</span>
<a name="l00086"></a>00086 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> bandwidthUsedInLastSecond = 0; 
<a name="l00087"></a>00087 
<a name="l00088"></a>00088 <span class="comment">// A date one second in the future from the time it was created</span>
<a name="l00089"></a>00089 <span class="keyword">static</span> NSDate *bandwidthMeasurementDate = nil;
<a name="l00090"></a>00090 
<a name="l00091"></a>00091 <span class="comment">// Since throttling variables are shared among all requests, we&#39;ll use a lock to mediate access</span>
<a name="l00092"></a>00092 <span class="keyword">static</span> NSLock *bandwidthThrottlingLock = nil;
<a name="l00093"></a>00093 
<a name="l00094"></a>00094 <span class="comment">// the maximum number of bytes that can be transmitted in one second</span>
<a name="l00095"></a>00095 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> maxBandwidthPerSecond = 0;
<a name="l00096"></a>00096 
<a name="l00097"></a>00097 <span class="comment">// A default figure for throttling bandwidth on mobile devices</span>
<a name="l00098"></a>00098 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keyword">const</span> ASIWWANBandwidthThrottleAmount = 14800;
<a name="l00099"></a>00099 
<a name="l00100"></a>00100 <span class="preprocessor">#if TARGET_OS_IPHONE</span>
<a name="l00101"></a>00101 <span class="preprocessor"></span><span class="comment">// YES when bandwidth throttling is active</span>
<a name="l00102"></a>00102 <span class="comment">// This flag does not denote whether throttling is turned on - rather whether it is currently in use</span>
<a name="l00103"></a>00103 <span class="comment">// It will be set to NO when throttling was turned on with setShouldThrottleBandwidthForWWAN, but a WI-FI connection is active</span>
<a name="l00104"></a>00104 <span class="keyword">static</span> BOOL isBandwidthThrottled = NO;
<a name="l00105"></a>00105 
<a name="l00106"></a>00106 <span class="comment">// When YES, bandwidth will be automatically throttled when using WWAN (3G/Edge/GPRS)</span>
<a name="l00107"></a>00107 <span class="comment">// Wifi will not be throttled</span>
<a name="l00108"></a>00108 <span class="keyword">static</span> BOOL shouldThrottleBandwithForWWANOnly = NO;
<a name="l00109"></a>00109 <span class="preprocessor">#endif</span>
<a name="l00110"></a>00110 <span class="preprocessor"></span>
<a name="l00111"></a>00111 <span class="comment">// Mediates access to the session cookies so requests</span>
<a name="l00112"></a>00112 <span class="keyword">static</span> NSRecursiveLock *sessionCookiesLock = nil;
<a name="l00113"></a>00113 
<a name="l00114"></a>00114 <span class="comment">// This lock ensures delegates only receive one notification that authentication is required at once</span>
<a name="l00115"></a>00115 <span class="comment">// When using ASIAuthenticationDialogs, it also ensures only one dialog is shown at once</span>
<a name="l00116"></a>00116 <span class="comment">// If a request can&#39;t acquire the lock immediately, it means a dialog is being shown or a delegate is handling the authentication challenge</span>
<a name="l00117"></a>00117 <span class="comment">// Once it gets the lock, it will try to look for existing credentials again rather than showing the dialog / notifying the delegate</span>
<a name="l00118"></a>00118 <span class="comment">// This is so it can make use of any credentials supplied for the other request, if they are appropriate</span>
<a name="l00119"></a>00119 <span class="keyword">static</span> NSRecursiveLock *delegateAuthenticationLock = nil;
<a name="l00120"></a>00120 
<a name="l00121"></a>00121 <span class="comment">// When throttling bandwidth, Set to a date in future that we will allow all requests to wake up and reschedule their streams</span>
<a name="l00122"></a>00122 <span class="keyword">static</span> NSDate *throttleWakeUpTime = nil;
<a name="l00123"></a>00123 
<a name="l00124"></a>00124 <span class="keyword">static</span> id &lt;ASICacheDelegate&gt; defaultCache = nil;
<a name="l00125"></a>00125 
<a name="l00126"></a>00126 <span class="comment">// Used for tracking when requests are using the network</span>
<a name="l00127"></a>00127 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> runningRequestCount = 0;
<a name="l00128"></a>00128 
<a name="l00129"></a>00129 <span class="comment">// You can use [ASIHTTPRequest setShouldUpdateNetworkActivityIndicator:NO] if you want to manage it yourself</span>
<a name="l00130"></a>00130 <span class="comment">// Alternatively, override showNetworkActivityIndicator / hideNetworkActivityIndicator</span>
<a name="l00131"></a>00131 <span class="comment">// By default this does nothing on Mac OS X, but again override the above methods for a different behaviour</span>
<a name="l00132"></a>00132 <span class="keyword">static</span> BOOL shouldUpdateNetworkActivityIndicator = YES;
<a name="l00133"></a>00133 
<a name="l00134"></a>00134 <span class="comment">// The thread all requests will run on</span>
<a name="l00135"></a>00135 <span class="comment">// Hangs around forever, but will be blocked unless there are requests underway</span>
<a name="l00136"></a>00136 <span class="keyword">static</span> NSThread *networkThread = nil;
<a name="l00137"></a>00137 
<a name="l00138"></a>00138 <span class="keyword">static</span> NSOperationQueue *sharedQueue = nil;
<a name="l00139"></a>00139 
<a name="l00140"></a>00140 <span class="comment">// Private stuff</span>
<a name="l00141"></a>00141 <span class="keyword">@interface </span>ASIHTTPRequest ()
<a name="l00142"></a>00142 
<a name="l00143"></a>00143 - (void)cancelLoad;
<a name="l00144"></a>00144 
<a name="l00145"></a>00145 - (void)destroyReadStream;
<a name="l00146"></a>00146 - (void)scheduleReadStream;
<a name="l00147"></a>00147 - (void)unscheduleReadStream;
<a name="l00148"></a>00148 
<a name="l00149"></a>00149 - (BOOL)willAskDelegateForCredentials;
<a name="l00150"></a>00150 - (BOOL)willAskDelegateForProxyCredentials;
<a name="l00151"></a>00151 - (void)askDelegateForProxyCredentials;
<a name="l00152"></a>00152 - (void)askDelegateForCredentials;
<a name="l00153"></a>00153 - (void)failAuthentication;
<a name="l00154"></a>00154 
<a name="l00155"></a>00155 + (void)measureBandwidthUsage;
<a name="l00156"></a>00156 + (void)recordBandwidthUsage;
<a name="l00157"></a>00157 
<a name="l00158"></a>00158 - (void)startRequest;
<a name="l00159"></a>00159 - (void)updateStatus:(NSTimer *)timer;
<a name="l00160"></a>00160 - (void)checkRequestStatus;
<a name="l00161"></a>00161 - (void)reportFailure;
<a name="l00162"></a>00162 - (void)reportFinished;
<a name="l00163"></a>00163 - (void)markAsFinished;
<a name="l00164"></a>00164 - (void)performRedirect;
<a name="l00165"></a>00165 - (BOOL)shouldTimeOut;
<a name="l00166"></a>00166 - (BOOL)willRedirect;
<a name="l00167"></a>00167 - (BOOL)willAskDelegateToConfirmRedirect;
<a name="l00168"></a>00168 
<a name="l00169"></a>00169 + (void)performInvocation:(NSInvocation *)invocation onTarget:(<span class="keywordtype">id</span> *)target releasingObject:(<span class="keywordtype">id</span>)objectToRelease;
<a name="l00170"></a>00170 + (void)hideNetworkActivityIndicatorAfterDelay;
<a name="l00171"></a>00171 + (void)hideNetworkActivityIndicatorIfNeeeded;
<a name="l00172"></a>00172 + (void)runRequests;
<a name="l00173"></a>00173 
<a name="l00174"></a>00174 <span class="comment">// Handling Proxy autodetection and PAC file downloads</span>
<a name="l00175"></a>00175 - (BOOL)configureProxies;
<a name="l00176"></a>00176 - (void)fetchPACFile;
<a name="l00177"></a>00177 - (void)finishedDownloadingPACFile:(ASIHTTPRequest *)theRequest;
<a name="l00178"></a>00178 - (void)runPACScript:(<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)script;
<a name="l00179"></a>00179 - (void)timeOutPACRead;
<a name="l00180"></a>00180 
<a name="l00181"></a>00181 - (void)useDataFromCache;
<a name="l00182"></a>00182 
<a name="l00183"></a>00183 <span class="comment">// Called to update the size of a partial download when starting a request, or retrying after a timeout</span>
<a name="l00184"></a>00184 - (void)updatePartialDownloadSize;
<a name="l00185"></a>00185 
<a name="l00186"></a>00186 <span class="preprocessor">#if TARGET_OS_IPHONE</span>
<a name="l00187"></a>00187 <span class="preprocessor"></span>+ (void)registerForNetworkReachabilityNotifications;
<a name="l00188"></a>00188 + (void)unsubscribeFromNetworkReachabilityNotifications;
<a name="l00189"></a>00189 <span class="comment">// Called when the status of the network changes</span>
<a name="l00190"></a>00190 + (void)reachabilityChanged:(NSNotification *)note;
<a name="l00191"></a>00191 <span class="preprocessor">#endif</span>
<a name="l00192"></a>00192 <span class="preprocessor"></span>
<a name="l00193"></a>00193 <span class="preprocessor">#if NS_BLOCKS_AVAILABLE</span>
<a name="l00194"></a>00194 <span class="preprocessor"></span>- (void)performBlockOnMainThread:(ASIBasicBlock)block;
<a name="l00195"></a>00195 - (void)releaseBlocksOnMainThread;
<a name="l00196"></a>00196 + (void)releaseBlocks:(NSArray *)blocks;
<a name="l00197"></a>00197 - (void)callBlock:(ASIBasicBlock)block;
<a name="l00198"></a>00198 <span class="preprocessor">#endif</span>
<a name="l00199"></a>00199 <span class="preprocessor"></span>
<a name="l00200"></a>00200 
<a name="l00201"></a>00201 
<a name="l00202"></a>00202 
<a name="l00203"></a>00203 
<a name="l00204"></a>00204 <span class="keyword">@property</span> (assign) BOOL complete;
<a name="l00205"></a>00205 <span class="keyword">@property</span> (retain) NSArray *responseCookies;
<a name="l00206"></a>00206 <span class="keyword">@property</span> (assign) <span class="keywordtype">int</span> responseStatusCode;
<a name="l00207"></a>00207 <span class="keyword">@property</span> (retain, nonatomic) NSDate *lastActivityTime;
<a name="l00208"></a>00208 
<a name="l00209"></a>00209 <span class="keyword">@property</span> (assign) <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> partialDownloadSize;
<a name="l00210"></a>00210 <span class="keyword">@property</span> (assign, nonatomic) <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> uploadBufferSize;
<a name="l00211"></a>00211 <span class="keyword">@property</span> (retain, nonatomic) NSOutputStream *postBodyWriteStream;
<a name="l00212"></a>00212 <span class="keyword">@property</span> (retain, nonatomic) NSInputStream *postBodyReadStream;
<a name="l00213"></a>00213 <span class="keyword">@property</span> (assign, nonatomic) <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> lastBytesRead;
<a name="l00214"></a>00214 <span class="keyword">@property</span> (assign, nonatomic) <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> lastBytesSent;
<a name="l00215"></a>00215 <span class="keyword">@property</span> (retain) NSRecursiveLock *cancelledLock;
<a name="l00216"></a>00216 <span class="keyword">@property</span> (retain, nonatomic) NSOutputStream *fileDownloadOutputStream;
<a name="l00217"></a>00217 <span class="keyword">@property</span> (retain, nonatomic) NSOutputStream *inflatedFileDownloadOutputStream;
<a name="l00218"></a>00218 <span class="keyword">@property</span> (assign) <span class="keywordtype">int</span> authenticationRetryCount;
<a name="l00219"></a>00219 <span class="keyword">@property</span> (assign) <span class="keywordtype">int</span> proxyAuthenticationRetryCount;
<a name="l00220"></a>00220 <span class="keyword">@property</span> (assign, nonatomic) BOOL updatedProgress;
<a name="l00221"></a>00221 <span class="keyword">@property</span> (assign, nonatomic) BOOL needsRedirect;
<a name="l00222"></a>00222 <span class="keyword">@property</span> (assign, nonatomic) <span class="keywordtype">int</span> redirectCount;
<a name="l00223"></a>00223 <span class="keyword">@property</span> (retain, nonatomic) <a class="code" href="class_n_s_data.html" title="For hashing raw data.">NSData</a> *compressedPostBody;
<a name="l00224"></a>00224 <span class="keyword">@property</span> (retain, nonatomic) <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *compressedPostBodyFilePath;
<a name="l00225"></a>00225 <span class="keyword">@property</span> (retain) <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *authenticationRealm;
<a name="l00226"></a>00226 <span class="keyword">@property</span> (retain) <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *proxyAuthenticationRealm;
<a name="l00227"></a>00227 <span class="keyword">@property</span> (retain) <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *responseStatusMessage;
<a name="l00228"></a>00228 <span class="keyword">@property</span> (assign) BOOL inProgress;
<a name="l00229"></a>00229 <span class="keyword">@property</span> (assign) <span class="keywordtype">int</span> retryCount;
<a name="l00230"></a>00230 <span class="keyword">@property</span> (assign) BOOL willRetryRequest;
<a name="l00231"></a>00231 <span class="keyword">@property</span> (assign) BOOL connectionCanBeReused;
<a name="l00232"></a>00232 <span class="keyword">@property</span> (retain, nonatomic) NSMutableDictionary *connectionInfo;
<a name="l00233"></a>00233 <span class="keyword">@property</span> (retain, nonatomic) NSInputStream *readStream;
<a name="l00234"></a>00234 <span class="keyword">@property</span> (assign) ASIAuthenticationState authenticationNeeded;
<a name="l00235"></a>00235 <span class="keyword">@property</span> (assign, nonatomic) BOOL readStreamIsScheduled;
<a name="l00236"></a>00236 <span class="keyword">@property</span> (assign, nonatomic) BOOL downloadComplete;
<a name="l00237"></a>00237 <span class="keyword">@property</span> (retain) NSNumber *requestID;
<a name="l00238"></a>00238 <span class="keyword">@property</span> (assign, nonatomic) <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *runLoopMode;
<a name="l00239"></a>00239 <span class="keyword">@property</span> (retain, nonatomic) NSTimer *statusTimer;
<a name="l00240"></a>00240 <span class="keyword">@property</span> (assign) BOOL didUseCachedResponse;
<a name="l00241"></a>00241 <span class="keyword">@property</span> (retain, nonatomic) NSURL *redirectURL;
<a name="l00242"></a>00242 
<a name="l00243"></a>00243 <span class="keyword">@property</span> (assign, nonatomic) BOOL isPACFileRequest;
<a name="l00244"></a>00244 <span class="keyword">@property</span> (retain, nonatomic) ASIHTTPRequest *PACFileRequest;
<a name="l00245"></a>00245 <span class="keyword">@property</span> (retain, nonatomic) NSInputStream *PACFileReadStream;
<a name="l00246"></a>00246 <span class="keyword">@property</span> (retain, nonatomic) NSMutableData *PACFileData;
<a name="l00247"></a>00247 
<a name="l00248"></a>00248 <span class="keyword">@property</span> (assign, nonatomic, setter=setSynchronous:) BOOL isSynchronous;
<a name="l00249"></a>00249 <span class="keyword">@end</span>
<a name="l00250"></a>00250 
<a name="l00251"></a>00251 
<a name="l00252"></a>00252 <span class="keyword">@implementation </span>ASIHTTPRequest
<a name="l00253"></a>00253 
<a name="l00254"></a>00254 <span class="preprocessor">#pragma mark init / dealloc</span>
<a name="l00255"></a>00255 <span class="preprocessor"></span>
<a name="l00256"></a>00256 + (void)initialize
<a name="l00257"></a>00257 {
<a name="l00258"></a>00258         <span class="keywordflow">if</span> (<span class="keyword">self</span> == [ASIHTTPRequest <span class="keyword">class</span>]) {
<a name="l00259"></a>00259                 persistentConnectionsPool = [[NSMutableArray alloc] init];
<a name="l00260"></a>00260                 connectionsLock = [[NSRecursiveLock alloc] init];
<a name="l00261"></a>00261                 progressLock = [[NSRecursiveLock alloc] init];
<a name="l00262"></a>00262                 bandwidthThrottlingLock = [[NSLock alloc] init];
<a name="l00263"></a>00263                 sessionCookiesLock = [[NSRecursiveLock alloc] init];
<a name="l00264"></a>00264                 sessionCredentialsLock = [[NSRecursiveLock alloc] init];
<a name="l00265"></a>00265                 delegateAuthenticationLock = [[NSRecursiveLock alloc] init];
<a name="l00266"></a>00266                 bandwidthUsageTracker = [[NSMutableArray alloc] initWithCapacity:5];
<a name="l00267"></a>00267                 ASIRequestTimedOutError = [[NSError alloc] initWithDomain:NetworkRequestErrorDomain code:ASIRequestTimedOutErrorType userInfo:[NSDictionary dictionaryWithObjectsAndKeys:@&quot;The request timed out&quot;,NSLocalizedDescriptionKey,nil]];  
<a name="l00268"></a>00268                 ASIAuthenticationError = [[NSError alloc] initWithDomain:NetworkRequestErrorDomain code:ASIAuthenticationErrorType userInfo:[NSDictionary dictionaryWithObjectsAndKeys:@&quot;Authentication needed&quot;,NSLocalizedDescriptionKey,nil]];
<a name="l00269"></a>00269                 ASIRequestCancelledError = [[NSError alloc] initWithDomain:NetworkRequestErrorDomain code:ASIRequestCancelledErrorType userInfo:[NSDictionary dictionaryWithObjectsAndKeys:@&quot;The request was cancelled&quot;,NSLocalizedDescriptionKey,nil]];
<a name="l00270"></a>00270                 ASIUnableToCreateRequestError = [[NSError alloc] initWithDomain:NetworkRequestErrorDomain code:ASIUnableToCreateRequestErrorType userInfo:[NSDictionary dictionaryWithObjectsAndKeys:@&quot;Unable to create request (bad url?)&quot;,NSLocalizedDescriptionKey,nil]];
<a name="l00271"></a>00271                 ASITooMuchRedirectionError = [[NSError alloc] initWithDomain:NetworkRequestErrorDomain code:ASITooMuchRedirectionErrorType userInfo:[NSDictionary dictionaryWithObjectsAndKeys:@&quot;The request failed because it redirected too many times&quot;,NSLocalizedDescriptionKey,nil]];
<a name="l00272"></a>00272                 sharedQueue = [[NSOperationQueue alloc] init];
<a name="l00273"></a>00273                 [sharedQueue setMaxConcurrentOperationCount:4];
<a name="l00274"></a>00274 
<a name="l00275"></a>00275         }
<a name="l00276"></a>00276 }
<a name="l00277"></a>00277 
<a name="l00278"></a>00278 
<a name="l00279"></a>00279 - (id)initWithURL:(NSURL *)newURL
<a name="l00280"></a>00280 {
<a name="l00281"></a>00281         <span class="keyword">self</span> = [<span class="keyword">self</span> init];
<a name="l00282"></a>00282         [<span class="keyword">self</span> setRequestMethod:@&quot;GET&quot;];
<a name="l00283"></a>00283 
<a name="l00284"></a>00284         [<span class="keyword">self</span> setRunLoopMode:NSDefaultRunLoopMode];
<a name="l00285"></a>00285         [<span class="keyword">self</span> setShouldAttemptPersistentConnection:YES];
<a name="l00286"></a>00286         [<span class="keyword">self</span> setPersistentConnectionTimeoutSeconds:60.0];
<a name="l00287"></a>00287         [<span class="keyword">self</span> setShouldPresentCredentialsBeforeChallenge:YES];
<a name="l00288"></a>00288         [<span class="keyword">self</span> setShouldRedirect:YES];
<a name="l00289"></a>00289         [<span class="keyword">self</span> setShowAccurateProgress:YES];
<a name="l00290"></a>00290         [<span class="keyword">self</span> setShouldResetDownloadProgress:YES];
<a name="l00291"></a>00291         [<span class="keyword">self</span> setShouldResetUploadProgress:YES];
<a name="l00292"></a>00292         [<span class="keyword">self</span> setAllowCompressedResponse:YES];
<a name="l00293"></a>00293         [<span class="keyword">self</span> setShouldWaitToInflateCompressedResponses:YES];
<a name="l00294"></a>00294         [<span class="keyword">self</span> setDefaultResponseEncoding:NSISOLatin1StringEncoding];
<a name="l00295"></a>00295         [<span class="keyword">self</span> setShouldPresentProxyAuthenticationDialog:YES];
<a name="l00296"></a>00296         
<a name="l00297"></a>00297         [<span class="keyword">self</span> setTimeOutSeconds:[ASIHTTPRequest defaultTimeOutSeconds]];
<a name="l00298"></a>00298         [<span class="keyword">self</span> setUseSessionPersistence:YES];
<a name="l00299"></a>00299         [<span class="keyword">self</span> setUseCookiePersistence:YES];
<a name="l00300"></a>00300         [<span class="keyword">self</span> setValidatesSecureCertificate:YES];
<a name="l00301"></a>00301         [<span class="keyword">self</span> setRequestCookies:[[[NSMutableArray alloc] init] autorelease]];
<a name="l00302"></a>00302         [<span class="keyword">self</span> setDidStartSelector:@selector(requestStarted:)];
<a name="l00303"></a>00303         [<span class="keyword">self</span> setDidReceiveResponseHeadersSelector:@selector(request:didReceiveResponseHeaders:)];
<a name="l00304"></a>00304         [<span class="keyword">self</span> setWillRedirectSelector:@selector(request:willRedirectToURL:)];
<a name="l00305"></a>00305         [<span class="keyword">self</span> setDidFinishSelector:@selector(requestFinished:)];
<a name="l00306"></a>00306         [<span class="keyword">self</span> setDidFailSelector:@selector(requestFailed:)];
<a name="l00307"></a>00307         [<span class="keyword">self</span> setDidReceiveDataSelector:@selector(request:didReceiveData:)];
<a name="l00308"></a>00308         [<span class="keyword">self</span> setURL:newURL];
<a name="l00309"></a>00309         [<span class="keyword">self</span> setCancelledLock:[[[NSRecursiveLock alloc] init] autorelease]];
<a name="l00310"></a>00310         [<span class="keyword">self</span> setDownloadCache:[[<span class="keyword">self</span> class] defaultCache]];
<a name="l00311"></a>00311         <span class="keywordflow">return</span> <span class="keyword">self</span>;
<a name="l00312"></a>00312 }
<a name="l00313"></a>00313 
<a name="l00314"></a>00314 + (id)requestWithURL:(NSURL *)newURL
<a name="l00315"></a>00315 {
<a name="l00316"></a>00316         <span class="keywordflow">return</span> [[[<span class="keyword">self</span> alloc] initWithURL:newURL] autorelease];
<a name="l00317"></a>00317 }
<a name="l00318"></a>00318 
<a name="l00319"></a>00319 + (id)requestWithURL:(NSURL *)newURL usingCache:(<span class="keywordtype">id</span> &lt;ASICacheDelegate&gt;)cache
<a name="l00320"></a>00320 {
<a name="l00321"></a>00321         <span class="keywordflow">return</span> [<span class="keyword">self</span> requestWithURL:newURL usingCache:cache andCachePolicy:ASIUseDefaultCachePolicy];
<a name="l00322"></a>00322 }
<a name="l00323"></a>00323 
<a name="l00324"></a>00324 + (id)requestWithURL:(NSURL *)newURL usingCache:(<span class="keywordtype">id</span> &lt;ASICacheDelegate&gt;)cache andCachePolicy:(ASICachePolicy)policy
<a name="l00325"></a>00325 {
<a name="l00326"></a>00326         ASIHTTPRequest *request = [[[<span class="keyword">self</span> alloc] initWithURL:newURL] autorelease];
<a name="l00327"></a>00327         [request setDownloadCache:cache];
<a name="l00328"></a>00328         [request setCachePolicy:policy];
<a name="l00329"></a>00329         <span class="keywordflow">return</span> request;
<a name="l00330"></a>00330 }
<a name="l00331"></a>00331 
<a name="l00332"></a>00332 - (void)dealloc
<a name="l00333"></a>00333 {
<a name="l00334"></a>00334         [<span class="keyword">self</span> setAuthenticationNeeded:ASINoAuthenticationNeededYet];
<a name="l00335"></a>00335         <span class="keywordflow">if</span> (requestAuthentication) {
<a name="l00336"></a>00336                 CFRelease(requestAuthentication);
<a name="l00337"></a>00337         }
<a name="l00338"></a>00338         <span class="keywordflow">if</span> (proxyAuthentication) {
<a name="l00339"></a>00339                 CFRelease(proxyAuthentication);
<a name="l00340"></a>00340         }
<a name="l00341"></a>00341         <span class="keywordflow">if</span> (request) {
<a name="l00342"></a>00342                 CFRelease(request);
<a name="l00343"></a>00343         }
<a name="l00344"></a>00344         <span class="keywordflow">if</span> (clientCertificateIdentity) {
<a name="l00345"></a>00345                 CFRelease(clientCertificateIdentity);
<a name="l00346"></a>00346         }
<a name="l00347"></a>00347         [<span class="keyword">self</span> cancelLoad];
<a name="l00348"></a>00348         [redirectURL release];
<a name="l00349"></a>00349         [statusTimer invalidate];
<a name="l00350"></a>00350         [statusTimer release];
<a name="l00351"></a>00351         [queue release];
<a name="l00352"></a>00352         [userInfo release];
<a name="l00353"></a>00353         [postBody release];
<a name="l00354"></a>00354         [compressedPostBody release];
<a name="l00355"></a>00355         [error release];
<a name="l00356"></a>00356         [requestHeaders release];
<a name="l00357"></a>00357         [requestCookies release];
<a name="l00358"></a>00358         [downloadDestinationPath release];
<a name="l00359"></a>00359         [temporaryFileDownloadPath release];
<a name="l00360"></a>00360         [temporaryUncompressedDataDownloadPath release];
<a name="l00361"></a>00361         [fileDownloadOutputStream release];
<a name="l00362"></a>00362         [inflatedFileDownloadOutputStream release];
<a name="l00363"></a>00363         [username release];
<a name="l00364"></a>00364         [password release];
<a name="l00365"></a>00365         [domain release];
<a name="l00366"></a>00366         [authenticationRealm release];
<a name="l00367"></a>00367         [authenticationScheme release];
<a name="l00368"></a>00368         [requestCredentials release];
<a name="l00369"></a>00369         [proxyHost release];
<a name="l00370"></a>00370         [proxyType release];
<a name="l00371"></a>00371         [proxyUsername release];
<a name="l00372"></a>00372         [proxyPassword release];
<a name="l00373"></a>00373         [proxyDomain release];
<a name="l00374"></a>00374         [proxyAuthenticationRealm release];
<a name="l00375"></a>00375         [proxyAuthenticationScheme release];
<a name="l00376"></a>00376         [proxyCredentials release];
<a name="l00377"></a>00377         [url release];
<a name="l00378"></a>00378         [originalURL release];
<a name="l00379"></a>00379         [lastActivityTime release];
<a name="l00380"></a>00380         [responseCookies release];
<a name="l00381"></a>00381         [rawResponseData release];
<a name="l00382"></a>00382         [responseHeaders release];
<a name="l00383"></a>00383         [requestMethod release];
<a name="l00384"></a>00384         [cancelledLock release];
<a name="l00385"></a>00385         [postBodyFilePath release];
<a name="l00386"></a>00386         [compressedPostBodyFilePath release];
<a name="l00387"></a>00387         [postBodyWriteStream release];
<a name="l00388"></a>00388         [postBodyReadStream release];
<a name="l00389"></a>00389         [PACurl release];
<a name="l00390"></a>00390         [clientCertificates release];
<a name="l00391"></a>00391         [responseStatusMessage release];
<a name="l00392"></a>00392         [connectionInfo release];
<a name="l00393"></a>00393         [requestID release];
<a name="l00394"></a>00394         [dataDecompressor release];
<a name="l00395"></a>00395         [userAgent release];
<a name="l00396"></a>00396 
<a name="l00397"></a>00397 <span class="preprocessor">        #if NS_BLOCKS_AVAILABLE</span>
<a name="l00398"></a>00398 <span class="preprocessor"></span>        [<span class="keyword">self</span> releaseBlocksOnMainThread];
<a name="l00399"></a>00399 <span class="preprocessor">        #endif</span>
<a name="l00400"></a>00400 <span class="preprocessor"></span>
<a name="l00401"></a>00401         [<span class="keyword">super</span> dealloc];
<a name="l00402"></a>00402 }
<a name="l00403"></a>00403 
<a name="l00404"></a>00404 <span class="preprocessor">#if NS_BLOCKS_AVAILABLE</span>
<a name="l00405"></a>00405 <span class="preprocessor"></span>- (void)releaseBlocksOnMainThread
<a name="l00406"></a>00406 {
<a name="l00407"></a>00407         NSMutableArray *blocks = [NSMutableArray array];
<a name="l00408"></a>00408         <span class="keywordflow">if</span> (completionBlock) {
<a name="l00409"></a>00409                 [blocks addObject:completionBlock];
<a name="l00410"></a>00410                 [completionBlock release];
<a name="l00411"></a>00411                 completionBlock = nil;
<a name="l00412"></a>00412         }
<a name="l00413"></a>00413         <span class="keywordflow">if</span> (failureBlock) {
<a name="l00414"></a>00414                 [blocks addObject:failureBlock];
<a name="l00415"></a>00415                 [failureBlock release];
<a name="l00416"></a>00416                 failureBlock = nil;
<a name="l00417"></a>00417         }
<a name="l00418"></a>00418         <span class="keywordflow">if</span> (startedBlock) {
<a name="l00419"></a>00419                 [blocks addObject:startedBlock];
<a name="l00420"></a>00420                 [startedBlock release];
<a name="l00421"></a>00421                 startedBlock = nil;
<a name="l00422"></a>00422         }
<a name="l00423"></a>00423         <span class="keywordflow">if</span> (headersReceivedBlock) {
<a name="l00424"></a>00424                 [blocks addObject:headersReceivedBlock];
<a name="l00425"></a>00425                 [headersReceivedBlock release];
<a name="l00426"></a>00426                 headersReceivedBlock = nil;
<a name="l00427"></a>00427         }
<a name="l00428"></a>00428         <span class="keywordflow">if</span> (bytesReceivedBlock) {
<a name="l00429"></a>00429                 [blocks addObject:bytesReceivedBlock];
<a name="l00430"></a>00430                 [bytesReceivedBlock release];
<a name="l00431"></a>00431                 bytesReceivedBlock = nil;
<a name="l00432"></a>00432         }
<a name="l00433"></a>00433         <span class="keywordflow">if</span> (bytesSentBlock) {
<a name="l00434"></a>00434                 [blocks addObject:bytesSentBlock];
<a name="l00435"></a>00435                 [bytesSentBlock release];
<a name="l00436"></a>00436                 bytesSentBlock = nil;
<a name="l00437"></a>00437         }
<a name="l00438"></a>00438         <span class="keywordflow">if</span> (downloadSizeIncrementedBlock) {
<a name="l00439"></a>00439                 [blocks addObject:downloadSizeIncrementedBlock];
<a name="l00440"></a>00440                 [downloadSizeIncrementedBlock release];
<a name="l00441"></a>00441                 downloadSizeIncrementedBlock = nil;
<a name="l00442"></a>00442         }
<a name="l00443"></a>00443         <span class="keywordflow">if</span> (uploadSizeIncrementedBlock) {
<a name="l00444"></a>00444                 [blocks addObject:uploadSizeIncrementedBlock];
<a name="l00445"></a>00445                 [uploadSizeIncrementedBlock release];
<a name="l00446"></a>00446                 uploadSizeIncrementedBlock = nil;
<a name="l00447"></a>00447         }
<a name="l00448"></a>00448         <span class="keywordflow">if</span> (dataReceivedBlock) {
<a name="l00449"></a>00449                 [blocks addObject:dataReceivedBlock];
<a name="l00450"></a>00450                 [dataReceivedBlock release];
<a name="l00451"></a>00451                 dataReceivedBlock = nil;
<a name="l00452"></a>00452         }
<a name="l00453"></a>00453         <span class="keywordflow">if</span> (proxyAuthenticationNeededBlock) {
<a name="l00454"></a>00454                 [blocks addObject:proxyAuthenticationNeededBlock];
<a name="l00455"></a>00455                 [proxyAuthenticationNeededBlock release];
<a name="l00456"></a>00456                 proxyAuthenticationNeededBlock = nil;
<a name="l00457"></a>00457         }
<a name="l00458"></a>00458         <span class="keywordflow">if</span> (authenticationNeededBlock) {
<a name="l00459"></a>00459                 [blocks addObject:authenticationNeededBlock];
<a name="l00460"></a>00460                 [authenticationNeededBlock release];
<a name="l00461"></a>00461                 authenticationNeededBlock = nil;
<a name="l00462"></a>00462         }
<a name="l00463"></a>00463         [[<span class="keyword">self</span> class] performSelectorOnMainThread:@selector(releaseBlocks:) withObject:blocks waitUntilDone:[NSThread isMainThread]];
<a name="l00464"></a>00464 }
<a name="l00465"></a>00465 <span class="comment">// Always called on main thread</span>
<a name="l00466"></a>00466 + (void)releaseBlocks:(NSArray *)blocks
<a name="l00467"></a>00467 {
<a name="l00468"></a>00468         <span class="comment">// Blocks will be released when this method exits</span>
<a name="l00469"></a>00469 }
<a name="l00470"></a>00470 <span class="preprocessor">#endif</span>
<a name="l00471"></a>00471 <span class="preprocessor"></span>
<a name="l00472"></a>00472 
<a name="l00473"></a>00473 <span class="preprocessor">#pragma mark setup request</span>
<a name="l00474"></a>00474 <span class="preprocessor"></span>
<a name="l00475"></a>00475 - (void)addRequestHeader:(<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)header value:(<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)value
<a name="l00476"></a>00476 {
<a name="l00477"></a>00477         <span class="keywordflow">if</span> (!requestHeaders) {
<a name="l00478"></a>00478                 [<span class="keyword">self</span> setRequestHeaders:[NSMutableDictionary dictionaryWithCapacity:1]];
<a name="l00479"></a>00479         }
<a name="l00480"></a>00480         [requestHeaders setObject:value forKey:header];
<a name="l00481"></a>00481 }
<a name="l00482"></a>00482 
<a name="l00483"></a>00483 <span class="comment">// This function will be called either just before a request starts, or when postLength is needed, whichever comes first</span>
<a name="l00484"></a>00484 <span class="comment">// postLength must be set by the time this function is complete</span>
<a name="l00485"></a>00485 - (void)buildPostBody
<a name="l00486"></a>00486 {
<a name="l00487"></a>00487 
<a name="l00488"></a>00488         <span class="keywordflow">if</span> ([<span class="keyword">self</span> haveBuiltPostBody]) {
<a name="l00489"></a>00489                 <span class="keywordflow">return</span>;
<a name="l00490"></a>00490         }
<a name="l00491"></a>00491         
<a name="l00492"></a>00492         <span class="comment">// Are we submitting the request body from a file on disk</span>
<a name="l00493"></a>00493         <span class="keywordflow">if</span> ([<span class="keyword">self</span> postBodyFilePath]) {
<a name="l00494"></a>00494                 
<a name="l00495"></a>00495                 <span class="comment">// If we were writing to the post body via appendPostData or appendPostDataFromFile, close the write stream</span>
<a name="l00496"></a>00496                 <span class="keywordflow">if</span> ([<span class="keyword">self</span> postBodyWriteStream]) {
<a name="l00497"></a>00497                         [[<span class="keyword">self</span> postBodyWriteStream] close];
<a name="l00498"></a>00498                         [<span class="keyword">self</span> setPostBodyWriteStream:nil];
<a name="l00499"></a>00499                 }
<a name="l00500"></a>00500 
<a name="l00501"></a>00501                 
<a name="l00502"></a>00502                 <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *path;
<a name="l00503"></a>00503                 <span class="keywordflow">if</span> ([<span class="keyword">self</span> shouldCompressRequestBody]) {
<a name="l00504"></a>00504                         <span class="keywordflow">if</span> (![<span class="keyword">self</span> compressedPostBodyFilePath]) {
<a name="l00505"></a>00505                                 [<span class="keyword">self</span> setCompressedPostBodyFilePath:[NSTemporaryDirectory() stringByAppendingPathComponent:[[NSProcessInfo processInfo] globallyUniqueString]]];
<a name="l00506"></a>00506                                 
<a name="l00507"></a>00507                                 NSError *err = nil;
<a name="l00508"></a>00508                                 <span class="keywordflow">if</span> (![ASIDataCompressor compressDataFromFile:[<span class="keyword">self</span> postBodyFilePath] toFile:[<span class="keyword">self</span> compressedPostBodyFilePath] error:&amp;err]) {
<a name="l00509"></a>00509                                         [<span class="keyword">self</span> failWithError:err];
<a name="l00510"></a>00510                                         <span class="keywordflow">return</span>;
<a name="l00511"></a>00511                                 }
<a name="l00512"></a>00512                         }
<a name="l00513"></a>00513                         path = [<span class="keyword">self</span> compressedPostBodyFilePath];
<a name="l00514"></a>00514                 } <span class="keywordflow">else</span> {
<a name="l00515"></a>00515                         path = [<span class="keyword">self</span> postBodyFilePath];
<a name="l00516"></a>00516                 }
<a name="l00517"></a>00517                 NSError *err = nil;
<a name="l00518"></a>00518                 [<span class="keyword">self</span> setPostLength:[[[[[NSFileManager alloc] init] autorelease] attributesOfItemAtPath:path error:&amp;err] fileSize]];
<a name="l00519"></a>00519                 <span class="keywordflow">if</span> (err) {
<a name="l00520"></a>00520                         [<span class="keyword">self</span> failWithError:[NSError errorWithDomain:NetworkRequestErrorDomain code:ASIFileManagementError userInfo:[NSDictionary dictionaryWithObjectsAndKeys:[<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> stringWithFormat:@&quot;Failed to get attributes for file at path &#39;%@&#39;&quot;,path],NSLocalizedDescriptionKey,error,NSUnderlyingErrorKey,nil]]];
<a name="l00521"></a>00521                         <span class="keywordflow">return</span>;
<a name="l00522"></a>00522                 }
<a name="l00523"></a>00523                 
<a name="l00524"></a>00524         <span class="comment">// Otherwise, we have an in-memory request body</span>
<a name="l00525"></a>00525         } <span class="keywordflow">else</span> {
<a name="l00526"></a>00526                 <span class="keywordflow">if</span> ([<span class="keyword">self</span> shouldCompressRequestBody]) {
<a name="l00527"></a>00527                         NSError *err = nil;
<a name="l00528"></a>00528                         <a class="code" href="class_n_s_data.html" title="For hashing raw data.">NSData</a> *compressedBody = [ASIDataCompressor compressData:[<span class="keyword">self</span> postBody] error:&amp;err];
<a name="l00529"></a>00529                         <span class="keywordflow">if</span> (err) {
<a name="l00530"></a>00530                                 [<span class="keyword">self</span> failWithError:err];
<a name="l00531"></a>00531                                 <span class="keywordflow">return</span>;
<a name="l00532"></a>00532                         }
<a name="l00533"></a>00533                         [<span class="keyword">self</span> setCompressedPostBody:compressedBody];
<a name="l00534"></a>00534                         [<span class="keyword">self</span> setPostLength:[[<span class="keyword">self</span> compressedPostBody] length]];
<a name="l00535"></a>00535                 } <span class="keywordflow">else</span> {
<a name="l00536"></a>00536                         [<span class="keyword">self</span> setPostLength:[[<span class="keyword">self</span> postBody] length]];
<a name="l00537"></a>00537                 }
<a name="l00538"></a>00538         }
<a name="l00539"></a>00539                 
<a name="l00540"></a>00540         <span class="keywordflow">if</span> ([<span class="keyword">self</span> postLength] &gt; 0) {
<a name="l00541"></a>00541                 <span class="keywordflow">if</span> ([requestMethod isEqualToString:<span class="stringliteral">@&quot;GET&quot;</span>] || [requestMethod isEqualToString:<span class="stringliteral">@&quot;DELETE&quot;</span>] || [requestMethod isEqualToString:<span class="stringliteral">@&quot;HEAD&quot;</span>]) {
<a name="l00542"></a>00542                         [<span class="keyword">self</span> setRequestMethod:@&quot;POST&quot;];
<a name="l00543"></a>00543                 }
<a name="l00544"></a>00544                 [<span class="keyword">self</span> addRequestHeader:@&quot;Content-Length&quot; value:[<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> stringWithFormat:@&quot;%llu&quot;,[<span class="keyword">self</span> postLength]]];
<a name="l00545"></a>00545         }
<a name="l00546"></a>00546         [<span class="keyword">self</span> setHaveBuiltPostBody:YES];
<a name="l00547"></a>00547 
<a name="l00548"></a>00548 }
<a name="l00549"></a>00549 
<a name="l00550"></a>00550 <span class="comment">// Sets up storage for the post body</span>
<a name="l00551"></a>00551 - (void)setupPostBody
<a name="l00552"></a>00552 {
<a name="l00553"></a>00553         <span class="keywordflow">if</span> ([<span class="keyword">self</span> shouldStreamPostDataFromDisk]) {
<a name="l00554"></a>00554                 <span class="keywordflow">if</span> (![<span class="keyword">self</span> postBodyFilePath]) {
<a name="l00555"></a>00555                         [<span class="keyword">self</span> setPostBodyFilePath:[NSTemporaryDirectory() stringByAppendingPathComponent:[[NSProcessInfo processInfo] globallyUniqueString]]];
<a name="l00556"></a>00556                         [<span class="keyword">self</span> setDidCreateTemporaryPostDataFile:YES];
<a name="l00557"></a>00557                 }
<a name="l00558"></a>00558                 <span class="keywordflow">if</span> (![<span class="keyword">self</span> postBodyWriteStream]) {
<a name="l00559"></a>00559                         [<span class="keyword">self</span> setPostBodyWriteStream:[[[NSOutputStream alloc] initToFileAtPath:[<span class="keyword">self</span> postBodyFilePath] append:NO] autorelease]];
<a name="l00560"></a>00560                         [[<span class="keyword">self</span> postBodyWriteStream] open];
<a name="l00561"></a>00561                 }
<a name="l00562"></a>00562         } <span class="keywordflow">else</span> {
<a name="l00563"></a>00563                 <span class="keywordflow">if</span> (![<span class="keyword">self</span> postBody]) {
<a name="l00564"></a>00564                         [<span class="keyword">self</span> setPostBody:[[[NSMutableData alloc] init] autorelease]];
<a name="l00565"></a>00565                 }
<a name="l00566"></a>00566         }       
<a name="l00567"></a>00567 }
<a name="l00568"></a>00568 
<a name="l00569"></a>00569 - (void)appendPostData:(<a class="code" href="class_n_s_data.html" title="For hashing raw data.">NSData</a> *)data
<a name="l00570"></a>00570 {
<a name="l00571"></a>00571         [<span class="keyword">self</span> setupPostBody];
<a name="l00572"></a>00572         <span class="keywordflow">if</span> ([data length] == 0) {
<a name="l00573"></a>00573                 <span class="keywordflow">return</span>;
<a name="l00574"></a>00574         }
<a name="l00575"></a>00575         <span class="keywordflow">if</span> ([<span class="keyword">self</span> shouldStreamPostDataFromDisk]) {
<a name="l00576"></a>00576                 [[<span class="keyword">self</span> postBodyWriteStream] write:[data bytes] maxLength:[data length]];
<a name="l00577"></a>00577         } <span class="keywordflow">else</span> {
<a name="l00578"></a>00578                 [[<span class="keyword">self</span> postBody] appendData:data];
<a name="l00579"></a>00579         }
<a name="l00580"></a>00580 }
<a name="l00581"></a>00581 
<a name="l00582"></a>00582 - (void)appendPostDataFromFile:(<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)file
<a name="l00583"></a>00583 {
<a name="l00584"></a>00584         [<span class="keyword">self</span> setupPostBody];
<a name="l00585"></a>00585         NSInputStream *stream = [[[NSInputStream alloc] initWithFileAtPath:file] autorelease];
<a name="l00586"></a>00586         [stream open];
<a name="l00587"></a>00587         NSUInteger bytesRead;
<a name="l00588"></a>00588         <span class="keywordflow">while</span> ([stream hasBytesAvailable]) {
<a name="l00589"></a>00589                 
<a name="l00590"></a>00590                 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> buffer[1024*256];
<a name="l00591"></a>00591                 bytesRead = [stream read:buffer maxLength:sizeof(buffer)];
<a name="l00592"></a>00592                 <span class="keywordflow">if</span> (bytesRead == 0) {
<a name="l00593"></a>00593                         <span class="keywordflow">break</span>;
<a name="l00594"></a>00594                 }
<a name="l00595"></a>00595                 <span class="keywordflow">if</span> ([<span class="keyword">self</span> shouldStreamPostDataFromDisk]) {
<a name="l00596"></a>00596                         [[<span class="keyword">self</span> postBodyWriteStream] write:buffer maxLength:bytesRead];
<a name="l00597"></a>00597                 } <span class="keywordflow">else</span> {
<a name="l00598"></a>00598                         [[<span class="keyword">self</span> postBody] appendData:[<a class="code" href="class_n_s_data.html" title="For hashing raw data.">NSData</a> dataWithBytes:buffer length:bytesRead]];
<a name="l00599"></a>00599                 }
<a name="l00600"></a>00600         }
<a name="l00601"></a>00601         [stream close];
<a name="l00602"></a>00602 }
<a name="l00603"></a>00603 
<a name="l00604"></a>00604 - (<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)requestMethod
<a name="l00605"></a>00605 {
<a name="l00606"></a>00606         [[<span class="keyword">self</span> cancelledLock] lock];
<a name="l00607"></a>00607         <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *m = requestMethod;
<a name="l00608"></a>00608         [[<span class="keyword">self</span> cancelledLock] unlock];
<a name="l00609"></a>00609         <span class="keywordflow">return</span> m;
<a name="l00610"></a>00610 }
<a name="l00611"></a>00611 
<a name="l00612"></a>00612 - (void)setRequestMethod:(<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)newRequestMethod
<a name="l00613"></a>00613 {
<a name="l00614"></a>00614         [[<span class="keyword">self</span> cancelledLock] lock];
<a name="l00615"></a>00615         <span class="keywordflow">if</span> (requestMethod != newRequestMethod) {
<a name="l00616"></a>00616                 [requestMethod release];
<a name="l00617"></a>00617                 requestMethod = [newRequestMethod retain];
<a name="l00618"></a>00618                 <span class="keywordflow">if</span> ([requestMethod isEqualToString:<span class="stringliteral">@&quot;POST&quot;</span>] || [requestMethod isEqualToString:<span class="stringliteral">@&quot;PUT&quot;</span>] || [postBody length] || postBodyFilePath) {
<a name="l00619"></a>00619                         [<span class="keyword">self</span> setShouldAttemptPersistentConnection:NO];
<a name="l00620"></a>00620                 }
<a name="l00621"></a>00621         }
<a name="l00622"></a>00622         [[<span class="keyword">self</span> cancelledLock] unlock];
<a name="l00623"></a>00623 }
<a name="l00624"></a>00624 
<a name="l00625"></a>00625 - (NSURL *)url
<a name="l00626"></a>00626 {
<a name="l00627"></a>00627         [[<span class="keyword">self</span> cancelledLock] lock];
<a name="l00628"></a>00628         NSURL *u = url;
<a name="l00629"></a>00629         [[<span class="keyword">self</span> cancelledLock] unlock];
<a name="l00630"></a>00630         <span class="keywordflow">return</span> u;
<a name="l00631"></a>00631 }
<a name="l00632"></a>00632 
<a name="l00633"></a>00633 
<a name="l00634"></a>00634 - (void)setURL:(NSURL *)newURL
<a name="l00635"></a>00635 {
<a name="l00636"></a>00636         [[<span class="keyword">self</span> cancelledLock] lock];
<a name="l00637"></a>00637         <span class="keywordflow">if</span> ([newURL isEqual:[<span class="keyword">self</span> url]]) {
<a name="l00638"></a>00638                 [[<span class="keyword">self</span> cancelledLock] unlock];
<a name="l00639"></a>00639                 <span class="keywordflow">return</span>;
<a name="l00640"></a>00640         }
<a name="l00641"></a>00641         [url release];
<a name="l00642"></a>00642         url = [newURL retain];
<a name="l00643"></a>00643         <span class="keywordflow">if</span> (requestAuthentication) {
<a name="l00644"></a>00644                 CFRelease(requestAuthentication);
<a name="l00645"></a>00645                 requestAuthentication = NULL;
<a name="l00646"></a>00646         }
<a name="l00647"></a>00647         <span class="keywordflow">if</span> (proxyAuthentication) {
<a name="l00648"></a>00648                 CFRelease(proxyAuthentication);
<a name="l00649"></a>00649                 proxyAuthentication = NULL;
<a name="l00650"></a>00650         }
<a name="l00651"></a>00651         <span class="keywordflow">if</span> (request) {
<a name="l00652"></a>00652                 CFRelease(request);
<a name="l00653"></a>00653                 request = NULL;
<a name="l00654"></a>00654         }
<a name="l00655"></a>00655         [<span class="keyword">self</span> setRedirectURL:nil];
<a name="l00656"></a>00656         [[<span class="keyword">self</span> cancelledLock] unlock];
<a name="l00657"></a>00657 }
<a name="l00658"></a>00658 
<a name="l00659"></a>00659 - (id)delegate
<a name="l00660"></a>00660 {
<a name="l00661"></a>00661         [[<span class="keyword">self</span> cancelledLock] lock];
<a name="l00662"></a>00662         <span class="keywordtype">id</span> d = delegate;
<a name="l00663"></a>00663         [[<span class="keyword">self</span> cancelledLock] unlock];
<a name="l00664"></a>00664         <span class="keywordflow">return</span> d;
<a name="l00665"></a>00665 }
<a name="l00666"></a>00666 
<a name="l00667"></a>00667 - (void)setDelegate:(<span class="keywordtype">id</span>)newDelegate
<a name="l00668"></a>00668 {
<a name="l00669"></a>00669         [[<span class="keyword">self</span> cancelledLock] lock];
<a name="l00670"></a>00670         delegate = newDelegate;
<a name="l00671"></a>00671         [[<span class="keyword">self</span> cancelledLock] unlock];
<a name="l00672"></a>00672 }
<a name="l00673"></a>00673 
<a name="l00674"></a>00674 - (id)queue
<a name="l00675"></a>00675 {
<a name="l00676"></a>00676         [[<span class="keyword">self</span> cancelledLock] lock];
<a name="l00677"></a>00677         <span class="keywordtype">id</span> q = queue;
<a name="l00678"></a>00678         [[<span class="keyword">self</span> cancelledLock] unlock];
<a name="l00679"></a>00679         <span class="keywordflow">return</span> q;
<a name="l00680"></a>00680 }
<a name="l00681"></a>00681 
<a name="l00682"></a>00682 
<a name="l00683"></a>00683 - (void)setQueue:(<span class="keywordtype">id</span>)newQueue
<a name="l00684"></a>00684 {
<a name="l00685"></a>00685         [[<span class="keyword">self</span> cancelledLock] lock];
<a name="l00686"></a>00686         <span class="keywordflow">if</span> (newQueue != queue) {
<a name="l00687"></a>00687                 [queue release];
<a name="l00688"></a>00688                 queue = [newQueue retain];
<a name="l00689"></a>00689         }
<a name="l00690"></a>00690         [[<span class="keyword">self</span> cancelledLock] unlock];
<a name="l00691"></a>00691 }
<a name="l00692"></a>00692 
<a name="l00693"></a>00693 <span class="preprocessor">#pragma mark get information about this request</span>
<a name="l00694"></a>00694 <span class="preprocessor"></span>
<a name="l00695"></a>00695 <span class="comment">// cancel the request - this must be run on the same thread as the request is running on</span>
<a name="l00696"></a>00696 - (void)cancelOnRequestThread
<a name="l00697"></a>00697 {
<a name="l00698"></a>00698 <span class="preprocessor">        #if DEBUG_REQUEST_STATUS</span>
<a name="l00699"></a>00699 <span class="preprocessor"></span>        NSLog(<span class="stringliteral">@&quot;[STATUS] Request cancelled: %@&quot;</span>,<span class="keyword">self</span>);
<a name="l00700"></a>00700 <span class="preprocessor">        #endif</span>
<a name="l00701"></a>00701 <span class="preprocessor"></span>    
<a name="l00702"></a>00702         [[<span class="keyword">self</span> cancelledLock] lock];
<a name="l00703"></a>00703 
<a name="l00704"></a>00704     <span class="keywordflow">if</span> ([<span class="keyword">self</span> isCancelled] || [<span class="keyword">self</span> complete]) {
<a name="l00705"></a>00705                 [[<span class="keyword">self</span> cancelledLock] unlock];
<a name="l00706"></a>00706                 <span class="keywordflow">return</span>;
<a name="l00707"></a>00707         }
<a name="l00708"></a>00708         [<span class="keyword">self</span> failWithError:ASIRequestCancelledError];
<a name="l00709"></a>00709         [<span class="keyword">self</span> setComplete:YES];
<a name="l00710"></a>00710         [<span class="keyword">self</span> cancelLoad];
<a name="l00711"></a>00711         
<a name="l00712"></a>00712         CFRetain(<span class="keyword">self</span>);
<a name="l00713"></a>00713     [<span class="keyword">self</span> willChangeValueForKey:@&quot;isCancelled&quot;];
<a name="l00714"></a>00714     cancelled = YES;
<a name="l00715"></a>00715     [<span class="keyword">self</span> didChangeValueForKey:@&quot;isCancelled&quot;];
<a name="l00716"></a>00716     
<a name="l00717"></a>00717         [[<span class="keyword">self</span> cancelledLock] unlock];
<a name="l00718"></a>00718         CFRelease(<span class="keyword">self</span>);
<a name="l00719"></a>00719 }
<a name="l00720"></a>00720 
<a name="l00721"></a>00721 - (void)cancel
<a name="l00722"></a>00722 {
<a name="l00723"></a>00723     [<span class="keyword">self</span> performSelector:@selector(cancelOnRequestThread) onThread:[[<span class="keyword">self</span> class] threadForRequest:self] withObject:nil waitUntilDone:NO];    
<a name="l00724"></a>00724 }
<a name="l00725"></a>00725 
<a name="l00726"></a>00726 - (void)clearDelegatesAndCancel
<a name="l00727"></a>00727 {
<a name="l00728"></a>00728         [[<span class="keyword">self</span> cancelledLock] lock];
<a name="l00729"></a>00729 
<a name="l00730"></a>00730         <span class="comment">// Clear delegates</span>
<a name="l00731"></a>00731         [<span class="keyword">self</span> setDelegate:nil];
<a name="l00732"></a>00732         [<span class="keyword">self</span> setQueue:nil];
<a name="l00733"></a>00733         [<span class="keyword">self</span> setDownloadProgressDelegate:nil];
<a name="l00734"></a>00734         [<span class="keyword">self</span> setUploadProgressDelegate:nil];
<a name="l00735"></a>00735 
<a name="l00736"></a>00736 <span class="preprocessor">        #if NS_BLOCKS_AVAILABLE</span>
<a name="l00737"></a>00737 <span class="preprocessor"></span>        <span class="comment">// Clear blocks</span>
<a name="l00738"></a>00738         [<span class="keyword">self</span> releaseBlocksOnMainThread];
<a name="l00739"></a>00739 <span class="preprocessor">        #endif</span>
<a name="l00740"></a>00740 <span class="preprocessor"></span>
<a name="l00741"></a>00741         [[<span class="keyword">self</span> cancelledLock] unlock];
<a name="l00742"></a>00742         [<span class="keyword">self</span> cancel];
<a name="l00743"></a>00743 }
<a name="l00744"></a>00744 
<a name="l00745"></a>00745 
<a name="l00746"></a>00746 - (BOOL)isCancelled
<a name="l00747"></a>00747 {
<a name="l00748"></a>00748     BOOL result;
<a name="l00749"></a>00749     
<a name="l00750"></a>00750         [[<span class="keyword">self</span> cancelledLock] lock];
<a name="l00751"></a>00751     result = cancelled;
<a name="l00752"></a>00752     [[<span class="keyword">self</span> cancelledLock] unlock];
<a name="l00753"></a>00753     
<a name="l00754"></a>00754     <span class="keywordflow">return</span> result;
<a name="l00755"></a>00755 }
<a name="l00756"></a>00756 
<a name="l00757"></a>00757 <span class="comment">// Call this method to get the received data as an NSString. Don&#39;t use for binary data!</span>
<a name="l00758"></a>00758 - (<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)responseString
<a name="l00759"></a>00759 {
<a name="l00760"></a>00760         <a class="code" href="class_n_s_data.html" title="For hashing raw data.">NSData</a> *data = [<span class="keyword">self</span> responseData];
<a name="l00761"></a>00761         <span class="keywordflow">if</span> (!data) {
<a name="l00762"></a>00762                 <span class="keywordflow">return</span> nil;
<a name="l00763"></a>00763         }
<a name="l00764"></a>00764         
<a name="l00765"></a>00765         <span class="keywordflow">return</span> [[[<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> alloc] initWithBytes:[data bytes] length:[data length] encoding:[<span class="keyword">self</span> responseEncoding]] autorelease];
<a name="l00766"></a>00766 }
<a name="l00767"></a>00767 
<a name="l00768"></a>00768 - (BOOL)isResponseCompressed
<a name="l00769"></a>00769 {
<a name="l00770"></a>00770         <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *encoding = [[<span class="keyword">self</span> responseHeaders] objectForKey:@&quot;Content-Encoding&quot;];
<a name="l00771"></a>00771         <span class="keywordflow">return</span> encoding &amp;&amp; [encoding rangeOfString:@&quot;gzip&quot;].location != NSNotFound;
<a name="l00772"></a>00772 }
<a name="l00773"></a>00773 
<a name="l00774"></a>00774 - (<a class="code" href="class_n_s_data.html" title="For hashing raw data.">NSData</a> *)responseData
<a name="l00775"></a>00775 {       
<a name="l00776"></a>00776         <span class="keywordflow">if</span> ([<span class="keyword">self</span> isResponseCompressed] &amp;&amp; [<span class="keyword">self</span> shouldWaitToInflateCompressedResponses]) {
<a name="l00777"></a>00777                 <span class="keywordflow">return</span> [ASIDataDecompressor uncompressData:[<span class="keyword">self</span> rawResponseData] error:NULL];
<a name="l00778"></a>00778         } <span class="keywordflow">else</span> {
<a name="l00779"></a>00779                 <span class="keywordflow">return</span> [<span class="keyword">self</span> rawResponseData];
<a name="l00780"></a>00780         }
<a name="l00781"></a>00781         <span class="keywordflow">return</span> nil;
<a name="l00782"></a>00782 }
<a name="l00783"></a>00783 
<a name="l00784"></a>00784 <span class="preprocessor">#pragma mark running a request</span>
<a name="l00785"></a>00785 <span class="preprocessor"></span>
<a name="l00786"></a>00786 - (void)startSynchronous
<a name="l00787"></a>00787 {
<a name="l00788"></a>00788 <span class="preprocessor">#if DEBUG_REQUEST_STATUS || DEBUG_THROTTLING</span>
<a name="l00789"></a>00789 <span class="preprocessor"></span>        NSLog(<span class="stringliteral">@&quot;[STATUS] Starting synchronous request %@&quot;</span>,<span class="keyword">self</span>);
<a name="l00790"></a>00790 <span class="preprocessor">#endif</span>
<a name="l00791"></a>00791 <span class="preprocessor"></span>        [<span class="keyword">self</span> setSynchronous:YES];
<a name="l00792"></a>00792         [<span class="keyword">self</span> setRunLoopMode:ASIHTTPRequestRunLoopMode];
<a name="l00793"></a>00793         [<span class="keyword">self</span> setInProgress:YES];
<a name="l00794"></a>00794 
<a name="l00795"></a>00795         <span class="keywordflow">if</span> (![<span class="keyword">self</span> isCancelled] &amp;&amp; ![<span class="keyword">self</span> complete]) {
<a name="l00796"></a>00796                 [<span class="keyword">self</span> main];
<a name="l00797"></a>00797                 <span class="keywordflow">while</span> (!complete) {
<a name="l00798"></a>00798                         [[NSRunLoop currentRunLoop] runMode:[<span class="keyword">self</span> runLoopMode] beforeDate:[NSDate distantFuture]];
<a name="l00799"></a>00799                 }
<a name="l00800"></a>00800         }
<a name="l00801"></a>00801 
<a name="l00802"></a>00802         [<span class="keyword">self</span> setInProgress:NO];
<a name="l00803"></a>00803 }
<a name="l00804"></a>00804 
<a name="l00805"></a>00805 - (void)start
<a name="l00806"></a>00806 {
<a name="l00807"></a>00807         [<span class="keyword">self</span> setInProgress:YES];
<a name="l00808"></a>00808         [<span class="keyword">self</span> performSelector:@selector(main) onThread:[[<span class="keyword">self</span> class] threadForRequest:self] withObject:nil waitUntilDone:NO];
<a name="l00809"></a>00809 }
<a name="l00810"></a>00810 
<a name="l00811"></a>00811 - (void)startAsynchronous
<a name="l00812"></a>00812 {
<a name="l00813"></a>00813 <span class="preprocessor">#if DEBUG_REQUEST_STATUS || DEBUG_THROTTLING</span>
<a name="l00814"></a>00814 <span class="preprocessor"></span>        NSLog(<span class="stringliteral">@&quot;[STATUS] Starting asynchronous request %@&quot;</span>,<span class="keyword">self</span>);
<a name="l00815"></a>00815 <span class="preprocessor">#endif</span>
<a name="l00816"></a>00816 <span class="preprocessor"></span>        [sharedQueue addOperation:self];
<a name="l00817"></a>00817 }
<a name="l00818"></a>00818 
<a name="l00819"></a>00819 <span class="preprocessor">#pragma mark concurrency</span>
<a name="l00820"></a>00820 <span class="preprocessor"></span>
<a name="l00821"></a>00821 - (BOOL)isConcurrent
<a name="l00822"></a>00822 {
<a name="l00823"></a>00823     <span class="keywordflow">return</span> YES;
<a name="l00824"></a>00824 }
<a name="l00825"></a>00825 
<a name="l00826"></a>00826 - (BOOL)isFinished 
<a name="l00827"></a>00827 {
<a name="l00828"></a>00828         <span class="keywordflow">return</span> finished;
<a name="l00829"></a>00829 }
<a name="l00830"></a>00830 
<a name="l00831"></a>00831 - (BOOL)isExecuting {
<a name="l00832"></a>00832         <span class="keywordflow">return</span> [<span class="keyword">self</span> inProgress];
<a name="l00833"></a>00833 }
<a name="l00834"></a>00834 
<a name="l00835"></a>00835 <span class="preprocessor">#pragma mark request logic</span>
<a name="l00836"></a>00836 <span class="preprocessor"></span>
<a name="l00837"></a>00837 <span class="comment">// Create the request</span>
<a name="l00838"></a>00838 - (void)main
<a name="l00839"></a>00839 {
<a name="l00840"></a>00840         <span class="keywordflow">@try</span> {
<a name="l00841"></a>00841                 
<a name="l00842"></a>00842                 [[<span class="keyword">self</span> cancelledLock] lock];
<a name="l00843"></a>00843                 
<a name="l00844"></a>00844 <span class="preprocessor">                #if TARGET_OS_IPHONE &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_4_0</span>
<a name="l00845"></a>00845 <span class="preprocessor"></span>                <span class="keywordflow">if</span> ([ASIHTTPRequest isMultitaskingSupported] &amp;&amp; [<span class="keyword">self</span> shouldContinueWhenAppEntersBackground]) {
<a name="l00846"></a>00846                         backgroundTask = <span class="comment">// Synchronize the cleanup call on the main thread in case</span><span class="comment">// the task actually finishes at around the same time.</span>[[UIApplication sharedApplication] beginBackgroundTaskWithExpirationHandler:^{
<a name="l00847"></a>00847                                 
<a name="l00848"></a>00848                                 
<a name="l00849"></a>00849                                 dispatch_async(dispatch_get_main_queue(), ^{
<a name="l00850"></a>00850                                         if (backgroundTask != UIBackgroundTaskInvalid)
<a name="l00851"></a>00851                                         {
<a name="l00852"></a>00852                                                 [[UIApplication sharedApplication] endBackgroundTask:backgroundTask];
<a name="l00853"></a>00853                                                 backgroundTask = UIBackgroundTaskInvalid;
<a name="l00854"></a>00854                                                 [<span class="keyword">self</span> cancel];
<a name="l00855"></a>00855                                         }
<a name="l00856"></a>00856                                 });
<a name="l00857"></a>00857                         }];
<a name="l00858"></a>00858                 }
<a name="l00859"></a>00859 <span class="preprocessor">                #endif</span>
<a name="l00860"></a>00860 <span class="preprocessor"></span>
<a name="l00861"></a>00861 
<a name="l00862"></a>00862                 <span class="comment">// A HEAD request generated by an ASINetworkQueue may have set the error already. If so, we should not proceed.</span>
<a name="l00863"></a>00863                 <span class="keywordflow">if</span> ([<span class="keyword">self</span> error]) {
<a name="l00864"></a>00864                         [<span class="keyword">self</span> setComplete:YES];
<a name="l00865"></a>00865                         [<span class="keyword">self</span> markAsFinished];
<a name="l00866"></a>00866                         <span class="keywordflow">return</span>;         
<a name="l00867"></a>00867                 }
<a name="l00868"></a>00868 
<a name="l00869"></a>00869                 [<span class="keyword">self</span> setComplete:NO];
<a name="l00870"></a>00870                 [<span class="keyword">self</span> setDidUseCachedResponse:NO];
<a name="l00871"></a>00871                 
<a name="l00872"></a>00872                 <span class="keywordflow">if</span> (![<span class="keyword">self</span> url]) {
<a name="l00873"></a>00873                         [<span class="keyword">self</span> failWithError:ASIUnableToCreateRequestError];
<a name="l00874"></a>00874                         <span class="keywordflow">return</span>;         
<a name="l00875"></a>00875                 }
<a name="l00876"></a>00876                 
<a name="l00877"></a>00877                 <span class="comment">// Must call before we create the request so that the request method can be set if needs be</span>
<a name="l00878"></a>00878                 <span class="keywordflow">if</span> (![<span class="keyword">self</span> mainRequest]) {
<a name="l00879"></a>00879                         [<span class="keyword">self</span> buildPostBody];
<a name="l00880"></a>00880                 }
<a name="l00881"></a>00881                 
<a name="l00882"></a>00882                 <span class="keywordflow">if</span> (![[<span class="keyword">self</span> requestMethod] isEqualToString:<span class="stringliteral">@&quot;GET&quot;</span>]) {
<a name="l00883"></a>00883                         [<span class="keyword">self</span> setDownloadCache:nil];
<a name="l00884"></a>00884                 }
<a name="l00885"></a>00885                 
<a name="l00886"></a>00886                 
<a name="l00887"></a>00887                 <span class="comment">// If we&#39;re redirecting, we&#39;ll already have a CFHTTPMessageRef</span>
<a name="l00888"></a>00888                 <span class="keywordflow">if</span> (request) {
<a name="l00889"></a>00889                         CFRelease(request);
<a name="l00890"></a>00890                 }
<a name="l00891"></a>00891 
<a name="l00892"></a>00892                 <span class="comment">// Create a new HTTP request.</span>
<a name="l00893"></a>00893                 request = CFHTTPMessageCreateRequest(kCFAllocatorDefault, (CFStringRef)[<span class="keyword">self</span> requestMethod], (CFURLRef)[<span class="keyword">self</span> url], [<span class="keyword">self</span> useHTTPVersionOne] ? kCFHTTPVersion1_0 : kCFHTTPVersion1_1);
<a name="l00894"></a>00894                 <span class="keywordflow">if</span> (!request) {
<a name="l00895"></a>00895                         [<span class="keyword">self</span> failWithError:ASIUnableToCreateRequestError];
<a name="l00896"></a>00896                         <span class="keywordflow">return</span>;
<a name="l00897"></a>00897                 }
<a name="l00898"></a>00898 
<a name="l00899"></a>00899                 <span class="comment">//If this is a HEAD request generated by an ASINetworkQueue, we need to let the main request generate its headers first so we can use them</span>
<a name="l00900"></a>00900                 <span class="keywordflow">if</span> ([<span class="keyword">self</span> mainRequest]) {
<a name="l00901"></a>00901                         [[<span class="keyword">self</span> mainRequest] buildRequestHeaders];
<a name="l00902"></a>00902                 }
<a name="l00903"></a>00903                 
<a name="l00904"></a>00904                 <span class="comment">// Even if this is a HEAD request with a mainRequest, we still need to call to give subclasses a chance to add their own to HEAD requests (ASIS3Request does this)</span>
<a name="l00905"></a>00905                 [<span class="keyword">self</span> buildRequestHeaders];
<a name="l00906"></a>00906                 
<a name="l00907"></a>00907                 <span class="keywordflow">if</span> ([<span class="keyword">self</span> downloadCache]) {
<a name="l00908"></a>00908 
<a name="l00909"></a>00909                         <span class="comment">// If this request should use the default policy, set its policy to the download cache&#39;s default policy</span>
<a name="l00910"></a>00910                         <span class="keywordflow">if</span> (![<span class="keyword">self</span> cachePolicy]) {
<a name="l00911"></a>00911                                 [<span class="keyword">self</span> setCachePolicy:[[<span class="keyword">self</span> downloadCache] defaultCachePolicy]];
<a name="l00912"></a>00912                         }
<a name="l00913"></a>00913 
<a name="l00914"></a>00914                         <span class="comment">// If have have cached data that is valid for this request, use that and stop</span>
<a name="l00915"></a>00915                         <span class="keywordflow">if</span> ([[<span class="keyword">self</span> downloadCache] canUseCachedDataForRequest:<span class="keyword">self</span>]) {
<a name="l00916"></a>00916                                 [<span class="keyword">self</span> useDataFromCache];
<a name="l00917"></a>00917                                 <span class="keywordflow">return</span>;
<a name="l00918"></a>00918                         }
<a name="l00919"></a>00919 
<a name="l00920"></a>00920                         <span class="comment">// If cached data is stale, or we have been told to ask the server if it has been modified anyway, we need to add headers for a conditional GET</span>
<a name="l00921"></a>00921                         <span class="keywordflow">if</span> ([<span class="keyword">self</span> cachePolicy] &amp; (ASIAskServerIfModifiedWhenStaleCachePolicy|ASIAskServerIfModifiedCachePolicy)) {
<a name="l00922"></a>00922 
<a name="l00923"></a>00923                                 NSDictionary *cachedHeaders = [[<span class="keyword">self</span> downloadCache] cachedResponseHeadersForURL:[<span class="keyword">self</span> url]];
<a name="l00924"></a>00924                                 <span class="keywordflow">if</span> (cachedHeaders) {
<a name="l00925"></a>00925                                         <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *etag = [cachedHeaders objectForKey:@&quot;Etag&quot;];
<a name="l00926"></a>00926                                         <span class="keywordflow">if</span> (etag) {
<a name="l00927"></a>00927                                                 [[<span class="keyword">self</span> requestHeaders] setObject:etag forKey:@&quot;If-None-Match&quot;];
<a name="l00928"></a>00928                                         }
<a name="l00929"></a>00929                                         <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *lastModified = [cachedHeaders objectForKey:@&quot;Last-Modified&quot;];
<a name="l00930"></a>00930                                         <span class="keywordflow">if</span> (lastModified) {
<a name="l00931"></a>00931                                                 [[<span class="keyword">self</span> requestHeaders] setObject:lastModified forKey:@&quot;If-Modified-Since&quot;];
<a name="l00932"></a>00932                                         }
<a name="l00933"></a>00933                                 }
<a name="l00934"></a>00934                         }
<a name="l00935"></a>00935                 }
<a name="l00936"></a>00936 
<a name="l00937"></a>00937                 [<span class="keyword">self</span> applyAuthorizationHeader];
<a name="l00938"></a>00938                 
<a name="l00939"></a>00939                 
<a name="l00940"></a>00940                 <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *header;
<a name="l00941"></a>00941                 <span class="keywordflow">for</span> (header in [<span class="keyword">self</span> requestHeaders]) {
<a name="l00942"></a>00942                         CFHTTPMessageSetHeaderFieldValue(request, (CFStringRef)header, (CFStringRef)[[<span class="keyword">self</span> requestHeaders] objectForKey:header]);
<a name="l00943"></a>00943                 }
<a name="l00944"></a>00944 
<a name="l00945"></a>00945                 <span class="comment">// If we immediately have access to proxy settings, start the request</span>
<a name="l00946"></a>00946                 <span class="comment">// Otherwise, we&#39;ll start downloading the proxy PAC file, and call startRequest once that process is complete</span>
<a name="l00947"></a>00947                 <span class="keywordflow">if</span> ([<span class="keyword">self</span> configureProxies]) {
<a name="l00948"></a>00948                         [<span class="keyword">self</span> startRequest];
<a name="l00949"></a>00949                 }
<a name="l00950"></a>00950 
<a name="l00951"></a>00951         } <span class="keywordflow">@catch</span> (NSException *exception) {
<a name="l00952"></a>00952                 NSError *underlyingError = [NSError errorWithDomain:NetworkRequestErrorDomain code:ASIUnhandledExceptionError userInfo:[exception userInfo]];
<a name="l00953"></a>00953                 [<span class="keyword">self</span> failWithError:[NSError errorWithDomain:NetworkRequestErrorDomain code:ASIUnhandledExceptionError userInfo:[NSDictionary dictionaryWithObjectsAndKeys:[exception name],NSLocalizedDescriptionKey,[exception reason],NSLocalizedFailureReasonErrorKey,underlyingError,NSUnderlyingErrorKey,nil]]];
<a name="l00954"></a>00954 
<a name="l00955"></a>00955         } <span class="keywordflow">@finally</span> {
<a name="l00956"></a>00956                 [[<span class="keyword">self</span> cancelledLock] unlock];
<a name="l00957"></a>00957         }
<a name="l00958"></a>00958 }
<a name="l00959"></a>00959 
<a name="l00960"></a>00960 - (void)applyAuthorizationHeader
<a name="l00961"></a>00961 {
<a name="l00962"></a>00962         <span class="comment">// Do we want to send credentials before we are asked for them?</span>
<a name="l00963"></a>00963         <span class="keywordflow">if</span> (![<span class="keyword">self</span> shouldPresentCredentialsBeforeChallenge]) {
<a name="l00964"></a>00964 <span class="preprocessor">                #if DEBUG_HTTP_AUTHENTICATION</span>
<a name="l00965"></a>00965 <span class="preprocessor"></span>                NSLog(<span class="stringliteral">@&quot;[AUTH] Request %@ will not send credentials to the server until it asks for them&quot;</span>,<span class="keyword">self</span>);
<a name="l00966"></a>00966 <span class="preprocessor">                #endif</span>
<a name="l00967"></a>00967 <span class="preprocessor"></span>                <span class="keywordflow">return</span>;
<a name="l00968"></a>00968         }
<a name="l00969"></a>00969 
<a name="l00970"></a>00970         NSDictionary *credentials = nil;
<a name="l00971"></a>00971 
<a name="l00972"></a>00972         <span class="comment">// Do we already have an auth header?</span>
<a name="l00973"></a>00973         <span class="keywordflow">if</span> (![[<span class="keyword">self</span> requestHeaders] objectForKey:<span class="stringliteral">@&quot;Authorization&quot;</span>]) {
<a name="l00974"></a>00974 
<a name="l00975"></a>00975                 <span class="comment">// If we have basic authentication explicitly set and a username and password set on the request, add a basic auth header</span>
<a name="l00976"></a>00976                 <span class="keywordflow">if</span> ([<span class="keyword">self</span> username] &amp;&amp; [<span class="keyword">self</span> password] &amp;&amp; [[<span class="keyword">self</span> authenticationScheme] isEqualToString:(<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)kCFHTTPAuthenticationSchemeBasic]) {
<a name="l00977"></a>00977                         [<span class="keyword">self</span> addBasicAuthenticationHeaderWithUsername:[<span class="keyword">self</span> username] andPassword:[<span class="keyword">self</span> password]];
<a name="l00978"></a>00978 
<a name="l00979"></a>00979 <span class="preprocessor">                        #if DEBUG_HTTP_AUTHENTICATION</span>
<a name="l00980"></a>00980 <span class="preprocessor"></span>                        NSLog(<span class="stringliteral">@&quot;[AUTH] Request %@ has a username and password set, and was manually configured to use BASIC. Will send credentials without waiting for an authentication challenge&quot;</span>,<span class="keyword">self</span>);      
<a name="l00981"></a>00981 <span class="preprocessor">                        #endif</span>
<a name="l00982"></a>00982 <span class="preprocessor"></span>
<a name="l00983"></a>00983                 } <span class="keywordflow">else</span> {
<a name="l00984"></a>00984 
<a name="l00985"></a>00985                         <span class="comment">// See if we have any cached credentials we can use in the session store</span>
<a name="l00986"></a>00986                         <span class="keywordflow">if</span> ([<span class="keyword">self</span> useSessionPersistence]) {
<a name="l00987"></a>00987                                 credentials = [<span class="keyword">self</span> findSessionAuthenticationCredentials];
<a name="l00988"></a>00988 
<a name="l00989"></a>00989                                 <span class="keywordflow">if</span> (credentials) {
<a name="l00990"></a>00990 
<a name="l00991"></a>00991                                         <span class="comment">// When the Authentication key is set, the credentials were stored after an authentication challenge, so we can let CFNetwork apply them</span>
<a name="l00992"></a>00992                                         <span class="comment">// (credentials for Digest and NTLM will always be stored like this)</span>
<a name="l00993"></a>00993                                         <span class="keywordflow">if</span> ([credentials objectForKey:<span class="stringliteral">@&quot;Authentication&quot;</span>]) {
<a name="l00994"></a>00994 
<a name="l00995"></a>00995                                                 <span class="comment">// If we&#39;ve already talked to this server and have valid credentials, let&#39;s apply them to the request</span>
<a name="l00996"></a>00996                                                 <span class="keywordflow">if</span> (CFHTTPMessageApplyCredentialDictionary(request, (CFHTTPAuthenticationRef)[credentials objectForKey:<span class="stringliteral">@&quot;Authentication&quot;</span>], (CFDictionaryRef)[credentials objectForKey:<span class="stringliteral">@&quot;Credentials&quot;</span>], NULL)) {
<a name="l00997"></a>00997                                                         [<span class="keyword">self</span> setAuthenticationScheme:[credentials objectForKey:@&quot;AuthenticationScheme&quot;]];
<a name="l00998"></a>00998 <span class="preprocessor">                                                        #if DEBUG_HTTP_AUTHENTICATION</span>
<a name="l00999"></a>00999 <span class="preprocessor"></span>                                                        NSLog(<span class="stringliteral">@&quot;[AUTH] Request %@ found cached credentials (%@), will reuse without waiting for an authentication challenge&quot;</span>,<span class="keyword">self</span>,[credentials objectForKey:<span class="stringliteral">@&quot;AuthenticationScheme&quot;</span>]);
<a name="l01000"></a>01000 <span class="preprocessor">                                                        #endif</span>
<a name="l01001"></a>01001 <span class="preprocessor"></span>                                                } <span class="keywordflow">else</span> {
<a name="l01002"></a>01002                                                         [[<span class="keyword">self</span> class] removeAuthenticationCredentialsFromSessionStore:[credentials objectForKey:@&quot;Credentials&quot;]];
<a name="l01003"></a>01003 <span class="preprocessor">                                                        #if DEBUG_HTTP_AUTHENTICATION</span>
<a name="l01004"></a>01004 <span class="preprocessor"></span>                                                        NSLog(<span class="stringliteral">@&quot;[AUTH] Failed to apply cached credentials to request %@. These will be removed from the session store, and this request will wait for an authentication challenge&quot;</span>,<span class="keyword">self</span>);
<a name="l01005"></a>01005 <span class="preprocessor">                                                        #endif</span>
<a name="l01006"></a>01006 <span class="preprocessor"></span>                                                }
<a name="l01007"></a>01007 
<a name="l01008"></a>01008                                         <span class="comment">// If the Authentication key is not set, these credentials were stored after a username and password set on a previous request passed basic authentication</span>
<a name="l01009"></a>01009                                         <span class="comment">// When this happens, we&#39;ll need to create the Authorization header ourselves</span>
<a name="l01010"></a>01010                                         } <span class="keywordflow">else</span> {
<a name="l01011"></a>01011                                                 NSDictionary *usernameAndPassword = [credentials objectForKey:@&quot;Credentials&quot;];
<a name="l01012"></a>01012                                                 [<span class="keyword">self</span> addBasicAuthenticationHeaderWithUsername:[usernameAndPassword objectForKey:(NSString *)kCFHTTPAuthenticationUsername] andPassword:[usernameAndPassword objectForKey:(NSString *)kCFHTTPAuthenticationPassword]];
<a name="l01013"></a>01013 <span class="preprocessor">                                                #if DEBUG_HTTP_AUTHENTICATION</span>
<a name="l01014"></a>01014 <span class="preprocessor"></span>                                                NSLog(<span class="stringliteral">@&quot;[AUTH] Request %@ found cached BASIC credentials from a previous request. Will send credentials without waiting for an authentication challenge&quot;</span>,<span class="keyword">self</span>);
<a name="l01015"></a>01015 <span class="preprocessor">                                                #endif</span>
<a name="l01016"></a>01016 <span class="preprocessor"></span>                                        }
<a name="l01017"></a>01017                                 }
<a name="l01018"></a>01018                         }
<a name="l01019"></a>01019                 }
<a name="l01020"></a>01020         }
<a name="l01021"></a>01021 
<a name="l01022"></a>01022         <span class="comment">// Apply proxy authentication credentials</span>
<a name="l01023"></a>01023         <span class="keywordflow">if</span> ([<span class="keyword">self</span> useSessionPersistence]) {
<a name="l01024"></a>01024                 credentials = [<span class="keyword">self</span> findSessionProxyAuthenticationCredentials];
<a name="l01025"></a>01025                 <span class="keywordflow">if</span> (credentials) {
<a name="l01026"></a>01026                         <span class="keywordflow">if</span> (!CFHTTPMessageApplyCredentialDictionary(request, (CFHTTPAuthenticationRef)[credentials objectForKey:<span class="stringliteral">@&quot;Authentication&quot;</span>], (CFDictionaryRef)[credentials objectForKey:<span class="stringliteral">@&quot;Credentials&quot;</span>], NULL)) {
<a name="l01027"></a>01027                                 [[<span class="keyword">self</span> class] removeProxyAuthenticationCredentialsFromSessionStore:[credentials objectForKey:@&quot;Credentials&quot;]];
<a name="l01028"></a>01028                         }
<a name="l01029"></a>01029                 }
<a name="l01030"></a>01030         }
<a name="l01031"></a>01031 }
<a name="l01032"></a>01032 
<a name="l01033"></a>01033 - (void)applyCookieHeader
<a name="l01034"></a>01034 {
<a name="l01035"></a>01035         <span class="comment">// Add cookies from the persistent (mac os global) store</span>
<a name="l01036"></a>01036         <span class="keywordflow">if</span> ([<span class="keyword">self</span> useCookiePersistence]) {
<a name="l01037"></a>01037                 NSArray *cookies = [[NSHTTPCookieStorage sharedHTTPCookieStorage] cookiesForURL:[[<span class="keyword">self</span> url] absoluteURL]];
<a name="l01038"></a>01038                 <span class="keywordflow">if</span> (cookies) {
<a name="l01039"></a>01039                         [[<span class="keyword">self</span> requestCookies] addObjectsFromArray:cookies];
<a name="l01040"></a>01040                 }
<a name="l01041"></a>01041         }
<a name="l01042"></a>01042         
<a name="l01043"></a>01043         <span class="comment">// Apply request cookies</span>
<a name="l01044"></a>01044         NSArray *cookies;
<a name="l01045"></a>01045         <span class="keywordflow">if</span> ([<span class="keyword">self</span> mainRequest]) {
<a name="l01046"></a>01046                 cookies = [[<span class="keyword">self</span> mainRequest] requestCookies];
<a name="l01047"></a>01047         } <span class="keywordflow">else</span> {
<a name="l01048"></a>01048                 cookies = [<span class="keyword">self</span> requestCookies];
<a name="l01049"></a>01049         }
<a name="l01050"></a>01050         <span class="keywordflow">if</span> ([cookies count] &gt; 0) {
<a name="l01051"></a>01051                 NSHTTPCookie *cookie;
<a name="l01052"></a>01052                 <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *cookieHeader = nil;
<a name="l01053"></a>01053                 <span class="keywordflow">for</span> (cookie in cookies) {
<a name="l01054"></a>01054                         <span class="keywordflow">if</span> (!cookieHeader) {
<a name="l01055"></a>01055                                 cookieHeader = [<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> stringWithFormat: @&quot;%@=%@&quot;,[cookie name],[cookie value]];
<a name="l01056"></a>01056                         } <span class="keywordflow">else</span> {
<a name="l01057"></a>01057                                 cookieHeader = [<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> stringWithFormat: @&quot;%@; %@=%@&quot;,cookieHeader,[cookie name],[cookie value]];
<a name="l01058"></a>01058                         }
<a name="l01059"></a>01059                 }
<a name="l01060"></a>01060                 <span class="keywordflow">if</span> (cookieHeader) {
<a name="l01061"></a>01061                         [<span class="keyword">self</span> addRequestHeader:@&quot;Cookie&quot; value:cookieHeader];
<a name="l01062"></a>01062                 }
<a name="l01063"></a>01063         }       
<a name="l01064"></a>01064 }
<a name="l01065"></a>01065 
<a name="l01066"></a>01066 - (void)buildRequestHeaders
<a name="l01067"></a>01067 {
<a name="l01068"></a>01068         <span class="keywordflow">if</span> ([<span class="keyword">self</span> haveBuiltRequestHeaders]) {
<a name="l01069"></a>01069                 <span class="keywordflow">return</span>;
<a name="l01070"></a>01070         }
<a name="l01071"></a>01071         [<span class="keyword">self</span> setHaveBuiltRequestHeaders:YES];
<a name="l01072"></a>01072         
<a name="l01073"></a>01073         <span class="keywordflow">if</span> ([<span class="keyword">self</span> mainRequest]) {
<a name="l01074"></a>01074                 <span class="keywordflow">for</span> (<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *header in [[<span class="keyword">self</span> mainRequest] requestHeaders]) {
<a name="l01075"></a>01075                         [<span class="keyword">self</span> addRequestHeader:header value:[[[<span class="keyword">self</span> mainRequest] requestHeaders] valueForKey:header]];
<a name="l01076"></a>01076                 }
<a name="l01077"></a>01077                 <span class="keywordflow">return</span>;
<a name="l01078"></a>01078         }
<a name="l01079"></a>01079         
<a name="l01080"></a>01080         [<span class="keyword">self</span> applyCookieHeader];
<a name="l01081"></a>01081         
<a name="l01082"></a>01082         <span class="comment">// Build and set the user agent string if the request does not already have a custom user agent specified</span>
<a name="l01083"></a>01083         <span class="keywordflow">if</span> (![[<span class="keyword">self</span> requestHeaders] objectForKey:<span class="stringliteral">@&quot;User-Agent&quot;</span>]) {
<a name="l01084"></a>01084                 <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *userAgentString = [<span class="keyword">self</span> userAgent];
<a name="l01085"></a>01085                 <span class="keywordflow">if</span> (!userAgentString) {
<a name="l01086"></a>01086                         userAgentString = [ASIHTTPRequest defaultUserAgentString];
<a name="l01087"></a>01087                 }
<a name="l01088"></a>01088                 <span class="keywordflow">if</span> (userAgentString) {
<a name="l01089"></a>01089                         [<span class="keyword">self</span> addRequestHeader:@&quot;User-Agent&quot; value:userAgentString];
<a name="l01090"></a>01090                 }
<a name="l01091"></a>01091         }
<a name="l01092"></a>01092         
<a name="l01093"></a>01093         
<a name="l01094"></a>01094         <span class="comment">// Accept a compressed response</span>
<a name="l01095"></a>01095         <span class="keywordflow">if</span> ([<span class="keyword">self</span> allowCompressedResponse]) {
<a name="l01096"></a>01096                 [<span class="keyword">self</span> addRequestHeader:@&quot;Accept-Encoding&quot; value:@&quot;gzip&quot;];
<a name="l01097"></a>01097         }
<a name="l01098"></a>01098         
<a name="l01099"></a>01099         <span class="comment">// Configure a compressed request body</span>
<a name="l01100"></a>01100         <span class="keywordflow">if</span> ([<span class="keyword">self</span> shouldCompressRequestBody]) {
<a name="l01101"></a>01101                 [<span class="keyword">self</span> addRequestHeader:@&quot;Content-Encoding&quot; value:@&quot;gzip&quot;];
<a name="l01102"></a>01102         }
<a name="l01103"></a>01103         
<a name="l01104"></a>01104         <span class="comment">// Should this request resume an existing download?</span>
<a name="l01105"></a>01105         [<span class="keyword">self</span> updatePartialDownloadSize];
<a name="l01106"></a>01106         <span class="keywordflow">if</span> ([<span class="keyword">self</span> partialDownloadSize]) {
<a name="l01107"></a>01107                 [<span class="keyword">self</span> addRequestHeader:@&quot;Range&quot; value:[<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> stringWithFormat:@&quot;bytes=%llu-&quot;,[<span class="keyword">self</span> partialDownloadSize]]];
<a name="l01108"></a>01108         }
<a name="l01109"></a>01109 }
<a name="l01110"></a>01110 
<a name="l01111"></a>01111 - (void)updatePartialDownloadSize
<a name="l01112"></a>01112 {
<a name="l01113"></a>01113         NSFileManager *fileManager = [[[NSFileManager alloc] init] autorelease];
<a name="l01114"></a>01114 
<a name="l01115"></a>01115         <span class="keywordflow">if</span> ([<span class="keyword">self</span> allowResumeForFileDownloads] &amp;&amp; [<span class="keyword">self</span> downloadDestinationPath] &amp;&amp; [<span class="keyword">self</span> temporaryFileDownloadPath] &amp;&amp; [fileManager fileExistsAtPath:[<span class="keyword">self</span> temporaryFileDownloadPath]]) {
<a name="l01116"></a>01116                 NSError *err = nil;
<a name="l01117"></a>01117                 [<span class="keyword">self</span> setPartialDownloadSize:[[fileManager attributesOfItemAtPath:[<span class="keyword">self</span> temporaryFileDownloadPath] error:&amp;err] fileSize]];
<a name="l01118"></a>01118                 <span class="keywordflow">if</span> (err) {
<a name="l01119"></a>01119                         [<span class="keyword">self</span> failWithError:[NSError errorWithDomain:NetworkRequestErrorDomain code:ASIFileManagementError userInfo:[NSDictionary dictionaryWithObjectsAndKeys:[<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> stringWithFormat:@&quot;Failed to get attributes for file at path &#39;%@&#39;&quot;,[<span class="keyword">self</span> temporaryFileDownloadPath]],NSLocalizedDescriptionKey,error,NSUnderlyingErrorKey,nil]]];
<a name="l01120"></a>01120                         <span class="keywordflow">return</span>;
<a name="l01121"></a>01121                 }
<a name="l01122"></a>01122         }
<a name="l01123"></a>01123 }
<a name="l01124"></a>01124 
<a name="l01125"></a>01125 - (void)startRequest
<a name="l01126"></a>01126 {
<a name="l01127"></a>01127         <span class="keywordflow">if</span> ([<span class="keyword">self</span> isCancelled]) {
<a name="l01128"></a>01128                 <span class="keywordflow">return</span>;
<a name="l01129"></a>01129         }
<a name="l01130"></a>01130         
<a name="l01131"></a>01131         [<span class="keyword">self</span> performSelectorOnMainThread:@selector(requestStarted) withObject:nil waitUntilDone:[NSThread isMainThread]];
<a name="l01132"></a>01132         
<a name="l01133"></a>01133         [<span class="keyword">self</span> setDownloadComplete:NO];
<a name="l01134"></a>01134         [<span class="keyword">self</span> setComplete:NO];
<a name="l01135"></a>01135         [<span class="keyword">self</span> setTotalBytesRead:0];
<a name="l01136"></a>01136         [<span class="keyword">self</span> setLastBytesRead:0];
<a name="l01137"></a>01137         
<a name="l01138"></a>01138         <span class="keywordflow">if</span> ([<span class="keyword">self</span> redirectCount] == 0) {
<a name="l01139"></a>01139                 [<span class="keyword">self</span> setOriginalURL:[<span class="keyword">self</span> url]];
<a name="l01140"></a>01140         }
<a name="l01141"></a>01141         
<a name="l01142"></a>01142         <span class="comment">// If we&#39;re retrying a request, let&#39;s remove any progress we made</span>
<a name="l01143"></a>01143         <span class="keywordflow">if</span> ([<span class="keyword">self</span> lastBytesSent] &gt; 0) {
<a name="l01144"></a>01144                 [<span class="keyword">self</span> removeUploadProgressSoFar];
<a name="l01145"></a>01145         }
<a name="l01146"></a>01146         
<a name="l01147"></a>01147         [<span class="keyword">self</span> setLastBytesSent:0];
<a name="l01148"></a>01148         [<span class="keyword">self</span> setContentLength:0];
<a name="l01149"></a>01149         [<span class="keyword">self</span> setResponseHeaders:nil];
<a name="l01150"></a>01150         <span class="keywordflow">if</span> (![<span class="keyword">self</span> downloadDestinationPath]) {
<a name="l01151"></a>01151                 [<span class="keyword">self</span> setRawResponseData:[[[NSMutableData alloc] init] autorelease]];
<a name="l01152"></a>01152     }
<a name="l01153"></a>01153         
<a name="l01154"></a>01154         
<a name="l01155"></a>01155     <span class="comment">//</span>
<a name="l01156"></a>01156         <span class="comment">// Create the stream for the request</span>
<a name="l01157"></a>01157         <span class="comment">//</span>
<a name="l01158"></a>01158 
<a name="l01159"></a>01159         NSFileManager *fileManager = [[[NSFileManager alloc] init] autorelease];
<a name="l01160"></a>01160 
<a name="l01161"></a>01161         [<span class="keyword">self</span> setReadStreamIsScheduled:NO];
<a name="l01162"></a>01162         
<a name="l01163"></a>01163         <span class="comment">// Do we need to stream the request body from disk</span>
<a name="l01164"></a>01164         <span class="keywordflow">if</span> ([<span class="keyword">self</span> shouldStreamPostDataFromDisk] &amp;&amp; [<span class="keyword">self</span> postBodyFilePath] &amp;&amp; [fileManager fileExistsAtPath:[<span class="keyword">self</span> postBodyFilePath]]) {
<a name="l01165"></a>01165                 
<a name="l01166"></a>01166                 <span class="comment">// Are we gzipping the request body?</span>
<a name="l01167"></a>01167                 <span class="keywordflow">if</span> ([<span class="keyword">self</span> compressedPostBodyFilePath] &amp;&amp; [fileManager fileExistsAtPath:[<span class="keyword">self</span> compressedPostBodyFilePath]]) {
<a name="l01168"></a>01168                         [<span class="keyword">self</span> setPostBodyReadStream:[ASIInputStream inputStreamWithFileAtPath:[<span class="keyword">self</span> compressedPostBodyFilePath] request:self]];
<a name="l01169"></a>01169                 } <span class="keywordflow">else</span> {
<a name="l01170"></a>01170                         [<span class="keyword">self</span> setPostBodyReadStream:[ASIInputStream inputStreamWithFileAtPath:[<span class="keyword">self</span> postBodyFilePath] request:self]];
<a name="l01171"></a>01171                 }
<a name="l01172"></a>01172                 [<span class="keyword">self</span> setReadStream:[(NSInputStream *)CFReadStreamCreateForStreamedHTTPRequest(kCFAllocatorDefault, request,(CFReadStreamRef)[<span class="keyword">self</span> postBodyReadStream]) autorelease]];
<a name="l01173"></a>01173     } <span class="keywordflow">else</span> {
<a name="l01174"></a>01174                 
<a name="l01175"></a>01175                 <span class="comment">// If we have a request body, we&#39;ll stream it from memory using our custom stream, so that we can measure bandwidth use and it can be bandwidth-throttled if necessary</span>
<a name="l01176"></a>01176                 <span class="keywordflow">if</span> ([<span class="keyword">self</span> postBody] &amp;&amp; [[<span class="keyword">self</span> postBody] length] &gt; 0) {
<a name="l01177"></a>01177                         <span class="keywordflow">if</span> ([<span class="keyword">self</span> shouldCompressRequestBody] &amp;&amp; [<span class="keyword">self</span> compressedPostBody]) {
<a name="l01178"></a>01178                                 [<span class="keyword">self</span> setPostBodyReadStream:[ASIInputStream inputStreamWithData:[<span class="keyword">self</span> compressedPostBody] request:self]];
<a name="l01179"></a>01179                         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ([<span class="keyword">self</span> postBody]) {
<a name="l01180"></a>01180                                 [<span class="keyword">self</span> setPostBodyReadStream:[ASIInputStream inputStreamWithData:[<span class="keyword">self</span> postBody] request:self]];
<a name="l01181"></a>01181                         }
<a name="l01182"></a>01182                         [<span class="keyword">self</span> setReadStream:[(NSInputStream *)CFReadStreamCreateForStreamedHTTPRequest(kCFAllocatorDefault, request,(CFReadStreamRef)[<span class="keyword">self</span> postBodyReadStream]) autorelease]];
<a name="l01183"></a>01183                 
<a name="l01184"></a>01184                 } <span class="keywordflow">else</span> {
<a name="l01185"></a>01185                         [<span class="keyword">self</span> setReadStream:[(NSInputStream *)CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, request) autorelease]];
<a name="l01186"></a>01186                 }
<a name="l01187"></a>01187         }
<a name="l01188"></a>01188 
<a name="l01189"></a>01189         <span class="keywordflow">if</span> (![<span class="keyword">self</span> readStream]) {
<a name="l01190"></a>01190                 [<span class="keyword">self</span> failWithError:[NSError errorWithDomain:NetworkRequestErrorDomain code:ASIInternalErrorWhileBuildingRequestType userInfo:[NSDictionary dictionaryWithObjectsAndKeys:@&quot;Unable to create read stream&quot;,NSLocalizedDescriptionKey,nil]]];
<a name="l01191"></a>01191         <span class="keywordflow">return</span>;
<a name="l01192"></a>01192     }
<a name="l01193"></a>01193 
<a name="l01194"></a>01194 
<a name="l01195"></a>01195     
<a name="l01196"></a>01196     
<a name="l01197"></a>01197     <span class="comment">//</span>
<a name="l01198"></a>01198     <span class="comment">// Handle SSL certificate settings</span>
<a name="l01199"></a>01199     <span class="comment">//</span>
<a name="l01200"></a>01200 
<a name="l01201"></a>01201     <span class="keywordflow">if</span>([[[[<span class="keyword">self</span> url] scheme] lowercaseString] isEqualToString:<span class="stringliteral">@&quot;https&quot;</span>]) {
<a name="l01202"></a>01202 
<a name="l01203"></a>01203         NSMutableDictionary *sslProperties = [NSMutableDictionary dictionaryWithCapacity:1];
<a name="l01204"></a>01204 
<a name="l01205"></a>01205         <span class="comment">// Tell CFNetwork not to validate SSL certificates</span>
<a name="l01206"></a>01206         <span class="keywordflow">if</span> (![<span class="keyword">self</span> validatesSecureCertificate]) {
<a name="l01207"></a>01207             [sslProperties setObject:(NSString *)kCFBooleanFalse forKey:(NSString *)kCFStreamSSLValidatesCertificateChain];
<a name="l01208"></a>01208         }
<a name="l01209"></a>01209 
<a name="l01210"></a>01210         <span class="comment">// Tell CFNetwork to use a client certificate</span>
<a name="l01211"></a>01211         <span class="keywordflow">if</span> (clientCertificateIdentity) {
<a name="l01212"></a>01212 
<a name="l01213"></a>01213                         NSMutableArray *certificates = [NSMutableArray arrayWithCapacity:[clientCertificates count]+1];
<a name="l01214"></a>01214 
<a name="l01215"></a>01215                         <span class="comment">// The first object in the array is our SecIdentityRef</span>
<a name="l01216"></a>01216                         [certificates addObject:(id)clientCertificateIdentity];
<a name="l01217"></a>01217 
<a name="l01218"></a>01218                         <span class="comment">// If we&#39;ve added any additional certificates, add them too</span>
<a name="l01219"></a>01219                         <span class="keywordflow">for</span> (<span class="keywordtype">id</span> cert in clientCertificates) {
<a name="l01220"></a>01220                                 [certificates addObject:cert];
<a name="l01221"></a>01221                         }
<a name="l01222"></a>01222             [sslProperties setObject:certificates forKey:(NSString *)kCFStreamSSLCertificates];
<a name="l01223"></a>01223         }
<a name="l01224"></a>01224 
<a name="l01225"></a>01225         CFReadStreamSetProperty((CFReadStreamRef)[<span class="keyword">self</span> readStream], kCFStreamPropertySSLSettings, sslProperties);
<a name="l01226"></a>01226     }
<a name="l01227"></a>01227 
<a name="l01228"></a>01228         <span class="comment">//</span>
<a name="l01229"></a>01229         <span class="comment">// Handle proxy settings</span>
<a name="l01230"></a>01230         <span class="comment">//</span>
<a name="l01231"></a>01231 
<a name="l01232"></a>01232         <span class="keywordflow">if</span> ([<span class="keyword">self</span> proxyHost] &amp;&amp; [<span class="keyword">self</span> proxyPort]) {
<a name="l01233"></a>01233                 <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *hostKey;
<a name="l01234"></a>01234                 <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *portKey;
<a name="l01235"></a>01235 
<a name="l01236"></a>01236                 <span class="keywordflow">if</span> (![<span class="keyword">self</span> proxyType]) {
<a name="l01237"></a>01237                         [<span class="keyword">self</span> setProxyType:(NSString *)kCFProxyTypeHTTP];
<a name="l01238"></a>01238                 }
<a name="l01239"></a>01239 
<a name="l01240"></a>01240                 <span class="keywordflow">if</span> ([[<span class="keyword">self</span> proxyType] isEqualToString:(<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)kCFProxyTypeSOCKS]) {
<a name="l01241"></a>01241                         hostKey = (<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)kCFStreamPropertySOCKSProxyHost;
<a name="l01242"></a>01242                         portKey = (<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)kCFStreamPropertySOCKSProxyPort;
<a name="l01243"></a>01243                 } <span class="keywordflow">else</span> {
<a name="l01244"></a>01244                         hostKey = (<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)kCFStreamPropertyHTTPProxyHost;
<a name="l01245"></a>01245                         portKey = (<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)kCFStreamPropertyHTTPProxyPort;
<a name="l01246"></a>01246                         <span class="keywordflow">if</span> ([[[[<span class="keyword">self</span> url] scheme] lowercaseString] isEqualToString:<span class="stringliteral">@&quot;https&quot;</span>]) {
<a name="l01247"></a>01247                                 hostKey = (<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)kCFStreamPropertyHTTPSProxyHost;
<a name="l01248"></a>01248                                 portKey = (<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)kCFStreamPropertyHTTPSProxyPort;
<a name="l01249"></a>01249                         }
<a name="l01250"></a>01250                 }
<a name="l01251"></a>01251                 NSMutableDictionary *proxyToUse = [NSMutableDictionary dictionaryWithObjectsAndKeys:[<span class="keyword">self</span> proxyHost],hostKey,[NSNumber numberWithInt:[<span class="keyword">self</span> proxyPort]],portKey,nil];
<a name="l01252"></a>01252 
<a name="l01253"></a>01253                 <span class="keywordflow">if</span> ([[<span class="keyword">self</span> proxyType] isEqualToString:(<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)kCFProxyTypeSOCKS]) {
<a name="l01254"></a>01254                         CFReadStreamSetProperty((CFReadStreamRef)[<span class="keyword">self</span> readStream], kCFStreamPropertySOCKSProxy, proxyToUse);
<a name="l01255"></a>01255                 } <span class="keywordflow">else</span> {
<a name="l01256"></a>01256                         CFReadStreamSetProperty((CFReadStreamRef)[<span class="keyword">self</span> readStream], kCFStreamPropertyHTTPProxy, proxyToUse);
<a name="l01257"></a>01257                 }
<a name="l01258"></a>01258         }
<a name="l01259"></a>01259 
<a name="l01260"></a>01260 
<a name="l01261"></a>01261         <span class="comment">//</span>
<a name="l01262"></a>01262         <span class="comment">// Handle persistent connections</span>
<a name="l01263"></a>01263         <span class="comment">//</span>
<a name="l01264"></a>01264         
<a name="l01265"></a>01265         [ASIHTTPRequest expirePersistentConnections];
<a name="l01266"></a>01266 
<a name="l01267"></a>01267         [connectionsLock lock];
<a name="l01268"></a>01268         
<a name="l01269"></a>01269         
<a name="l01270"></a>01270         <span class="keywordflow">if</span> (![[<span class="keyword">self</span> url] host] || ![[<span class="keyword">self</span> url] scheme]) {
<a name="l01271"></a>01271                 [<span class="keyword">self</span> setConnectionInfo:nil];
<a name="l01272"></a>01272                 [<span class="keyword">self</span> setShouldAttemptPersistentConnection:NO];
<a name="l01273"></a>01273         }
<a name="l01274"></a>01274         
<a name="l01275"></a>01275         <span class="comment">// Will store the old stream that was using this connection (if there was one) so we can clean it up once we&#39;ve opened our own stream</span>
<a name="l01276"></a>01276         NSInputStream *oldStream = nil;
<a name="l01277"></a>01277         
<a name="l01278"></a>01278         <span class="comment">// Use a persistent connection if possible</span>
<a name="l01279"></a>01279         <span class="keywordflow">if</span> ([<span class="keyword">self</span> shouldAttemptPersistentConnection]) {
<a name="l01280"></a>01280                 
<a name="l01281"></a>01281 
<a name="l01282"></a>01282                 <span class="comment">// If we are redirecting, we will re-use the current connection only if we are connecting to the same server</span>
<a name="l01283"></a>01283                 <span class="keywordflow">if</span> ([<span class="keyword">self</span> connectionInfo]) {
<a name="l01284"></a>01284                         
<a name="l01285"></a>01285                         <span class="keywordflow">if</span> (![[[<span class="keyword">self</span> connectionInfo] objectForKey:<span class="stringliteral">@&quot;host&quot;</span>] isEqualToString:[[<span class="keyword">self</span> url] host]] || ![[[<span class="keyword">self</span> connectionInfo] objectForKey:<span class="stringliteral">@&quot;scheme&quot;</span>] isEqualToString:[[<span class="keyword">self</span> url] scheme]] || [(NSNumber *)[[<span class="keyword">self</span> connectionInfo] objectForKey:<span class="stringliteral">@&quot;port&quot;</span>] intValue] != [[[<span class="keyword">self</span> url] port] intValue]) {
<a name="l01286"></a>01286                                 [<span class="keyword">self</span> setConnectionInfo:nil];
<a name="l01287"></a>01287 
<a name="l01288"></a>01288                         <span class="comment">// Check if we should have expired this connection</span>
<a name="l01289"></a>01289                         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ([[[<span class="keyword">self</span> connectionInfo] objectForKey:<span class="stringliteral">@&quot;expires&quot;</span>] timeIntervalSinceNow] &lt; 0) {
<a name="l01290"></a>01290 <span class="preprocessor">                                #if DEBUG_PERSISTENT_CONNECTIONS</span>
<a name="l01291"></a>01291 <span class="preprocessor"></span>                                NSLog(<span class="stringliteral">@&quot;[CONNECTION] Not re-using connection #%i because it has expired&quot;</span>,[[[<span class="keyword">self</span> connectionInfo] objectForKey:<span class="stringliteral">@&quot;id&quot;</span>] intValue]);
<a name="l01292"></a>01292 <span class="preprocessor">                                #endif</span>
<a name="l01293"></a>01293 <span class="preprocessor"></span>                                [persistentConnectionsPool removeObject:[<span class="keyword">self</span> connectionInfo]];
<a name="l01294"></a>01294                                 [<span class="keyword">self</span> setConnectionInfo:nil];
<a name="l01295"></a>01295 
<a name="l01296"></a>01296                         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ([[<span class="keyword">self</span> connectionInfo] objectForKey:<span class="stringliteral">@&quot;request&quot;</span>] != nil) {
<a name="l01297"></a>01297                 <span class="comment">//Some other request reused this connection already - we&#39;ll have to create a new one</span>
<a name="l01298"></a>01298 <span class="preprocessor">                                #if DEBUG_PERSISTENT_CONNECTIONS</span>
<a name="l01299"></a>01299 <span class="preprocessor"></span>                NSLog(<span class="stringliteral">@&quot;%@ - Not re-using connection #%i for request #%i because it is already used by request #%i&quot;</span>,<span class="keyword">self</span>,[[[<span class="keyword">self</span> connectionInfo] objectForKey:<span class="stringliteral">@&quot;id&quot;</span>] intValue],[[<span class="keyword">self</span> requestID] intValue],[[[<span class="keyword">self</span> connectionInfo] objectForKey:<span class="stringliteral">@&quot;request&quot;</span>] intValue]);
<a name="l01300"></a>01300 <span class="preprocessor">                                #endif</span>
<a name="l01301"></a>01301 <span class="preprocessor"></span>                [<span class="keyword">self</span> setConnectionInfo:nil];
<a name="l01302"></a>01302             }
<a name="l01303"></a>01303                 }
<a name="l01304"></a>01304                 
<a name="l01305"></a>01305                 
<a name="l01306"></a>01306                 
<a name="l01307"></a>01307                 <span class="keywordflow">if</span> (![<span class="keyword">self</span> connectionInfo] &amp;&amp; [[<span class="keyword">self</span> url] host] &amp;&amp; [[<span class="keyword">self</span> url] scheme]) { <span class="comment">// We must have a proper url with a host and scheme, or this will explode</span>
<a name="l01308"></a>01308                         
<a name="l01309"></a>01309                         <span class="comment">// Look for a connection to the same server in the pool</span>
<a name="l01310"></a>01310                         <span class="keywordflow">for</span> (NSMutableDictionary *existingConnection in persistentConnectionsPool) {
<a name="l01311"></a>01311                                 <span class="keywordflow">if</span> (![existingConnection objectForKey:<span class="stringliteral">@&quot;request&quot;</span>] &amp;&amp; [[existingConnection objectForKey:<span class="stringliteral">@&quot;host&quot;</span>] isEqualToString:[[<span class="keyword">self</span> url] host]] &amp;&amp; [[existingConnection objectForKey:<span class="stringliteral">@&quot;scheme&quot;</span>] isEqualToString:[[<span class="keyword">self</span> url] scheme]] &amp;&amp; [(NSNumber *)[existingConnection objectForKey:<span class="stringliteral">@&quot;port&quot;</span>] intValue] == [[[<span class="keyword">self</span> url] port] intValue]) {
<a name="l01312"></a>01312                                         [<span class="keyword">self</span> setConnectionInfo:existingConnection];
<a name="l01313"></a>01313                                 }
<a name="l01314"></a>01314                         }
<a name="l01315"></a>01315                 }
<a name="l01316"></a>01316                 
<a name="l01317"></a>01317                 <span class="keywordflow">if</span> ([[<span class="keyword">self</span> connectionInfo] objectForKey:<span class="stringliteral">@&quot;stream&quot;</span>]) {
<a name="l01318"></a>01318                         oldStream = [[[<span class="keyword">self</span> connectionInfo] objectForKey:@&quot;stream&quot;] retain];
<a name="l01319"></a>01319 
<a name="l01320"></a>01320                 }
<a name="l01321"></a>01321                 
<a name="l01322"></a>01322                 <span class="comment">// No free connection was found in the pool matching the server/scheme/port we&#39;re connecting to, we&#39;ll need to create a new one</span>
<a name="l01323"></a>01323                 <span class="keywordflow">if</span> (![<span class="keyword">self</span> connectionInfo]) {
<a name="l01324"></a>01324                         [<span class="keyword">self</span> setConnectionInfo:[NSMutableDictionary dictionary]];
<a name="l01325"></a>01325                         nextConnectionNumberToCreate++;
<a name="l01326"></a>01326                         [[<span class="keyword">self</span> connectionInfo] setObject:[NSNumber numberWithInt:nextConnectionNumberToCreate] forKey:@&quot;id&quot;];
<a name="l01327"></a>01327                         [[<span class="keyword">self</span> connectionInfo] setObject:[[<span class="keyword">self</span> url] host] forKey:@&quot;host&quot;];
<a name="l01328"></a>01328                         [[<span class="keyword">self</span> connectionInfo] setObject:[NSNumber numberWithInt:[[[<span class="keyword">self</span> url] port] intValue]] forKey:@&quot;port&quot;];
<a name="l01329"></a>01329                         [[<span class="keyword">self</span> connectionInfo] setObject:[[<span class="keyword">self</span> url] scheme] forKey:@&quot;scheme&quot;];
<a name="l01330"></a>01330                         [persistentConnectionsPool addObject:[<span class="keyword">self</span> connectionInfo]];
<a name="l01331"></a>01331                 }
<a name="l01332"></a>01332                 
<a name="l01333"></a>01333                 <span class="comment">// If we are retrying this request, it will already have a requestID</span>
<a name="l01334"></a>01334                 <span class="keywordflow">if</span> (![<span class="keyword">self</span> requestID]) {
<a name="l01335"></a>01335                         nextRequestID++;
<a name="l01336"></a>01336                         [<span class="keyword">self</span> setRequestID:[NSNumber numberWithUnsignedInt:nextRequestID]];
<a name="l01337"></a>01337                 }
<a name="l01338"></a>01338                 [[<span class="keyword">self</span> connectionInfo] setObject:[<span class="keyword">self</span> requestID] forKey:@&quot;request&quot;];           
<a name="l01339"></a>01339                 [[<span class="keyword">self</span> connectionInfo] setObject:[<span class="keyword">self</span> readStream] forKey:@&quot;stream&quot;];
<a name="l01340"></a>01340                 CFReadStreamSetProperty((CFReadStreamRef)[<span class="keyword">self</span> readStream],  kCFStreamPropertyHTTPAttemptPersistentConnection, kCFBooleanTrue);
<a name="l01341"></a>01341                 
<a name="l01342"></a>01342 <span class="preprocessor">                #if DEBUG_PERSISTENT_CONNECTIONS</span>
<a name="l01343"></a>01343 <span class="preprocessor"></span>                NSLog(<span class="stringliteral">@&quot;[CONNECTION] Request #%@ will use connection #%i&quot;</span>,[<span class="keyword">self</span> requestID],[[[<span class="keyword">self</span> connectionInfo] objectForKey:<span class="stringliteral">@&quot;id&quot;</span>] intValue]);
<a name="l01344"></a>01344 <span class="preprocessor">                #endif</span>
<a name="l01345"></a>01345 <span class="preprocessor"></span>                
<a name="l01346"></a>01346                 
<a name="l01347"></a>01347                 <span class="comment">// Tag the stream with an id that tells it which connection to use behind the scenes</span>
<a name="l01348"></a>01348                 <span class="comment">// See http://lists.apple.com/archives/macnetworkprog/2008/Dec/msg00001.html for details on this approach</span>
<a name="l01349"></a>01349                 
<a name="l01350"></a>01350                 CFReadStreamSetProperty((CFReadStreamRef)[<span class="keyword">self</span> readStream], CFSTR(<span class="stringliteral">&quot;ASIStreamID&quot;</span>), [[<span class="keyword">self</span> connectionInfo] objectForKey:<span class="stringliteral">@&quot;id&quot;</span>]);
<a name="l01351"></a>01351         
<a name="l01352"></a>01352         } <span class="keywordflow">else</span> {
<a name="l01353"></a>01353 <span class="preprocessor">                #if DEBUG_PERSISTENT_CONNECTIONS</span>
<a name="l01354"></a>01354 <span class="preprocessor"></span>                NSLog(<span class="stringliteral">@&quot;[CONNECTION] Request %@ will not use a persistent connection&quot;</span>,<span class="keyword">self</span>);
<a name="l01355"></a>01355 <span class="preprocessor">                #endif</span>
<a name="l01356"></a>01356 <span class="preprocessor"></span>        }
<a name="l01357"></a>01357         
<a name="l01358"></a>01358         [connectionsLock unlock];
<a name="l01359"></a>01359 
<a name="l01360"></a>01360         <span class="comment">// Schedule the stream</span>
<a name="l01361"></a>01361         <span class="keywordflow">if</span> (![<span class="keyword">self</span> readStreamIsScheduled] &amp;&amp; (!throttleWakeUpTime || [throttleWakeUpTime timeIntervalSinceDate:[NSDate date]] &lt; 0)) {
<a name="l01362"></a>01362                 [<span class="keyword">self</span> scheduleReadStream];
<a name="l01363"></a>01363         }
<a name="l01364"></a>01364         
<a name="l01365"></a>01365         BOOL streamSuccessfullyOpened = NO;
<a name="l01366"></a>01366 
<a name="l01367"></a>01367 
<a name="l01368"></a>01368    <span class="comment">// Start the HTTP connection</span>
<a name="l01369"></a>01369         CFStreamClientContext ctxt = {0, <span class="keyword">self</span>, NULL, NULL, NULL};
<a name="l01370"></a>01370     <span class="keywordflow">if</span> (CFReadStreamSetClient((CFReadStreamRef)[<span class="keyword">self</span> readStream], kNetworkEvents, ReadStreamClientCallBack, &amp;ctxt)) {
<a name="l01371"></a>01371                 <span class="keywordflow">if</span> (CFReadStreamOpen((CFReadStreamRef)[<span class="keyword">self</span> readStream])) {
<a name="l01372"></a>01372                         streamSuccessfullyOpened = YES;
<a name="l01373"></a>01373                 }
<a name="l01374"></a>01374         }
<a name="l01375"></a>01375         
<a name="l01376"></a>01376         <span class="comment">// Here, we&#39;ll close the stream that was previously using this connection, if there was one</span>
<a name="l01377"></a>01377         <span class="comment">// We&#39;ve kept it open until now (when we&#39;ve just opened a new stream) so that the new stream can make use of the old connection</span>
<a name="l01378"></a>01378         <span class="comment">// http://lists.apple.com/archives/Macnetworkprog/2006/Mar/msg00119.html</span>
<a name="l01379"></a>01379         <span class="keywordflow">if</span> (oldStream) {
<a name="l01380"></a>01380                 [oldStream close];
<a name="l01381"></a>01381                 [oldStream release];
<a name="l01382"></a>01382                 oldStream = nil;
<a name="l01383"></a>01383         }
<a name="l01384"></a>01384 
<a name="l01385"></a>01385         <span class="keywordflow">if</span> (!streamSuccessfullyOpened) {
<a name="l01386"></a>01386                 [<span class="keyword">self</span> setConnectionCanBeReused:NO];
<a name="l01387"></a>01387                 [<span class="keyword">self</span> destroyReadStream];
<a name="l01388"></a>01388                 [<span class="keyword">self</span> failWithError:[NSError errorWithDomain:NetworkRequestErrorDomain code:ASIInternalErrorWhileBuildingRequestType userInfo:[NSDictionary dictionaryWithObjectsAndKeys:@&quot;Unable to start HTTP connection&quot;,NSLocalizedDescriptionKey,nil]]];
<a name="l01389"></a>01389                 <span class="keywordflow">return</span>; 
<a name="l01390"></a>01390         }
<a name="l01391"></a>01391         
<a name="l01392"></a>01392         <span class="keywordflow">if</span> (![<span class="keyword">self</span> mainRequest]) {
<a name="l01393"></a>01393                 <span class="keywordflow">if</span> ([<span class="keyword">self</span> shouldResetUploadProgress]) {
<a name="l01394"></a>01394                         <span class="keywordflow">if</span> ([<span class="keyword">self</span> showAccurateProgress]) {
<a name="l01395"></a>01395                                 [<span class="keyword">self</span> incrementUploadSizeBy:[<span class="keyword">self</span> postLength]];
<a name="l01396"></a>01396                         } <span class="keywordflow">else</span> {
<a name="l01397"></a>01397                                 [<span class="keyword">self</span> incrementUploadSizeBy:1];  
<a name="l01398"></a>01398                         }
<a name="l01399"></a>01399                         [ASIHTTPRequest updateProgressIndicator:&amp;uploadProgressDelegate withProgress:0 ofTotal:1];
<a name="l01400"></a>01400                 }
<a name="l01401"></a>01401                 <span class="keywordflow">if</span> ([<span class="keyword">self</span> shouldResetDownloadProgress] &amp;&amp; ![<span class="keyword">self</span> partialDownloadSize]) {
<a name="l01402"></a>01402                         [ASIHTTPRequest updateProgressIndicator:&amp;downloadProgressDelegate withProgress:0 ofTotal:1];
<a name="l01403"></a>01403                 }
<a name="l01404"></a>01404         }       
<a name="l01405"></a>01405         
<a name="l01406"></a>01406         
<a name="l01407"></a>01407         <span class="comment">// Record when the request started, so we can timeout if nothing happens</span>
<a name="l01408"></a>01408         [<span class="keyword">self</span> setLastActivityTime:[NSDate date]];
<a name="l01409"></a>01409         [<span class="keyword">self</span> setStatusTimer:[NSTimer timerWithTimeInterval:0.25 target:self selector:@selector(updateStatus:) userInfo:nil repeats:YES]];
<a name="l01410"></a>01410         [[NSRunLoop currentRunLoop] addTimer:[<span class="keyword">self</span> statusTimer] forMode:[<span class="keyword">self</span> runLoopMode]];
<a name="l01411"></a>01411 }
<a name="l01412"></a>01412 
<a name="l01413"></a>01413 - (void)setStatusTimer:(NSTimer *)timer
<a name="l01414"></a>01414 {
<a name="l01415"></a>01415         CFRetain(<span class="keyword">self</span>);
<a name="l01416"></a>01416         <span class="comment">// We must invalidate the old timer here, not before we&#39;ve created and scheduled a new timer</span>
<a name="l01417"></a>01417         <span class="comment">// This is because the timer may be the only thing retaining an asynchronous request</span>
<a name="l01418"></a>01418         <span class="keywordflow">if</span> (statusTimer &amp;&amp; timer != statusTimer) {
<a name="l01419"></a>01419                 [statusTimer invalidate];
<a name="l01420"></a>01420                 [statusTimer release];
<a name="l01421"></a>01421         }
<a name="l01422"></a>01422         statusTimer = [timer retain];
<a name="l01423"></a>01423         CFRelease(<span class="keyword">self</span>);
<a name="l01424"></a>01424 }
<a name="l01425"></a>01425 
<a name="l01426"></a>01426 <span class="comment">// This gets fired every 1/4 of a second to update the progress and work out if we need to timeout</span>
<a name="l01427"></a>01427 - (void)updateStatus:(NSTimer*)timer
<a name="l01428"></a>01428 {
<a name="l01429"></a>01429         [<span class="keyword">self</span> checkRequestStatus];
<a name="l01430"></a>01430         <span class="keywordflow">if</span> (![<span class="keyword">self</span> inProgress]) {
<a name="l01431"></a>01431                 [<span class="keyword">self</span> setStatusTimer:nil];
<a name="l01432"></a>01432         }
<a name="l01433"></a>01433 }
<a name="l01434"></a>01434 
<a name="l01435"></a>01435 - (void)performRedirect
<a name="l01436"></a>01436 {
<a name="l01437"></a>01437         [<span class="keyword">self</span> setURL:[<span class="keyword">self</span> redirectURL]];
<a name="l01438"></a>01438         [<span class="keyword">self</span> setComplete:YES];
<a name="l01439"></a>01439         [<span class="keyword">self</span> setNeedsRedirect:NO];
<a name="l01440"></a>01440         [<span class="keyword">self</span> setRedirectCount:[<span class="keyword">self</span> redirectCount]+1];
<a name="l01441"></a>01441 
<a name="l01442"></a>01442         <span class="keywordflow">if</span> ([<span class="keyword">self</span> redirectCount] &gt; RedirectionLimit) {
<a name="l01443"></a>01443                 <span class="comment">// Some naughty / badly coded website is trying to force us into a redirection loop. This is not cool.</span>
<a name="l01444"></a>01444                 [<span class="keyword">self</span> failWithError:ASITooMuchRedirectionError];
<a name="l01445"></a>01445                 [<span class="keyword">self</span> setComplete:YES];
<a name="l01446"></a>01446         } <span class="keywordflow">else</span> {
<a name="l01447"></a>01447                 <span class="comment">// Go all the way back to the beginning and build the request again, so that we can apply any new cookies</span>
<a name="l01448"></a>01448                 [<span class="keyword">self</span> main];
<a name="l01449"></a>01449         }
<a name="l01450"></a>01450 }
<a name="l01451"></a>01451 
<a name="l01452"></a>01452 <span class="comment">// Called by delegate to resume loading with a new url after the delegate received request:willRedirectToURL:</span>
<a name="l01453"></a>01453 - (void)redirectToURL:(NSURL *)newURL
<a name="l01454"></a>01454 {
<a name="l01455"></a>01455         [<span class="keyword">self</span> setRedirectURL:newURL];
<a name="l01456"></a>01456         [<span class="keyword">self</span> performSelector:@selector(performRedirect) onThread:[[<span class="keyword">self</span> class] threadForRequest:self] withObject:nil waitUntilDone:NO];
<a name="l01457"></a>01457 }
<a name="l01458"></a>01458 
<a name="l01459"></a>01459 - (BOOL)shouldTimeOut
<a name="l01460"></a>01460 {
<a name="l01461"></a>01461         NSTimeInterval secondsSinceLastActivity = [[NSDate date] timeIntervalSinceDate:lastActivityTime];
<a name="l01462"></a>01462         <span class="comment">// See if we need to timeout</span>
<a name="l01463"></a>01463         <span class="keywordflow">if</span> ([<span class="keyword">self</span> readStream] &amp;&amp; [<span class="keyword">self</span> readStreamIsScheduled] &amp;&amp; [<span class="keyword">self</span> lastActivityTime] &amp;&amp; [<span class="keyword">self</span> timeOutSeconds] &gt; 0 &amp;&amp; secondsSinceLastActivity &gt; [<span class="keyword">self</span> timeOutSeconds]) {
<a name="l01464"></a>01464                 
<a name="l01465"></a>01465                 <span class="comment">// We have no body, or we&#39;ve sent more than the upload buffer size,so we can safely time out here</span>
<a name="l01466"></a>01466                 <span class="keywordflow">if</span> ([<span class="keyword">self</span> postLength] == 0 || ([<span class="keyword">self</span> uploadBufferSize] &gt; 0 &amp;&amp; [<span class="keyword">self</span> totalBytesSent] &gt; [<span class="keyword">self</span> uploadBufferSize])) {
<a name="l01467"></a>01467                         <span class="keywordflow">return</span> YES;
<a name="l01468"></a>01468                         
<a name="l01469"></a>01469                 <span class="comment">// ***Black magic warning***</span>
<a name="l01470"></a>01470                 <span class="comment">// We have a body, but we&#39;ve taken longer than timeOutSeconds to upload the first small chunk of data</span>
<a name="l01471"></a>01471                 <span class="comment">// Since there&#39;s no reliable way to track upload progress for the first 32KB (iPhone) or 128KB (Mac) with CFNetwork, we&#39;ll be slightly more forgiving on the timeout, as there&#39;s a strong chance our connection is just very slow.</span>
<a name="l01472"></a>01472                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (secondsSinceLastActivity &gt; [<span class="keyword">self</span> timeOutSeconds]*1.5) {
<a name="l01473"></a>01473                         <span class="keywordflow">return</span> YES;
<a name="l01474"></a>01474                 }
<a name="l01475"></a>01475         }
<a name="l01476"></a>01476         <span class="keywordflow">return</span> NO;
<a name="l01477"></a>01477 }
<a name="l01478"></a>01478 
<a name="l01479"></a>01479 - (void)checkRequestStatus
<a name="l01480"></a>01480 {
<a name="l01481"></a>01481         <span class="comment">// We won&#39;t let the request cancel while we&#39;re updating progress / checking for a timeout</span>
<a name="l01482"></a>01482         [[<span class="keyword">self</span> cancelledLock] lock];
<a name="l01483"></a>01483         <span class="comment">// See if our NSOperationQueue told us to cancel</span>
<a name="l01484"></a>01484         <span class="keywordflow">if</span> ([<span class="keyword">self</span> isCancelled] || [<span class="keyword">self</span> complete]) {
<a name="l01485"></a>01485                 [[<span class="keyword">self</span> cancelledLock] unlock];
<a name="l01486"></a>01486                 <span class="keywordflow">return</span>;
<a name="l01487"></a>01487         }
<a name="l01488"></a>01488         
<a name="l01489"></a>01489         [<span class="keyword">self</span> performThrottling];
<a name="l01490"></a>01490         
<a name="l01491"></a>01491         <span class="keywordflow">if</span> ([<span class="keyword">self</span> shouldTimeOut]) {                     
<a name="l01492"></a>01492                 <span class="comment">// Do we need to auto-retry this request?</span>
<a name="l01493"></a>01493                 <span class="keywordflow">if</span> ([<span class="keyword">self</span> numberOfTimesToRetryOnTimeout] &gt; [<span class="keyword">self</span> retryCount]) {
<a name="l01494"></a>01494 
<a name="l01495"></a>01495                         <span class="comment">// If we are resuming a download, we may need to update the Range header to take account of data we&#39;ve just downloaded</span>
<a name="l01496"></a>01496                         [<span class="keyword">self</span> updatePartialDownloadSize];
<a name="l01497"></a>01497                         <span class="keywordflow">if</span> ([<span class="keyword">self</span> partialDownloadSize]) {
<a name="l01498"></a>01498                                 CFHTTPMessageSetHeaderFieldValue(request, (CFStringRef)<span class="stringliteral">@&quot;Range&quot;</span>, (CFStringRef)[<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> stringWithFormat:<span class="stringliteral">@&quot;bytes=%llu-&quot;</span>,[<span class="keyword">self</span> partialDownloadSize]]);
<a name="l01499"></a>01499                         }
<a name="l01500"></a>01500                         [<span class="keyword">self</span> setRetryCount:[<span class="keyword">self</span> retryCount]+1];
<a name="l01501"></a>01501                         [<span class="keyword">self</span> unscheduleReadStream];
<a name="l01502"></a>01502                         [[<span class="keyword">self</span> cancelledLock] unlock];
<a name="l01503"></a>01503                         [<span class="keyword">self</span> startRequest];
<a name="l01504"></a>01504                         <span class="keywordflow">return</span>;
<a name="l01505"></a>01505                 }
<a name="l01506"></a>01506                 [<span class="keyword">self</span> failWithError:ASIRequestTimedOutError];
<a name="l01507"></a>01507                 [<span class="keyword">self</span> cancelLoad];
<a name="l01508"></a>01508                 [<span class="keyword">self</span> setComplete:YES];
<a name="l01509"></a>01509                 [[<span class="keyword">self</span> cancelledLock] unlock];
<a name="l01510"></a>01510                 <span class="keywordflow">return</span>;
<a name="l01511"></a>01511         }
<a name="l01512"></a>01512 
<a name="l01513"></a>01513         <span class="comment">// readStream will be null if we aren&#39;t currently running (perhaps we&#39;re waiting for a delegate to supply credentials)</span>
<a name="l01514"></a>01514         <span class="keywordflow">if</span> ([<span class="keyword">self</span> readStream]) {
<a name="l01515"></a>01515                 
<a name="l01516"></a>01516                 <span class="comment">// If we have a post body</span>
<a name="l01517"></a>01517                 <span class="keywordflow">if</span> ([<span class="keyword">self</span> postLength]) {
<a name="l01518"></a>01518                 
<a name="l01519"></a>01519                         [<span class="keyword">self</span> setLastBytesSent:totalBytesSent]; 
<a name="l01520"></a>01520                         
<a name="l01521"></a>01521                         <span class="comment">// Find out how much data we&#39;ve uploaded so far</span>
<a name="l01522"></a>01522                         [<span class="keyword">self</span> setTotalBytesSent:[NSMakeCollectable([(NSNumber *)CFReadStreamCopyProperty((CFReadStreamRef)[<span class="keyword">self</span> readStream], kCFStreamPropertyHTTPRequestBytesWrittenCount) autorelease]) unsignedLongLongValue]];
<a name="l01523"></a>01523                         <span class="keywordflow">if</span> (totalBytesSent &gt; lastBytesSent) {
<a name="l01524"></a>01524                                 
<a name="l01525"></a>01525                                 <span class="comment">// We&#39;ve uploaded more data,  reset the timeout</span>
<a name="l01526"></a>01526                                 [<span class="keyword">self</span> setLastActivityTime:[NSDate date]];
<a name="l01527"></a>01527                                 [ASIHTTPRequest incrementBandwidthUsedInLastSecond:(unsigned long)(totalBytesSent-lastBytesSent)];              
<a name="l01528"></a>01528                                                 
<a name="l01529"></a>01529 <span class="preprocessor">                                #if DEBUG_REQUEST_STATUS</span>
<a name="l01530"></a>01530 <span class="preprocessor"></span>                                <span class="keywordflow">if</span> ([<span class="keyword">self</span> totalBytesSent] == [<span class="keyword">self</span> postLength]) {
<a name="l01531"></a>01531                                         NSLog(<span class="stringliteral">@&quot;[STATUS] Request %@ finished uploading data&quot;</span>,<span class="keyword">self</span>);
<a name="l01532"></a>01532                                 }
<a name="l01533"></a>01533 <span class="preprocessor">                                #endif</span>
<a name="l01534"></a>01534 <span class="preprocessor"></span>                        }
<a name="l01535"></a>01535                 }
<a name="l01536"></a>01536                         
<a name="l01537"></a>01537                 [<span class="keyword">self</span> updateProgressIndicators];
<a name="l01538"></a>01538 
<a name="l01539"></a>01539         }
<a name="l01540"></a>01540         
<a name="l01541"></a>01541         [[<span class="keyword">self</span> cancelledLock] unlock];
<a name="l01542"></a>01542 }
<a name="l01543"></a>01543 
<a name="l01544"></a>01544 
<a name="l01545"></a>01545 <span class="comment">// Cancel loading and clean up. DO NOT USE THIS TO CANCEL REQUESTS - use [request cancel] instead</span>
<a name="l01546"></a>01546 - (void)cancelLoad
<a name="l01547"></a>01547 {
<a name="l01548"></a>01548         <span class="comment">// If we&#39;re in the middle of downloading a PAC file, let&#39;s stop that first</span>
<a name="l01549"></a>01549         <span class="keywordflow">if</span> (PACFileReadStream) {
<a name="l01550"></a>01550                 [PACFileReadStream setDelegate:nil];
<a name="l01551"></a>01551                 [PACFileReadStream close];
<a name="l01552"></a>01552                 [<span class="keyword">self</span> setPACFileReadStream:nil];
<a name="l01553"></a>01553                 [<span class="keyword">self</span> setPACFileData:nil];
<a name="l01554"></a>01554         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (PACFileRequest) {
<a name="l01555"></a>01555                 [PACFileRequest setDelegate:nil];
<a name="l01556"></a>01556                 [PACFileRequest cancel];
<a name="l01557"></a>01557                 [<span class="keyword">self</span> setPACFileRequest:nil];
<a name="l01558"></a>01558         }
<a name="l01559"></a>01559 
<a name="l01560"></a>01560     [<span class="keyword">self</span> destroyReadStream];
<a name="l01561"></a>01561         
<a name="l01562"></a>01562         [[<span class="keyword">self</span> postBodyReadStream] close];
<a name="l01563"></a>01563         [<span class="keyword">self</span> setPostBodyReadStream:nil];
<a name="l01564"></a>01564         
<a name="l01565"></a>01565     <span class="keywordflow">if</span> ([<span class="keyword">self</span> rawResponseData]) {
<a name="l01566"></a>01566                 <span class="keywordflow">if</span> (![<span class="keyword">self</span> complete]) {
<a name="l01567"></a>01567                         [<span class="keyword">self</span> setRawResponseData:nil];
<a name="l01568"></a>01568                 }
<a name="l01569"></a>01569         <span class="comment">// If we were downloading to a file</span>
<a name="l01570"></a>01570         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ([<span class="keyword">self</span> temporaryFileDownloadPath]) {
<a name="l01571"></a>01571                 [[<span class="keyword">self</span> fileDownloadOutputStream] close];
<a name="l01572"></a>01572                 [<span class="keyword">self</span> setFileDownloadOutputStream:nil];
<a name="l01573"></a>01573                 
<a name="l01574"></a>01574                 [[<span class="keyword">self</span> inflatedFileDownloadOutputStream] close];
<a name="l01575"></a>01575                 [<span class="keyword">self</span> setInflatedFileDownloadOutputStream:nil];
<a name="l01576"></a>01576                 
<a name="l01577"></a>01577                 <span class="comment">// If we haven&#39;t said we might want to resume, let&#39;s remove the temporary file too</span>
<a name="l01578"></a>01578                 <span class="keywordflow">if</span> (![<span class="keyword">self</span> complete]) {
<a name="l01579"></a>01579                         <span class="keywordflow">if</span> (![<span class="keyword">self</span> allowResumeForFileDownloads]) {
<a name="l01580"></a>01580                                 [<span class="keyword">self</span> removeTemporaryDownloadFile];
<a name="l01581"></a>01581                         }
<a name="l01582"></a>01582                         [<span class="keyword">self</span> removeTemporaryUncompressedDownloadFile];
<a name="l01583"></a>01583                 }
<a name="l01584"></a>01584         }
<a name="l01585"></a>01585         
<a name="l01586"></a>01586         <span class="comment">// Clean up any temporary file used to store request body for streaming</span>
<a name="l01587"></a>01587         <span class="keywordflow">if</span> (![<span class="keyword">self</span> authenticationNeeded] &amp;&amp; ![<span class="keyword">self</span> willRetryRequest] &amp;&amp; [<span class="keyword">self</span> didCreateTemporaryPostDataFile]) {
<a name="l01588"></a>01588                 [<span class="keyword">self</span> removeTemporaryUploadFile];
<a name="l01589"></a>01589                 [<span class="keyword">self</span> removeTemporaryCompressedUploadFile];
<a name="l01590"></a>01590                 [<span class="keyword">self</span> setDidCreateTemporaryPostDataFile:NO];
<a name="l01591"></a>01591         }
<a name="l01592"></a>01592 }
<a name="l01593"></a>01593 
<a name="l01594"></a>01594 <span class="preprocessor">#pragma mark HEAD request</span>
<a name="l01595"></a>01595 <span class="preprocessor"></span>
<a name="l01596"></a>01596 <span class="comment">// Used by ASINetworkQueue to create a HEAD request appropriate for this request with the same headers (though you can use it yourself)</span>
<a name="l01597"></a>01597 - (ASIHTTPRequest *)HEADRequest
<a name="l01598"></a>01598 {
<a name="l01599"></a>01599         ASIHTTPRequest *headRequest = [[<span class="keyword">self</span> class] requestWithURL:[<span class="keyword">self</span> url]];
<a name="l01600"></a>01600         
<a name="l01601"></a>01601         <span class="comment">// Copy the properties that make sense for a HEAD request</span>
<a name="l01602"></a>01602         [headRequest setRequestHeaders:[[[<span class="keyword">self</span> requestHeaders] mutableCopy] autorelease]];
<a name="l01603"></a>01603         [headRequest setRequestCookies:[[[<span class="keyword">self</span> requestCookies] mutableCopy] autorelease]];
<a name="l01604"></a>01604         [headRequest setUseCookiePersistence:[<span class="keyword">self</span> useCookiePersistence]];
<a name="l01605"></a>01605         [headRequest setUseKeychainPersistence:[<span class="keyword">self</span> useKeychainPersistence]];
<a name="l01606"></a>01606         [headRequest setUseSessionPersistence:[<span class="keyword">self</span> useSessionPersistence]];
<a name="l01607"></a>01607         [headRequest setAllowCompressedResponse:[<span class="keyword">self</span> allowCompressedResponse]];
<a name="l01608"></a>01608         [headRequest setUsername:[<span class="keyword">self</span> username]];
<a name="l01609"></a>01609         [headRequest setPassword:[<span class="keyword">self</span> password]];
<a name="l01610"></a>01610         [headRequest setDomain:[<span class="keyword">self</span> domain]];
<a name="l01611"></a>01611         [headRequest setProxyUsername:[<span class="keyword">self</span> proxyUsername]];
<a name="l01612"></a>01612         [headRequest setProxyPassword:[<span class="keyword">self</span> proxyPassword]];
<a name="l01613"></a>01613         [headRequest setProxyDomain:[<span class="keyword">self</span> proxyDomain]];
<a name="l01614"></a>01614         [headRequest setProxyHost:[<span class="keyword">self</span> proxyHost]];
<a name="l01615"></a>01615         [headRequest setProxyPort:[<span class="keyword">self</span> proxyPort]];
<a name="l01616"></a>01616         [headRequest setProxyType:[<span class="keyword">self</span> proxyType]];
<a name="l01617"></a>01617         [headRequest setShouldPresentAuthenticationDialog:[<span class="keyword">self</span> shouldPresentAuthenticationDialog]];
<a name="l01618"></a>01618         [headRequest setShouldPresentProxyAuthenticationDialog:[<span class="keyword">self</span> shouldPresentProxyAuthenticationDialog]];
<a name="l01619"></a>01619         [headRequest setTimeOutSeconds:[<span class="keyword">self</span> timeOutSeconds]];
<a name="l01620"></a>01620         [headRequest setUseHTTPVersionOne:[<span class="keyword">self</span> useHTTPVersionOne]];
<a name="l01621"></a>01621         [headRequest setValidatesSecureCertificate:[<span class="keyword">self</span> validatesSecureCertificate]];
<a name="l01622"></a>01622     [headRequest setClientCertificateIdentity:clientCertificateIdentity];
<a name="l01623"></a>01623         [headRequest setClientCertificates:[[clientCertificates copy] autorelease]];
<a name="l01624"></a>01624         [headRequest setPACurl:[<span class="keyword">self</span> PACurl]];
<a name="l01625"></a>01625         [headRequest setShouldPresentCredentialsBeforeChallenge:[<span class="keyword">self</span> shouldPresentCredentialsBeforeChallenge]];
<a name="l01626"></a>01626         [headRequest setNumberOfTimesToRetryOnTimeout:[<span class="keyword">self</span> numberOfTimesToRetryOnTimeout]];
<a name="l01627"></a>01627         [headRequest setShouldUseRFC2616RedirectBehaviour:[<span class="keyword">self</span> shouldUseRFC2616RedirectBehaviour]];
<a name="l01628"></a>01628         [headRequest setShouldAttemptPersistentConnection:[<span class="keyword">self</span> shouldAttemptPersistentConnection]];
<a name="l01629"></a>01629         [headRequest setPersistentConnectionTimeoutSeconds:[<span class="keyword">self</span> persistentConnectionTimeoutSeconds]];
<a name="l01630"></a>01630         
<a name="l01631"></a>01631         [headRequest setMainRequest:self];
<a name="l01632"></a>01632         [headRequest setRequestMethod:@&quot;HEAD&quot;];
<a name="l01633"></a>01633         <span class="keywordflow">return</span> headRequest;
<a name="l01634"></a>01634 }
<a name="l01635"></a>01635 
<a name="l01636"></a>01636 
<a name="l01637"></a>01637 <span class="preprocessor">#pragma mark upload/download progress</span>
<a name="l01638"></a>01638 <span class="preprocessor"></span>
<a name="l01639"></a>01639 
<a name="l01640"></a>01640 - (void)updateProgressIndicators
<a name="l01641"></a>01641 {
<a name="l01642"></a>01642         <span class="comment">//Only update progress if this isn&#39;t a HEAD request used to preset the content-length</span>
<a name="l01643"></a>01643         <span class="keywordflow">if</span> (![<span class="keyword">self</span> mainRequest]) {
<a name="l01644"></a>01644                 <span class="keywordflow">if</span> ([<span class="keyword">self</span> showAccurateProgress] || ([<span class="keyword">self</span> complete] &amp;&amp; ![<span class="keyword">self</span> updatedProgress])) {
<a name="l01645"></a>01645                         [<span class="keyword">self</span> updateUploadProgress];
<a name="l01646"></a>01646                         [<span class="keyword">self</span> updateDownloadProgress];
<a name="l01647"></a>01647                 }
<a name="l01648"></a>01648         }
<a name="l01649"></a>01649 }
<a name="l01650"></a>01650 
<a name="l01651"></a>01651 - (id)uploadProgressDelegate
<a name="l01652"></a>01652 {
<a name="l01653"></a>01653         [[<span class="keyword">self</span> cancelledLock] lock];
<a name="l01654"></a>01654         <span class="keywordtype">id</span> d = [[uploadProgressDelegate retain] autorelease];
<a name="l01655"></a>01655         [[<span class="keyword">self</span> cancelledLock] unlock];
<a name="l01656"></a>01656         <span class="keywordflow">return</span> d;
<a name="l01657"></a>01657 }
<a name="l01658"></a>01658 
<a name="l01659"></a>01659 - (void)setUploadProgressDelegate:(<span class="keywordtype">id</span>)newDelegate
<a name="l01660"></a>01660 {
<a name="l01661"></a>01661         [[<span class="keyword">self</span> cancelledLock] lock];
<a name="l01662"></a>01662         uploadProgressDelegate = newDelegate;
<a name="l01663"></a>01663 
<a name="l01664"></a>01664 <span class="preprocessor">        #if !TARGET_OS_IPHONE</span>
<a name="l01665"></a>01665 <span class="preprocessor"></span>        <span class="comment">// If the uploadProgressDelegate is an NSProgressIndicator, we set its MaxValue to 1.0 so we can update it as if it were a UIProgressView</span>
<a name="l01666"></a>01666         <span class="keywordtype">double</span> max = 1.0;
<a name="l01667"></a>01667         [ASIHTTPRequest performSelector:@selector(setMaxValue:) onTarget:&amp;uploadProgressDelegate withObject:nil amount:&amp;max callerToRetain:nil];
<a name="l01668"></a>01668 <span class="preprocessor">        #endif</span>
<a name="l01669"></a>01669 <span class="preprocessor"></span>        [[<span class="keyword">self</span> cancelledLock] unlock];
<a name="l01670"></a>01670 }
<a name="l01671"></a>01671 
<a name="l01672"></a>01672 - (id)downloadProgressDelegate
<a name="l01673"></a>01673 {
<a name="l01674"></a>01674         [[<span class="keyword">self</span> cancelledLock] lock];
<a name="l01675"></a>01675         <span class="keywordtype">id</span> d = [[downloadProgressDelegate retain] autorelease];
<a name="l01676"></a>01676         [[<span class="keyword">self</span> cancelledLock] unlock];
<a name="l01677"></a>01677         <span class="keywordflow">return</span> d;
<a name="l01678"></a>01678 }
<a name="l01679"></a>01679 
<a name="l01680"></a>01680 - (void)setDownloadProgressDelegate:(<span class="keywordtype">id</span>)newDelegate
<a name="l01681"></a>01681 {
<a name="l01682"></a>01682         [[<span class="keyword">self</span> cancelledLock] lock];
<a name="l01683"></a>01683         downloadProgressDelegate = newDelegate;
<a name="l01684"></a>01684 
<a name="l01685"></a>01685 <span class="preprocessor">        #if !TARGET_OS_IPHONE</span>
<a name="l01686"></a>01686 <span class="preprocessor"></span>        <span class="comment">// If the downloadProgressDelegate is an NSProgressIndicator, we set its MaxValue to 1.0 so we can update it as if it were a UIProgressView</span>
<a name="l01687"></a>01687         <span class="keywordtype">double</span> max = 1.0;
<a name="l01688"></a>01688         [ASIHTTPRequest performSelector:@selector(setMaxValue:) onTarget:&amp;downloadProgressDelegate withObject:nil amount:&amp;max callerToRetain:nil];      
<a name="l01689"></a>01689 <span class="preprocessor">        #endif</span>
<a name="l01690"></a>01690 <span class="preprocessor"></span>        [[<span class="keyword">self</span> cancelledLock] unlock];
<a name="l01691"></a>01691 }
<a name="l01692"></a>01692 
<a name="l01693"></a>01693 
<a name="l01694"></a>01694 - (void)updateDownloadProgress
<a name="l01695"></a>01695 {
<a name="l01696"></a>01696         <span class="comment">// We won&#39;t update download progress until we&#39;ve examined the headers, since we might need to authenticate</span>
<a name="l01697"></a>01697         <span class="keywordflow">if</span> (![<span class="keyword">self</span> responseHeaders] || [<span class="keyword">self</span> needsRedirect] || !([<span class="keyword">self</span> contentLength] || [<span class="keyword">self</span> complete])) {
<a name="l01698"></a>01698                 <span class="keywordflow">return</span>;
<a name="l01699"></a>01699         }
<a name="l01700"></a>01700                 
<a name="l01701"></a>01701         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> bytesReadSoFar = [<span class="keyword">self</span> totalBytesRead]+[self partialDownloadSize];
<a name="l01702"></a>01702         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> value = 0;
<a name="l01703"></a>01703         
<a name="l01704"></a>01704         <span class="keywordflow">if</span> ([<span class="keyword">self</span> showAccurateProgress] &amp;&amp; [<span class="keyword">self</span> contentLength]) {
<a name="l01705"></a>01705                 value = bytesReadSoFar-[self lastBytesRead];
<a name="l01706"></a>01706                 <span class="keywordflow">if</span> (value == 0) {
<a name="l01707"></a>01707                         <span class="keywordflow">return</span>;
<a name="l01708"></a>01708                 }
<a name="l01709"></a>01709         } <span class="keywordflow">else</span> {
<a name="l01710"></a>01710                 value = 1;
<a name="l01711"></a>01711                 [<span class="keyword">self</span> setUpdatedProgress:YES];
<a name="l01712"></a>01712         }
<a name="l01713"></a>01713         <span class="keywordflow">if</span> (!value) {
<a name="l01714"></a>01714                 <span class="keywordflow">return</span>;
<a name="l01715"></a>01715         }
<a name="l01716"></a>01716 
<a name="l01717"></a>01717         [ASIHTTPRequest performSelector:@selector(request:didReceiveBytes:) onTarget:&amp;queue withObject:self amount:&amp;value callerToRetain:self];
<a name="l01718"></a>01718         [ASIHTTPRequest performSelector:@selector(request:didReceiveBytes:) onTarget:&amp;downloadProgressDelegate withObject:self amount:&amp;value callerToRetain:self];
<a name="l01719"></a>01719 
<a name="l01720"></a>01720         [ASIHTTPRequest updateProgressIndicator:&amp;downloadProgressDelegate withProgress:[<span class="keyword">self</span> totalBytesRead]+[<span class="keyword">self</span> partialDownloadSize] ofTotal:[<span class="keyword">self</span> contentLength]+[<span class="keyword">self</span> partialDownloadSize]];
<a name="l01721"></a>01721 
<a name="l01722"></a>01722 <span class="preprocessor">        #if NS_BLOCKS_AVAILABLE</span>
<a name="l01723"></a>01723 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (bytesReceivedBlock) {
<a name="l01724"></a>01724                 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> totalSize = [<span class="keyword">self</span> contentLength] + [self partialDownloadSize];
<a name="l01725"></a>01725                 [<span class="keyword">self</span> performBlockOnMainThread:^{ if (bytesReceivedBlock) { bytesReceivedBlock(value, totalSize); }}];
<a name="l01726"></a>01726     }
<a name="l01727"></a>01727 <span class="preprocessor">        #endif</span>
<a name="l01728"></a>01728 <span class="preprocessor"></span>        [<span class="keyword">self</span> setLastBytesRead:bytesReadSoFar];
<a name="l01729"></a>01729 }
<a name="l01730"></a>01730 
<a name="l01731"></a>01731 - (void)updateUploadProgress
<a name="l01732"></a>01732 {
<a name="l01733"></a>01733         <span class="keywordflow">if</span> ([<span class="keyword">self</span> isCancelled] || [<span class="keyword">self</span> totalBytesSent] == 0) {
<a name="l01734"></a>01734                 <span class="keywordflow">return</span>;
<a name="l01735"></a>01735         }
<a name="l01736"></a>01736         
<a name="l01737"></a>01737         <span class="comment">// If this is the first time we&#39;ve written to the buffer, totalBytesSent will be the size of the buffer (currently seems to be 128KB on both Leopard and iPhone 2.2.1, 32KB on iPhone 3.0)</span>
<a name="l01738"></a>01738         <span class="comment">// If request body is less than the buffer size, totalBytesSent will be the total size of the request body</span>
<a name="l01739"></a>01739         <span class="comment">// We will remove this from any progress display, as kCFStreamPropertyHTTPRequestBytesWrittenCount does not tell us how much data has actually be written</span>
<a name="l01740"></a>01740         <span class="keywordflow">if</span> ([<span class="keyword">self</span> uploadBufferSize] == 0 &amp;&amp; [<span class="keyword">self</span> totalBytesSent] != [<span class="keyword">self</span> postLength]) {
<a name="l01741"></a>01741                 [<span class="keyword">self</span> setUploadBufferSize:[<span class="keyword">self</span> totalBytesSent]];
<a name="l01742"></a>01742                 [<span class="keyword">self</span> incrementUploadSizeBy:-[<span class="keyword">self</span> uploadBufferSize]];
<a name="l01743"></a>01743         }
<a name="l01744"></a>01744         
<a name="l01745"></a>01745         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> value = 0;
<a name="l01746"></a>01746         
<a name="l01747"></a>01747         <span class="keywordflow">if</span> ([<span class="keyword">self</span> showAccurateProgress]) {
<a name="l01748"></a>01748                 <span class="keywordflow">if</span> ([<span class="keyword">self</span> totalBytesSent] == [<span class="keyword">self</span> postLength] || [<span class="keyword">self</span> lastBytesSent] &gt; 0) {
<a name="l01749"></a>01749                         value = [<span class="keyword">self</span> totalBytesSent]-[self lastBytesSent];
<a name="l01750"></a>01750                 } <span class="keywordflow">else</span> {
<a name="l01751"></a>01751                         <span class="keywordflow">return</span>;
<a name="l01752"></a>01752                 }
<a name="l01753"></a>01753         } <span class="keywordflow">else</span> {
<a name="l01754"></a>01754                 value = 1;
<a name="l01755"></a>01755                 [<span class="keyword">self</span> setUpdatedProgress:YES];
<a name="l01756"></a>01756         }
<a name="l01757"></a>01757         
<a name="l01758"></a>01758         <span class="keywordflow">if</span> (!value) {
<a name="l01759"></a>01759                 <span class="keywordflow">return</span>;
<a name="l01760"></a>01760         }
<a name="l01761"></a>01761         
<a name="l01762"></a>01762         [ASIHTTPRequest performSelector:@selector(request:didSendBytes:) onTarget:&amp;queue withObject:self amount:&amp;value callerToRetain:self];
<a name="l01763"></a>01763         [ASIHTTPRequest performSelector:@selector(request:didSendBytes:) onTarget:&amp;uploadProgressDelegate withObject:self amount:&amp;value callerToRetain:self];
<a name="l01764"></a>01764         [ASIHTTPRequest updateProgressIndicator:&amp;uploadProgressDelegate withProgress:[<span class="keyword">self</span> totalBytesSent]-[<span class="keyword">self</span> uploadBufferSize] ofTotal:[<span class="keyword">self</span> postLength]-[<span class="keyword">self</span> uploadBufferSize]];
<a name="l01765"></a>01765 
<a name="l01766"></a>01766 <span class="preprocessor">        #if NS_BLOCKS_AVAILABLE</span>
<a name="l01767"></a>01767 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(bytesSentBlock){
<a name="l01768"></a>01768                 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> totalSize = [<span class="keyword">self</span> postLength];
<a name="l01769"></a>01769                 [<span class="keyword">self</span> performBlockOnMainThread:^{ if (bytesSentBlock) { bytesSentBlock(value, totalSize); }}];
<a name="l01770"></a>01770         }
<a name="l01771"></a>01771 <span class="preprocessor">        #endif</span>
<a name="l01772"></a>01772 <span class="preprocessor"></span>}
<a name="l01773"></a>01773 
<a name="l01774"></a>01774 
<a name="l01775"></a>01775 - (void)incrementDownloadSizeBy:(<span class="keywordtype">long</span> <span class="keywordtype">long</span>)length
<a name="l01776"></a>01776 {
<a name="l01777"></a>01777         [ASIHTTPRequest performSelector:@selector(request:incrementDownloadSizeBy:) onTarget:&amp;queue withObject:self amount:&amp;length callerToRetain:self];
<a name="l01778"></a>01778         [ASIHTTPRequest performSelector:@selector(request:incrementDownloadSizeBy:) onTarget:&amp;downloadProgressDelegate withObject:self amount:&amp;length callerToRetain:self];
<a name="l01779"></a>01779 
<a name="l01780"></a>01780 <span class="preprocessor">        #if NS_BLOCKS_AVAILABLE</span>
<a name="l01781"></a>01781 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(downloadSizeIncrementedBlock){
<a name="l01782"></a>01782                 [<span class="keyword">self</span> performBlockOnMainThread:^{ if (downloadSizeIncrementedBlock) { downloadSizeIncrementedBlock(length); }}];
<a name="l01783"></a>01783     }
<a name="l01784"></a>01784 <span class="preprocessor">        #endif</span>
<a name="l01785"></a>01785 <span class="preprocessor"></span>}
<a name="l01786"></a>01786 
<a name="l01787"></a>01787 - (void)incrementUploadSizeBy:(<span class="keywordtype">long</span> <span class="keywordtype">long</span>)length
<a name="l01788"></a>01788 {
<a name="l01789"></a>01789         [ASIHTTPRequest performSelector:@selector(request:incrementUploadSizeBy:) onTarget:&amp;queue withObject:self amount:&amp;length callerToRetain:self];
<a name="l01790"></a>01790         [ASIHTTPRequest performSelector:@selector(request:incrementUploadSizeBy:) onTarget:&amp;uploadProgressDelegate withObject:self amount:&amp;length callerToRetain:self];
<a name="l01791"></a>01791 
<a name="l01792"></a>01792 <span class="preprocessor">        #if NS_BLOCKS_AVAILABLE</span>
<a name="l01793"></a>01793 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(uploadSizeIncrementedBlock) {
<a name="l01794"></a>01794                 [<span class="keyword">self</span> performBlockOnMainThread:^{ if (uploadSizeIncrementedBlock) { uploadSizeIncrementedBlock(length); }}];
<a name="l01795"></a>01795     }
<a name="l01796"></a>01796 <span class="preprocessor">        #endif</span>
<a name="l01797"></a>01797 <span class="preprocessor"></span>}
<a name="l01798"></a>01798 
<a name="l01799"></a>01799 
<a name="l01800"></a>01800 -(void)removeUploadProgressSoFar
<a name="l01801"></a>01801 {
<a name="l01802"></a>01802         <span class="keywordtype">long</span> <span class="keywordtype">long</span> progressToRemove = -[self totalBytesSent];
<a name="l01803"></a>01803         [ASIHTTPRequest performSelector:@selector(request:didSendBytes:) onTarget:&amp;queue withObject:self amount:&amp;progressToRemove callerToRetain:self];
<a name="l01804"></a>01804         [ASIHTTPRequest performSelector:@selector(request:didSendBytes:) onTarget:&amp;uploadProgressDelegate withObject:self amount:&amp;progressToRemove callerToRetain:self];
<a name="l01805"></a>01805         [ASIHTTPRequest updateProgressIndicator:&amp;uploadProgressDelegate withProgress:0 ofTotal:[<span class="keyword">self</span> postLength]];
<a name="l01806"></a>01806 
<a name="l01807"></a>01807 <span class="preprocessor">        #if NS_BLOCKS_AVAILABLE</span>
<a name="l01808"></a>01808 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(bytesSentBlock){
<a name="l01809"></a>01809                 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> totalSize = [<span class="keyword">self</span> postLength];
<a name="l01810"></a>01810                 [<span class="keyword">self</span> performBlockOnMainThread:^{  if (bytesSentBlock) { bytesSentBlock(progressToRemove, totalSize); }}];
<a name="l01811"></a>01811         }
<a name="l01812"></a>01812 <span class="preprocessor">        #endif</span>
<a name="l01813"></a>01813 <span class="preprocessor"></span>}
<a name="l01814"></a>01814 
<a name="l01815"></a>01815 <span class="preprocessor">#if NS_BLOCKS_AVAILABLE</span>
<a name="l01816"></a>01816 <span class="preprocessor"></span>- (void)performBlockOnMainThread:(ASIBasicBlock)block
<a name="l01817"></a>01817 {
<a name="l01818"></a>01818         [<span class="keyword">self</span> performSelectorOnMainThread:@selector(callBlock:) withObject:[[block copy] autorelease] waitUntilDone:[NSThread isMainThread]];
<a name="l01819"></a>01819 }
<a name="l01820"></a>01820 
<a name="l01821"></a>01821 - (void)callBlock:(ASIBasicBlock)block
<a name="l01822"></a>01822 {
<a name="l01823"></a>01823         block();
<a name="l01824"></a>01824 }
<a name="l01825"></a>01825 <span class="preprocessor">#endif</span>
<a name="l01826"></a>01826 <span class="preprocessor"></span>
<a name="l01827"></a>01827 
<a name="l01828"></a>01828 + (void)performSelector:(<span class="keywordtype">SEL</span>)selector onTarget:(<span class="keywordtype">id</span> *)target withObject:(<span class="keywordtype">id</span>)object amount:(<span class="keywordtype">void</span> *)amount callerToRetain:(<span class="keywordtype">id</span>)callerToRetain
<a name="l01829"></a>01829 {
<a name="l01830"></a>01830         <span class="keywordflow">if</span> ([*target respondsToSelector:selector]) {
<a name="l01831"></a>01831                 NSMethodSignature *signature = nil;
<a name="l01832"></a>01832                 signature = [*target methodSignatureForSelector:selector];
<a name="l01833"></a>01833                 NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:signature];
<a name="l01834"></a>01834 
<a name="l01835"></a>01835                 [invocation setSelector:selector];
<a name="l01836"></a>01836                 
<a name="l01837"></a>01837                 <span class="keywordtype">int</span> argumentNumber = 2;
<a name="l01838"></a>01838                 
<a name="l01839"></a>01839                 <span class="comment">// If we got an object parameter, we pass a pointer to the object pointer</span>
<a name="l01840"></a>01840                 <span class="keywordflow">if</span> (<span class="keywordtype">object</span>) {
<a name="l01841"></a>01841                         [invocation setArgument:&amp;object atIndex:argumentNumber];
<a name="l01842"></a>01842                         argumentNumber++;
<a name="l01843"></a>01843                 }
<a name="l01844"></a>01844                 
<a name="l01845"></a>01845                 <span class="comment">// For the amount we&#39;ll just pass the pointer directly so NSInvocation will call the method using the number itself rather than a pointer to it</span>
<a name="l01846"></a>01846                 <span class="keywordflow">if</span> (amount) {
<a name="l01847"></a>01847                         [invocation setArgument:amount atIndex:argumentNumber];
<a name="l01848"></a>01848                 }
<a name="l01849"></a>01849 
<a name="l01850"></a>01850         <span class="keywordtype">SEL</span> callback = <span class="keyword">@selector</span>(performInvocation:onTarget:releasingObject:);
<a name="l01851"></a>01851         NSMethodSignature *cbSignature = [ASIHTTPRequest methodSignatureForSelector:callback];
<a name="l01852"></a>01852         NSInvocation *cbInvocation = [NSInvocation invocationWithMethodSignature:cbSignature];
<a name="l01853"></a>01853         [cbInvocation setSelector:callback];
<a name="l01854"></a>01854         [cbInvocation setTarget:self];
<a name="l01855"></a>01855         [cbInvocation setArgument:&amp;invocation atIndex:2];
<a name="l01856"></a>01856         [cbInvocation setArgument:&amp;target atIndex:3];
<a name="l01857"></a>01857                 <span class="keywordflow">if</span> (callerToRetain) {
<a name="l01858"></a>01858                         [cbInvocation setArgument:&amp;callerToRetain atIndex:4];
<a name="l01859"></a>01859                 }
<a name="l01860"></a>01860 
<a name="l01861"></a>01861                 CFRetain(invocation);
<a name="l01862"></a>01862 
<a name="l01863"></a>01863                 <span class="comment">// Used to pass in a request that we must retain until after the call</span>
<a name="l01864"></a>01864                 <span class="comment">// We&#39;re using CFRetain rather than [callerToRetain retain] so things to avoid earthquakes when using garbage collection</span>
<a name="l01865"></a>01865                 <span class="keywordflow">if</span> (callerToRetain) {
<a name="l01866"></a>01866                         CFRetain(callerToRetain);
<a name="l01867"></a>01867                 }
<a name="l01868"></a>01868         [cbInvocation performSelectorOnMainThread:@selector(invoke) withObject:nil waitUntilDone:[NSThread isMainThread]];
<a name="l01869"></a>01869     }
<a name="l01870"></a>01870 }
<a name="l01871"></a>01871 
<a name="l01872"></a>01872 + (void)performInvocation:(NSInvocation *)invocation onTarget:(<span class="keywordtype">id</span> *)target releasingObject:(<span class="keywordtype">id</span>)objectToRelease
<a name="l01873"></a>01873 {
<a name="l01874"></a>01874     <span class="keywordflow">if</span> (*target &amp;&amp; [*target respondsToSelector:[invocation selector]]) {
<a name="l01875"></a>01875         [invocation invokeWithTarget:*target];
<a name="l01876"></a>01876     }
<a name="l01877"></a>01877         CFRelease(invocation);
<a name="l01878"></a>01878         <span class="keywordflow">if</span> (objectToRelease) {
<a name="l01879"></a>01879                 CFRelease(objectToRelease);
<a name="l01880"></a>01880         }
<a name="l01881"></a>01881 }
<a name="l01882"></a>01882         
<a name="l01883"></a>01883         
<a name="l01884"></a>01884 + (void)updateProgressIndicator:(<span class="keywordtype">id</span> *)indicator withProgress:(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)progress ofTotal:(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)total
<a name="l01885"></a>01885 {
<a name="l01886"></a>01886 <span class="preprocessor">        #if TARGET_OS_IPHONE</span>
<a name="l01887"></a>01887 <span class="preprocessor"></span>                <span class="comment">// Cocoa Touch: UIProgressView</span>
<a name="l01888"></a>01888                 <span class="keywordtype">SEL</span> selector = <span class="keyword">@selector</span>(setProgress:);
<a name="l01889"></a>01889                 <span class="keywordtype">float</span> progressAmount = (float)((progress*1.0)/(total*1.0));
<a name="l01890"></a>01890                 
<a name="l01891"></a>01891 <span class="preprocessor">        #else</span>
<a name="l01892"></a>01892 <span class="preprocessor"></span>                <span class="comment">// Cocoa: NSProgressIndicator</span>
<a name="l01893"></a>01893                 <span class="keywordtype">double</span> progressAmount = progressAmount = (progress*1.0)/(total*1.0);
<a name="l01894"></a>01894                 <span class="keywordtype">SEL</span> selector = <span class="keyword">@selector</span>(setDoubleValue:);
<a name="l01895"></a>01895 <span class="preprocessor">        #endif</span>
<a name="l01896"></a>01896 <span class="preprocessor"></span>        
<a name="l01897"></a>01897         <span class="keywordflow">if</span> (![*indicator respondsToSelector:selector]) {
<a name="l01898"></a>01898                 <span class="keywordflow">return</span>;
<a name="l01899"></a>01899         }
<a name="l01900"></a>01900         
<a name="l01901"></a>01901         [progressLock lock];
<a name="l01902"></a>01902         [ASIHTTPRequest performSelector:selector onTarget:indicator withObject:nil amount:&amp;progressAmount callerToRetain:nil];
<a name="l01903"></a>01903         [progressLock unlock];
<a name="l01904"></a>01904 }
<a name="l01905"></a>01905 
<a name="l01906"></a>01906 
<a name="l01907"></a>01907 <span class="preprocessor">#pragma mark talking to delegates / calling blocks</span>
<a name="l01908"></a>01908 <span class="preprocessor"></span>
<a name="l01909"></a>01909 <span class="comment">/* ALWAYS CALLED ON MAIN THREAD! */</span>
<a name="l01910"></a>01910 - (void)requestStarted
<a name="l01911"></a>01911 {
<a name="l01912"></a>01912         <span class="keywordflow">if</span> ([<span class="keyword">self</span> error] || [<span class="keyword">self</span> mainRequest]) {
<a name="l01913"></a>01913                 <span class="keywordflow">return</span>;
<a name="l01914"></a>01914         }
<a name="l01915"></a>01915         <span class="keywordflow">if</span> (delegate &amp;&amp; [delegate respondsToSelector:didStartSelector]) {
<a name="l01916"></a>01916                 [delegate performSelector:didStartSelector withObject:self];
<a name="l01917"></a>01917         }
<a name="l01918"></a>01918 <span class="preprocessor">        #if NS_BLOCKS_AVAILABLE</span>
<a name="l01919"></a>01919 <span class="preprocessor"></span>        <span class="keywordflow">if</span>(startedBlock){
<a name="l01920"></a>01920                 startedBlock();
<a name="l01921"></a>01921         }
<a name="l01922"></a>01922 <span class="preprocessor">        #endif</span>
<a name="l01923"></a>01923 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (queue &amp;&amp; [queue respondsToSelector:<span class="keyword">@selector</span>(requestStarted:)]) {
<a name="l01924"></a>01924                 [queue performSelector:@selector(requestStarted:) withObject:self];
<a name="l01925"></a>01925         }
<a name="l01926"></a>01926 }
<a name="l01927"></a>01927 
<a name="l01928"></a>01928 <span class="comment">/* ALWAYS CALLED ON MAIN THREAD! */</span>
<a name="l01929"></a>01929 - (void)requestRedirected
<a name="l01930"></a>01930 {
<a name="l01931"></a>01931         <span class="keywordflow">if</span> ([<span class="keyword">self</span> error] || [<span class="keyword">self</span> mainRequest]) {
<a name="l01932"></a>01932                 <span class="keywordflow">return</span>;
<a name="l01933"></a>01933         }
<a name="l01934"></a>01934 
<a name="l01935"></a>01935         <span class="keywordflow">if</span>([[<span class="keyword">self</span> delegate] respondsToSelector:<span class="keyword">@selector</span>(requestRedirected:)]){
<a name="l01936"></a>01936                 [[<span class="keyword">self</span> delegate] performSelector:@selector(requestRedirected:) withObject:self];
<a name="l01937"></a>01937         }
<a name="l01938"></a>01938 
<a name="l01939"></a>01939 <span class="preprocessor">        #if NS_BLOCKS_AVAILABLE</span>
<a name="l01940"></a>01940 <span class="preprocessor"></span>        <span class="keywordflow">if</span>(requestRedirectedBlock){
<a name="l01941"></a>01941                 requestRedirectedBlock();
<a name="l01942"></a>01942         }
<a name="l01943"></a>01943 <span class="preprocessor">        #endif</span>
<a name="l01944"></a>01944 <span class="preprocessor"></span>}
<a name="l01945"></a>01945 
<a name="l01946"></a>01946 
<a name="l01947"></a>01947 <span class="comment">/* ALWAYS CALLED ON MAIN THREAD! */</span>
<a name="l01948"></a>01948 - (void)requestReceivedResponseHeaders:(NSMutableDictionary *)newResponseHeaders
<a name="l01949"></a>01949 {
<a name="l01950"></a>01950         <span class="keywordflow">if</span> ([<span class="keyword">self</span> error] || [<span class="keyword">self</span> mainRequest]) {
<a name="l01951"></a>01951                 <span class="keywordflow">return</span>;
<a name="l01952"></a>01952         }
<a name="l01953"></a>01953 
<a name="l01954"></a>01954         <span class="keywordflow">if</span> (delegate &amp;&amp; [delegate respondsToSelector:didReceiveResponseHeadersSelector]) {
<a name="l01955"></a>01955                 [delegate performSelector:didReceiveResponseHeadersSelector withObject:self withObject:newResponseHeaders];
<a name="l01956"></a>01956         }
<a name="l01957"></a>01957 
<a name="l01958"></a>01958 <span class="preprocessor">        #if NS_BLOCKS_AVAILABLE</span>
<a name="l01959"></a>01959 <span class="preprocessor"></span>        <span class="keywordflow">if</span>(headersReceivedBlock){
<a name="l01960"></a>01960                 headersReceivedBlock(newResponseHeaders);
<a name="l01961"></a>01961     }
<a name="l01962"></a>01962 <span class="preprocessor">        #endif</span>
<a name="l01963"></a>01963 <span class="preprocessor"></span>
<a name="l01964"></a>01964         <span class="keywordflow">if</span> (queue &amp;&amp; [queue respondsToSelector:<span class="keyword">@selector</span>(request:didReceiveResponseHeaders:)]) {
<a name="l01965"></a>01965                 [queue performSelector:@selector(request:didReceiveResponseHeaders:) withObject:self withObject:newResponseHeaders];
<a name="l01966"></a>01966         }
<a name="l01967"></a>01967 }
<a name="l01968"></a>01968 
<a name="l01969"></a>01969 <span class="comment">/* ALWAYS CALLED ON MAIN THREAD! */</span>
<a name="l01970"></a>01970 - (void)requestWillRedirectToURL:(NSURL *)newURL
<a name="l01971"></a>01971 {
<a name="l01972"></a>01972         <span class="keywordflow">if</span> ([<span class="keyword">self</span> error] || [<span class="keyword">self</span> mainRequest]) {
<a name="l01973"></a>01973                 <span class="keywordflow">return</span>;
<a name="l01974"></a>01974         }
<a name="l01975"></a>01975         <span class="keywordflow">if</span> (delegate &amp;&amp; [delegate respondsToSelector:willRedirectSelector]) {
<a name="l01976"></a>01976                 [delegate performSelector:willRedirectSelector withObject:self withObject:newURL];
<a name="l01977"></a>01977         }
<a name="l01978"></a>01978         <span class="keywordflow">if</span> (queue &amp;&amp; [queue respondsToSelector:<span class="keyword">@selector</span>(request:willRedirectToURL:)]) {
<a name="l01979"></a>01979                 [queue performSelector:@selector(request:willRedirectToURL:) withObject:self withObject:newURL];
<a name="l01980"></a>01980         }
<a name="l01981"></a>01981 }
<a name="l01982"></a>01982 
<a name="l01983"></a>01983 <span class="comment">// Subclasses might override this method to process the result in the same thread</span>
<a name="l01984"></a>01984 <span class="comment">// If you do this, don&#39;t forget to call [super requestFinished] to let the queue / delegate know we&#39;re done</span>
<a name="l01985"></a>01985 - (void)requestFinished
<a name="l01986"></a>01986 {
<a name="l01987"></a>01987 <span class="preprocessor">#if DEBUG_REQUEST_STATUS || DEBUG_THROTTLING</span>
<a name="l01988"></a>01988 <span class="preprocessor"></span>        NSLog(<span class="stringliteral">@&quot;[STATUS] Request finished: %@&quot;</span>,<span class="keyword">self</span>);
<a name="l01989"></a>01989 <span class="preprocessor">#endif</span>
<a name="l01990"></a>01990 <span class="preprocessor"></span>        <span class="keywordflow">if</span> ([<span class="keyword">self</span> error] || [<span class="keyword">self</span> mainRequest]) {
<a name="l01991"></a>01991                 <span class="keywordflow">return</span>;
<a name="l01992"></a>01992         }
<a name="l01993"></a>01993         <span class="keywordflow">if</span> ([<span class="keyword">self</span> isPACFileRequest]) {
<a name="l01994"></a>01994                 [<span class="keyword">self</span> reportFinished];
<a name="l01995"></a>01995         } <span class="keywordflow">else</span> {
<a name="l01996"></a>01996                 [<span class="keyword">self</span> performSelectorOnMainThread:@selector(reportFinished) withObject:nil waitUntilDone:[NSThread isMainThread]];
<a name="l01997"></a>01997         }
<a name="l01998"></a>01998 }
<a name="l01999"></a>01999 
<a name="l02000"></a>02000 <span class="comment">/* ALWAYS CALLED ON MAIN THREAD! */</span>
<a name="l02001"></a>02001 - (void)reportFinished
<a name="l02002"></a>02002 {
<a name="l02003"></a>02003         <span class="keywordflow">if</span> (delegate &amp;&amp; [delegate respondsToSelector:didFinishSelector]) {
<a name="l02004"></a>02004                 [delegate performSelector:didFinishSelector withObject:self];
<a name="l02005"></a>02005         }
<a name="l02006"></a>02006 
<a name="l02007"></a>02007 <span class="preprocessor">        #if NS_BLOCKS_AVAILABLE</span>
<a name="l02008"></a>02008 <span class="preprocessor"></span>        <span class="keywordflow">if</span>(completionBlock){
<a name="l02009"></a>02009                 completionBlock();
<a name="l02010"></a>02010         }
<a name="l02011"></a>02011 <span class="preprocessor">        #endif</span>
<a name="l02012"></a>02012 <span class="preprocessor"></span>
<a name="l02013"></a>02013         <span class="keywordflow">if</span> (queue &amp;&amp; [queue respondsToSelector:<span class="keyword">@selector</span>(requestFinished:)]) {
<a name="l02014"></a>02014                 [queue performSelector:@selector(requestFinished:) withObject:self];
<a name="l02015"></a>02015         }
<a name="l02016"></a>02016 }
<a name="l02017"></a>02017 
<a name="l02018"></a>02018 <span class="comment">/* ALWAYS CALLED ON MAIN THREAD! */</span>
<a name="l02019"></a>02019 - (void)reportFailure
<a name="l02020"></a>02020 {
<a name="l02021"></a>02021         <span class="keywordflow">if</span> (delegate &amp;&amp; [delegate respondsToSelector:didFailSelector]) {
<a name="l02022"></a>02022                 [delegate performSelector:didFailSelector withObject:self];
<a name="l02023"></a>02023         }
<a name="l02024"></a>02024 
<a name="l02025"></a>02025 <span class="preprocessor">        #if NS_BLOCKS_AVAILABLE</span>
<a name="l02026"></a>02026 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(failureBlock){
<a name="l02027"></a>02027         failureBlock();
<a name="l02028"></a>02028     }
<a name="l02029"></a>02029 <span class="preprocessor">        #endif</span>
<a name="l02030"></a>02030 <span class="preprocessor"></span>
<a name="l02031"></a>02031         <span class="keywordflow">if</span> (queue &amp;&amp; [queue respondsToSelector:<span class="keyword">@selector</span>(requestFailed:)]) {
<a name="l02032"></a>02032                 [queue performSelector:@selector(requestFailed:) withObject:self];
<a name="l02033"></a>02033         }
<a name="l02034"></a>02034 }
<a name="l02035"></a>02035 
<a name="l02036"></a>02036 <span class="comment">/* ALWAYS CALLED ON MAIN THREAD! */</span>
<a name="l02037"></a>02037 - (void)passOnReceivedData:(<a class="code" href="class_n_s_data.html" title="For hashing raw data.">NSData</a> *)data
<a name="l02038"></a>02038 {
<a name="l02039"></a>02039         <span class="keywordflow">if</span> (delegate &amp;&amp; [delegate respondsToSelector:didReceiveDataSelector]) {
<a name="l02040"></a>02040                 [delegate performSelector:didReceiveDataSelector withObject:self withObject:data];
<a name="l02041"></a>02041         }
<a name="l02042"></a>02042 
<a name="l02043"></a>02043 <span class="preprocessor">        #if NS_BLOCKS_AVAILABLE</span>
<a name="l02044"></a>02044 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (dataReceivedBlock) {
<a name="l02045"></a>02045                 dataReceivedBlock(data);
<a name="l02046"></a>02046         }
<a name="l02047"></a>02047 <span class="preprocessor">        #endif</span>
<a name="l02048"></a>02048 <span class="preprocessor"></span>}
<a name="l02049"></a>02049 
<a name="l02050"></a>02050 <span class="comment">// Subclasses might override this method to perform error handling in the same thread</span>
<a name="l02051"></a>02051 <span class="comment">// If you do this, don&#39;t forget to call [super failWithError:] to let the queue / delegate know we&#39;re done</span>
<a name="l02052"></a>02052 - (void)failWithError:(NSError *)theError
<a name="l02053"></a>02053 {
<a name="l02054"></a>02054 <span class="preprocessor">#if DEBUG_REQUEST_STATUS || DEBUG_THROTTLING</span>
<a name="l02055"></a>02055 <span class="preprocessor"></span>        NSLog(<span class="stringliteral">@&quot;[STATUS] Request %@: %@&quot;</span>,<span class="keyword">self</span>,(theError == ASIRequestCancelledError ? <span class="stringliteral">@&quot;Cancelled&quot;</span> : <span class="stringliteral">@&quot;Failed&quot;</span>));
<a name="l02056"></a>02056 <span class="preprocessor">#endif</span>
<a name="l02057"></a>02057 <span class="preprocessor"></span>        [<span class="keyword">self</span> setComplete:YES];
<a name="l02058"></a>02058         
<a name="l02059"></a>02059         <span class="comment">// Invalidate the current connection so subsequent requests don&#39;t attempt to reuse it</span>
<a name="l02060"></a>02060         <span class="keywordflow">if</span> (theError &amp;&amp; [theError code] != ASIAuthenticationErrorType &amp;&amp; [theError code] != ASITooMuchRedirectionErrorType) {
<a name="l02061"></a>02061                 [connectionsLock lock];
<a name="l02062"></a>02062 <span class="preprocessor">                #if DEBUG_PERSISTENT_CONNECTIONS</span>
<a name="l02063"></a>02063 <span class="preprocessor"></span>                NSLog(<span class="stringliteral">@&quot;[CONNECTION] Request #%@ failed and will invalidate connection #%@&quot;</span>,[<span class="keyword">self</span> requestID],[[<span class="keyword">self</span> connectionInfo] objectForKey:<span class="stringliteral">@&quot;id&quot;</span>]);
<a name="l02064"></a>02064 <span class="preprocessor">                #endif</span>
<a name="l02065"></a>02065 <span class="preprocessor"></span>                [[<span class="keyword">self</span> connectionInfo] removeObjectForKey:@&quot;request&quot;];
<a name="l02066"></a>02066                 [persistentConnectionsPool removeObject:[<span class="keyword">self</span> connectionInfo]];
<a name="l02067"></a>02067                 [connectionsLock unlock];
<a name="l02068"></a>02068                 [<span class="keyword">self</span> destroyReadStream];
<a name="l02069"></a>02069         }
<a name="l02070"></a>02070         <span class="keywordflow">if</span> ([<span class="keyword">self</span> connectionCanBeReused]) {
<a name="l02071"></a>02071                 [[<span class="keyword">self</span> connectionInfo] setObject:[NSDate dateWithTimeIntervalSinceNow:[<span class="keyword">self</span> persistentConnectionTimeoutSeconds]] forKey:@&quot;expires&quot;];
<a name="l02072"></a>02072         }
<a name="l02073"></a>02073         
<a name="l02074"></a>02074     <span class="keywordflow">if</span> ([<span class="keyword">self</span> isCancelled] || [<span class="keyword">self</span> error]) {
<a name="l02075"></a>02075                 <span class="keywordflow">return</span>;
<a name="l02076"></a>02076         }
<a name="l02077"></a>02077         
<a name="l02078"></a>02078         <span class="comment">// If we have cached data, use it and ignore the error when using ASIFallbackToCacheIfLoadFailsCachePolicy</span>
<a name="l02079"></a>02079         <span class="keywordflow">if</span> ([<span class="keyword">self</span> downloadCache] &amp;&amp; ([<span class="keyword">self</span> cachePolicy] &amp; ASIFallbackToCacheIfLoadFailsCachePolicy)) {
<a name="l02080"></a>02080                 <span class="keywordflow">if</span> ([[<span class="keyword">self</span> downloadCache] canUseCachedDataForRequest:<span class="keyword">self</span>]) {
<a name="l02081"></a>02081                         [<span class="keyword">self</span> useDataFromCache];
<a name="l02082"></a>02082                         <span class="keywordflow">return</span>;
<a name="l02083"></a>02083                 }
<a name="l02084"></a>02084         }
<a name="l02085"></a>02085         
<a name="l02086"></a>02086         
<a name="l02087"></a>02087         [<span class="keyword">self</span> setError:theError];
<a name="l02088"></a>02088         
<a name="l02089"></a>02089         ASIHTTPRequest *failedRequest = <span class="keyword">self</span>;
<a name="l02090"></a>02090         
<a name="l02091"></a>02091         <span class="comment">// If this is a HEAD request created by an ASINetworkQueue or compatible queue delegate, make the main request fail</span>
<a name="l02092"></a>02092         <span class="keywordflow">if</span> ([<span class="keyword">self</span> mainRequest]) {
<a name="l02093"></a>02093                 failedRequest = [<span class="keyword">self</span> mainRequest];
<a name="l02094"></a>02094                 [failedRequest setError:theError];
<a name="l02095"></a>02095         }
<a name="l02096"></a>02096 
<a name="l02097"></a>02097         <span class="keywordflow">if</span> ([<span class="keyword">self</span> isPACFileRequest]) {
<a name="l02098"></a>02098                 [failedRequest reportFailure];
<a name="l02099"></a>02099         } <span class="keywordflow">else</span> {
<a name="l02100"></a>02100                 [failedRequest performSelectorOnMainThread:@selector(reportFailure) withObject:nil waitUntilDone:[NSThread isMainThread]];
<a name="l02101"></a>02101         }
<a name="l02102"></a>02102         
<a name="l02103"></a>02103     <span class="keywordflow">if</span> (!inProgress)
<a name="l02104"></a>02104     {
<a name="l02105"></a>02105         <span class="comment">// if we&#39;re not in progress, we can&#39;t notify the queue we&#39;ve finished (doing so can cause a crash later on)</span>
<a name="l02106"></a>02106         <span class="comment">// &quot;markAsFinished&quot; will be at the start of main() when we are started</span>
<a name="l02107"></a>02107         <span class="keywordflow">return</span>;
<a name="l02108"></a>02108     }
<a name="l02109"></a>02109         [<span class="keyword">self</span> markAsFinished];
<a name="l02110"></a>02110 }
<a name="l02111"></a>02111 
<a name="l02112"></a>02112 <span class="preprocessor">#pragma mark parsing HTTP response headers</span>
<a name="l02113"></a>02113 <span class="preprocessor"></span>
<a name="l02114"></a>02114 - (void)readResponseHeaders
<a name="l02115"></a>02115 {
<a name="l02116"></a>02116         [<span class="keyword">self</span> setAuthenticationNeeded:ASINoAuthenticationNeededYet];
<a name="l02117"></a>02117 
<a name="l02118"></a>02118         CFHTTPMessageRef message = (CFHTTPMessageRef)CFReadStreamCopyProperty((CFReadStreamRef)[<span class="keyword">self</span> readStream], kCFStreamPropertyHTTPResponseHeader);
<a name="l02119"></a>02119         <span class="keywordflow">if</span> (!message) {
<a name="l02120"></a>02120                 <span class="keywordflow">return</span>;
<a name="l02121"></a>02121         }
<a name="l02122"></a>02122         
<a name="l02123"></a>02123         <span class="comment">// Make sure we&#39;ve received all the headers</span>
<a name="l02124"></a>02124         <span class="keywordflow">if</span> (!CFHTTPMessageIsHeaderComplete(message)) {
<a name="l02125"></a>02125                 CFRelease(message);
<a name="l02126"></a>02126                 <span class="keywordflow">return</span>;
<a name="l02127"></a>02127         }
<a name="l02128"></a>02128 
<a name="l02129"></a>02129 <span class="preprocessor">        #if DEBUG_REQUEST_STATUS</span>
<a name="l02130"></a>02130 <span class="preprocessor"></span>        <span class="keywordflow">if</span> ([<span class="keyword">self</span> totalBytesSent] == [<span class="keyword">self</span> postLength]) {
<a name="l02131"></a>02131                 NSLog(<span class="stringliteral">@&quot;[STATUS] Request %@ received response headers&quot;</span>,<span class="keyword">self</span>);
<a name="l02132"></a>02132         }
<a name="l02133"></a>02133 <span class="preprocessor">        #endif          </span>
<a name="l02134"></a>02134 <span class="preprocessor"></span>
<a name="l02135"></a>02135         [<span class="keyword">self</span> setResponseHeaders:[(NSDictionary *)CFHTTPMessageCopyAllHeaderFields(message) autorelease]];
<a name="l02136"></a>02136         [<span class="keyword">self</span> setResponseStatusCode:(int)CFHTTPMessageGetResponseStatusCode(message)];
<a name="l02137"></a>02137         [<span class="keyword">self</span> setResponseStatusMessage:[(<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">CFHTTPMessageCopyResponseStatusLine</a>(message) autorelease]];
<a name="l02138"></a>02138 
<a name="l02139"></a>02139         <span class="keywordflow">if</span> ([<span class="keyword">self</span> downloadCache] &amp;&amp; ([[<span class="keyword">self</span> downloadCache] canUseCachedDataForRequest:<span class="keyword">self</span>])) {
<a name="l02140"></a>02140 
<a name="l02141"></a>02141                 <span class="comment">// Update the expiry date</span>
<a name="l02142"></a>02142                 [[<span class="keyword">self</span> downloadCache] updateExpiryForRequest:self maxAge:[<span class="keyword">self</span> secondsToCache]];
<a name="l02143"></a>02143 
<a name="l02144"></a>02144                 <span class="comment">// Read the response from the cache</span>
<a name="l02145"></a>02145                 [<span class="keyword">self</span> useDataFromCache];
<a name="l02146"></a>02146 
<a name="l02147"></a>02147                 CFRelease(message);
<a name="l02148"></a>02148                 <span class="keywordflow">return</span>;
<a name="l02149"></a>02149         }
<a name="l02150"></a>02150 
<a name="l02151"></a>02151         <span class="comment">// Is the server response a challenge for credentials?</span>
<a name="l02152"></a>02152         <span class="keywordflow">if</span> ([<span class="keyword">self</span> responseStatusCode] == 401) {
<a name="l02153"></a>02153                 [<span class="keyword">self</span> setAuthenticationNeeded:ASIHTTPAuthenticationNeeded];
<a name="l02154"></a>02154         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ([<span class="keyword">self</span> responseStatusCode] == 407) {
<a name="l02155"></a>02155                 [<span class="keyword">self</span> setAuthenticationNeeded:ASIProxyAuthenticationNeeded];
<a name="l02156"></a>02156         } <span class="keywordflow">else</span> {
<a name="l02157"></a>02157 <span class="preprocessor">                #if DEBUG_HTTP_AUTHENTICATION</span>
<a name="l02158"></a>02158 <span class="preprocessor"></span>                <span class="keywordflow">if</span> ([<span class="keyword">self</span> authenticationScheme]) {
<a name="l02159"></a>02159                         NSLog(<span class="stringliteral">@&quot;[AUTH] Request %@ has passed %@ authentication&quot;</span>,<span class="keyword">self</span>,[<span class="keyword">self</span> authenticationScheme]);
<a name="l02160"></a>02160                 }
<a name="l02161"></a>02161 <span class="preprocessor">                #endif</span>
<a name="l02162"></a>02162 <span class="preprocessor"></span>        }
<a name="l02163"></a>02163                 
<a name="l02164"></a>02164         <span class="comment">// Authentication succeeded, or no authentication was required</span>
<a name="l02165"></a>02165         <span class="keywordflow">if</span> (![<span class="keyword">self</span> authenticationNeeded]) {
<a name="l02166"></a>02166 
<a name="l02167"></a>02167                 <span class="comment">// Did we get here without an authentication challenge? (which can happen when shouldPresentCredentialsBeforeChallenge is YES and basic auth was successful)</span>
<a name="l02168"></a>02168                 <span class="keywordflow">if</span> (!requestAuthentication &amp;&amp; [[<span class="keyword">self</span> authenticationScheme] isEqualToString:(<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)kCFHTTPAuthenticationSchemeBasic] &amp;&amp; [<span class="keyword">self</span> username] &amp;&amp; [<span class="keyword">self</span> password] &amp;&amp; [<span class="keyword">self</span> useSessionPersistence]) {
<a name="l02169"></a>02169 
<a name="l02170"></a>02170 <span class="preprocessor">                        #if DEBUG_HTTP_AUTHENTICATION</span>
<a name="l02171"></a>02171 <span class="preprocessor"></span>                        NSLog(<span class="stringliteral">@&quot;[AUTH] Request %@ passed BASIC authentication, and will save credentials in the session store for future use&quot;</span>,<span class="keyword">self</span>);
<a name="l02172"></a>02172 <span class="preprocessor">                        #endif</span>
<a name="l02173"></a>02173 <span class="preprocessor"></span>                        
<a name="l02174"></a>02174                         NSMutableDictionary *newCredentials = [NSMutableDictionary dictionaryWithCapacity:2];
<a name="l02175"></a>02175                         [newCredentials setObject:[<span class="keyword">self</span> username] forKey:(NSString *)kCFHTTPAuthenticationUsername];
<a name="l02176"></a>02176                         [newCredentials setObject:[<span class="keyword">self</span> password] forKey:(NSString *)kCFHTTPAuthenticationPassword];
<a name="l02177"></a>02177                         
<a name="l02178"></a>02178                         <span class="comment">// Store the credentials in the session </span>
<a name="l02179"></a>02179                         NSMutableDictionary *sessionCredentials = [NSMutableDictionary dictionary];
<a name="l02180"></a>02180                         [sessionCredentials setObject:newCredentials forKey:@&quot;Credentials&quot;];
<a name="l02181"></a>02181                         [sessionCredentials setObject:[<span class="keyword">self</span> url] forKey:@&quot;URL&quot;];
<a name="l02182"></a>02182                         [sessionCredentials setObject:(NSString *)kCFHTTPAuthenticationSchemeBasic forKey:@&quot;AuthenticationScheme&quot;];
<a name="l02183"></a>02183                         [[<span class="keyword">self</span> class] storeAuthenticationCredentialsInSessionStore:sessionCredentials];
<a name="l02184"></a>02184                 }
<a name="l02185"></a>02185         }
<a name="l02186"></a>02186 
<a name="l02187"></a>02187         <span class="comment">// Read response textEncoding</span>
<a name="l02188"></a>02188         [<span class="keyword">self</span> parseStringEncodingFromHeaders];
<a name="l02189"></a>02189 
<a name="l02190"></a>02190         <span class="comment">// Handle cookies</span>
<a name="l02191"></a>02191         NSArray *newCookies = [NSHTTPCookie cookiesWithResponseHeaderFields:[<span class="keyword">self</span> responseHeaders] forURL:[<span class="keyword">self</span> url]];
<a name="l02192"></a>02192         [<span class="keyword">self</span> setResponseCookies:newCookies];
<a name="l02193"></a>02193         
<a name="l02194"></a>02194         <span class="keywordflow">if</span> ([<span class="keyword">self</span> useCookiePersistence]) {
<a name="l02195"></a>02195                 
<a name="l02196"></a>02196                 <span class="comment">// Store cookies in global persistent store</span>
<a name="l02197"></a>02197                 [[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookies:newCookies forURL:[<span class="keyword">self</span> url] mainDocumentURL:nil];
<a name="l02198"></a>02198                 
<a name="l02199"></a>02199                 <span class="comment">// We also keep any cookies in the sessionCookies array, so that we have a reference to them if we need to remove them later</span>
<a name="l02200"></a>02200                 NSHTTPCookie *cookie;
<a name="l02201"></a>02201                 <span class="keywordflow">for</span> (cookie in newCookies) {
<a name="l02202"></a>02202                         [ASIHTTPRequest addSessionCookie:cookie];
<a name="l02203"></a>02203                 }
<a name="l02204"></a>02204         }
<a name="l02205"></a>02205         
<a name="l02206"></a>02206         <span class="comment">// Do we need to redirect?</span>
<a name="l02207"></a>02207         <span class="keywordflow">if</span> (![<span class="keyword">self</span> willRedirect]) {
<a name="l02208"></a>02208                 <span class="comment">// See if we got a Content-length header</span>
<a name="l02209"></a>02209                 <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *cLength = [responseHeaders valueForKey:@&quot;Content-Length&quot;];
<a name="l02210"></a>02210                 ASIHTTPRequest *theRequest = <span class="keyword">self</span>;
<a name="l02211"></a>02211                 <span class="keywordflow">if</span> ([<span class="keyword">self</span> mainRequest]) {
<a name="l02212"></a>02212                         theRequest = [<span class="keyword">self</span> mainRequest];
<a name="l02213"></a>02213                 }
<a name="l02214"></a>02214 
<a name="l02215"></a>02215                 <span class="keywordflow">if</span> (cLength) {
<a name="l02216"></a>02216                         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> length = strtoull([cLength UTF8String], NULL, 0);
<a name="l02217"></a>02217 
<a name="l02218"></a>02218                         <span class="comment">// Workaround for Apache HEAD requests for dynamically generated content returning the wrong Content-Length when using gzip</span>
<a name="l02219"></a>02219                         <span class="keywordflow">if</span> ([<span class="keyword">self</span> mainRequest] &amp;&amp; [<span class="keyword">self</span> allowCompressedResponse] &amp;&amp; length == 20 &amp;&amp; [<span class="keyword">self</span> showAccurateProgress] &amp;&amp; [<span class="keyword">self</span> shouldResetDownloadProgress]) {
<a name="l02220"></a>02220                                 [[<span class="keyword">self</span> mainRequest] setShowAccurateProgress:NO];
<a name="l02221"></a>02221                                 [[<span class="keyword">self</span> mainRequest] incrementDownloadSizeBy:1];
<a name="l02222"></a>02222 
<a name="l02223"></a>02223                         } <span class="keywordflow">else</span> {
<a name="l02224"></a>02224                                 [theRequest setContentLength:length];
<a name="l02225"></a>02225                                 <span class="keywordflow">if</span> ([<span class="keyword">self</span> showAccurateProgress] &amp;&amp; [<span class="keyword">self</span> shouldResetDownloadProgress]) {
<a name="l02226"></a>02226                                         [theRequest incrementDownloadSizeBy:[theRequest contentLength]+[theRequest partialDownloadSize]];
<a name="l02227"></a>02227                                 }
<a name="l02228"></a>02228                         }
<a name="l02229"></a>02229 
<a name="l02230"></a>02230                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ([<span class="keyword">self</span> showAccurateProgress] &amp;&amp; [<span class="keyword">self</span> shouldResetDownloadProgress]) {
<a name="l02231"></a>02231                         [theRequest setShowAccurateProgress:NO];
<a name="l02232"></a>02232                         [theRequest incrementDownloadSizeBy:1];
<a name="l02233"></a>02233                 }
<a name="l02234"></a>02234         }
<a name="l02235"></a>02235 
<a name="l02236"></a>02236         <span class="comment">// Handle connection persistence</span>
<a name="l02237"></a>02237         <span class="keywordflow">if</span> ([<span class="keyword">self</span> shouldAttemptPersistentConnection]) {
<a name="l02238"></a>02238                 
<a name="l02239"></a>02239                 <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *connectionHeader = [[[<span class="keyword">self</span> responseHeaders] objectForKey:@&quot;Connection&quot;] lowercaseString];
<a name="l02240"></a>02240 
<a name="l02241"></a>02241                 <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *httpVersion = NSMakeCollectable([(<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)CFHTTPMessageCopyVersion(message) autorelease]);
<a name="l02242"></a>02242                 
<a name="l02243"></a>02243                 <span class="comment">// Don&#39;t re-use the connection if the server is HTTP 1.0 and didn&#39;t send Connection: Keep-Alive</span>
<a name="l02244"></a>02244                 <span class="keywordflow">if</span> (![httpVersion isEqualToString:(<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)kCFHTTPVersion1_0] || [connectionHeader isEqualToString:<span class="stringliteral">@&quot;keep-alive&quot;</span>]) {
<a name="l02245"></a>02245 
<a name="l02246"></a>02246                         <span class="comment">// See if server explicitly told us to close the connection</span>
<a name="l02247"></a>02247                         <span class="keywordflow">if</span> (![connectionHeader isEqualToString:<span class="stringliteral">@&quot;close&quot;</span>]) {
<a name="l02248"></a>02248                                 
<a name="l02249"></a>02249                                 <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *keepAliveHeader = [[<span class="keyword">self</span> responseHeaders] objectForKey:@&quot;Keep-Alive&quot;];
<a name="l02250"></a>02250                                 
<a name="l02251"></a>02251                                 <span class="comment">// If we got a keep alive header, we&#39;ll reuse the connection for as long as the server tells us</span>
<a name="l02252"></a>02252                                 <span class="keywordflow">if</span> (keepAliveHeader) { 
<a name="l02253"></a>02253                                         <span class="keywordtype">int</span> timeout = 0;
<a name="l02254"></a>02254                                         <span class="keywordtype">int</span> max = 0;
<a name="l02255"></a>02255                                         NSScanner *scanner = [NSScanner scannerWithString:keepAliveHeader];
<a name="l02256"></a>02256                                         [scanner scanString:@&quot;timeout=&quot; intoString:NULL];
<a name="l02257"></a>02257                                         [scanner scanInt:&amp;timeout];
<a name="l02258"></a>02258                                         [scanner scanUpToString:@&quot;max=&quot; intoString:NULL];
<a name="l02259"></a>02259                                         [scanner scanString:@&quot;max=&quot; intoString:NULL];
<a name="l02260"></a>02260                                         [scanner scanInt:&amp;max];
<a name="l02261"></a>02261                                         <span class="keywordflow">if</span> (max &gt; 5) {
<a name="l02262"></a>02262                                                 [<span class="keyword">self</span> setConnectionCanBeReused:YES];
<a name="l02263"></a>02263                                                 [<span class="keyword">self</span> setPersistentConnectionTimeoutSeconds:timeout];
<a name="l02264"></a>02264 <span class="preprocessor">                                                #if DEBUG_PERSISTENT_CONNECTIONS</span>
<a name="l02265"></a>02265 <span class="preprocessor"></span>                                                        NSLog(<span class="stringliteral">@&quot;[CONNECTION] Got a keep-alive header, will keep this connection open for %f seconds&quot;</span>, [<span class="keyword">self</span> persistentConnectionTimeoutSeconds]);
<a name="l02266"></a>02266 <span class="preprocessor">                                                #endif                                  </span>
<a name="l02267"></a>02267 <span class="preprocessor"></span>                                        }
<a name="l02268"></a>02268                                 
<a name="l02269"></a>02269                                 <span class="comment">// Otherwise, we&#39;ll assume we can keep this connection open</span>
<a name="l02270"></a>02270                                 } <span class="keywordflow">else</span> {
<a name="l02271"></a>02271                                         [<span class="keyword">self</span> setConnectionCanBeReused:YES];
<a name="l02272"></a>02272 <span class="preprocessor">                                        #if DEBUG_PERSISTENT_CONNECTIONS</span>
<a name="l02273"></a>02273 <span class="preprocessor"></span>                                                NSLog(<span class="stringliteral">@&quot;[CONNECTION] Got no keep-alive header, will keep this connection open for %f seconds&quot;</span>, [<span class="keyword">self</span> persistentConnectionTimeoutSeconds]);
<a name="l02274"></a>02274 <span class="preprocessor">                                        #endif</span>
<a name="l02275"></a>02275 <span class="preprocessor"></span>                                }
<a name="l02276"></a>02276                         }
<a name="l02277"></a>02277                 }
<a name="l02278"></a>02278         }
<a name="l02279"></a>02279 
<a name="l02280"></a>02280         CFRelease(message);
<a name="l02281"></a>02281         [<span class="keyword">self</span> performSelectorOnMainThread:@selector(requestReceivedResponseHeaders:) withObject:[[[<span class="keyword">self</span> responseHeaders] copy] autorelease] waitUntilDone:[NSThread isMainThread]];
<a name="l02282"></a>02282 }
<a name="l02283"></a>02283 
<a name="l02284"></a>02284 - (BOOL)willRedirect
<a name="l02285"></a>02285 {
<a name="l02286"></a>02286         <span class="comment">// Do we need to redirect?</span>
<a name="l02287"></a>02287         <span class="keywordflow">if</span> (![<span class="keyword">self</span> shouldRedirect] || ![responseHeaders valueForKey:<span class="stringliteral">@&quot;Location&quot;</span>]) {
<a name="l02288"></a>02288                 <span class="keywordflow">return</span> NO;
<a name="l02289"></a>02289         }
<a name="l02290"></a>02290 
<a name="l02291"></a>02291         <span class="comment">// Note that ASIHTTPRequest does not currently support 305 Use Proxy</span>
<a name="l02292"></a>02292         <span class="keywordtype">int</span> responseCode = [<span class="keyword">self</span> responseStatusCode];
<a name="l02293"></a>02293         <span class="keywordflow">if</span> (responseCode != 301 &amp;&amp; responseCode != 302 &amp;&amp; responseCode != 303 &amp;&amp; responseCode != 307) {
<a name="l02294"></a>02294                 <span class="keywordflow">return</span> NO;
<a name="l02295"></a>02295         }
<a name="l02296"></a>02296 
<a name="l02297"></a>02297         [<span class="keyword">self</span> performSelectorOnMainThread:@selector(requestRedirected) withObject:nil waitUntilDone:[NSThread isMainThread]];
<a name="l02298"></a>02298 
<a name="l02299"></a>02299         <span class="comment">// By default, we redirect 301 and 302 response codes as GET requests</span>
<a name="l02300"></a>02300         <span class="comment">// According to RFC 2616 this is wrong, but this is what most browsers do, so it&#39;s probably what you&#39;re expecting to happen</span>
<a name="l02301"></a>02301         <span class="comment">// See also:</span>
<a name="l02302"></a>02302         <span class="comment">// http://allseeing-i.lighthouseapp.com/projects/27881/tickets/27-302-redirection-issue</span>
<a name="l02303"></a>02303 
<a name="l02304"></a>02304         <span class="keywordflow">if</span> (responseCode != 307 &amp;&amp; (![<span class="keyword">self</span> shouldUseRFC2616RedirectBehaviour] || responseCode == 303)) {
<a name="l02305"></a>02305                 [<span class="keyword">self</span> setRequestMethod:@&quot;GET&quot;];
<a name="l02306"></a>02306                 [<span class="keyword">self</span> setPostBody:nil];
<a name="l02307"></a>02307                 [<span class="keyword">self</span> setPostLength:0];
<a name="l02308"></a>02308 
<a name="l02309"></a>02309                 <span class="comment">// Perhaps there are other headers we should be preserving, but it&#39;s hard to know what we need to keep and what to throw away.</span>
<a name="l02310"></a>02310                 <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *userAgentHeader = [[<span class="keyword">self</span> requestHeaders] objectForKey:@&quot;User-Agent&quot;];
<a name="l02311"></a>02311                 <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *acceptHeader = [[<span class="keyword">self</span> requestHeaders] objectForKey:@&quot;Accept&quot;];
<a name="l02312"></a>02312                 [<span class="keyword">self</span> setRequestHeaders:nil];
<a name="l02313"></a>02313                 <span class="keywordflow">if</span> (userAgentHeader) {
<a name="l02314"></a>02314                         [<span class="keyword">self</span> addRequestHeader:@&quot;User-Agent&quot; value:userAgentHeader];
<a name="l02315"></a>02315                 }
<a name="l02316"></a>02316                 <span class="keywordflow">if</span> (acceptHeader) {
<a name="l02317"></a>02317                         [<span class="keyword">self</span> addRequestHeader:@&quot;Accept&quot; value:acceptHeader];
<a name="l02318"></a>02318                 }
<a name="l02319"></a>02319                 [<span class="keyword">self</span> setHaveBuiltRequestHeaders:NO];
<a name="l02320"></a>02320 
<a name="l02321"></a>02321         } <span class="keywordflow">else</span> {
<a name="l02322"></a>02322                 <span class="comment">// Force rebuild the cookie header incase we got some new cookies from this request</span>
<a name="l02323"></a>02323                 <span class="comment">// All other request headers will remain as they are for 301 / 302 redirects</span>
<a name="l02324"></a>02324                 [<span class="keyword">self</span> applyCookieHeader];
<a name="l02325"></a>02325         }
<a name="l02326"></a>02326 
<a name="l02327"></a>02327         <span class="comment">// Force the redirected request to rebuild the request headers (if not a 303, it will re-use old ones, and add any new ones)</span>
<a name="l02328"></a>02328         [<span class="keyword">self</span> setRedirectURL:[[NSURL URLWithString:[responseHeaders valueForKey:@&quot;Location&quot;] relativeToURL:[<span class="keyword">self</span> url]] absoluteURL]];
<a name="l02329"></a>02329         [<span class="keyword">self</span> setNeedsRedirect:YES];
<a name="l02330"></a>02330 
<a name="l02331"></a>02331         <span class="comment">// Clear the request cookies</span>
<a name="l02332"></a>02332         <span class="comment">// This means manually added cookies will not be added to the redirect request - only those stored in the global persistent store</span>
<a name="l02333"></a>02333         <span class="comment">// But, this is probably the safest option - we might be redirecting to a different domain</span>
<a name="l02334"></a>02334         [<span class="keyword">self</span> setRequestCookies:[NSMutableArray array]];
<a name="l02335"></a>02335 
<a name="l02336"></a>02336 <span class="preprocessor">        #if DEBUG_REQUEST_STATUS</span>
<a name="l02337"></a>02337 <span class="preprocessor"></span>        NSLog(<span class="stringliteral">@&quot;[STATUS] Request will redirect (code: %i): %@&quot;</span>,responseCode,<span class="keyword">self</span>);
<a name="l02338"></a>02338 <span class="preprocessor">        #endif</span>
<a name="l02339"></a>02339 <span class="preprocessor"></span>
<a name="l02340"></a>02340         <span class="keywordflow">return</span> YES;
<a name="l02341"></a>02341 }
<a name="l02342"></a>02342 
<a name="l02343"></a>02343 - (void)parseStringEncodingFromHeaders
<a name="l02344"></a>02344 {
<a name="l02345"></a>02345         <span class="comment">// Handle response text encoding</span>
<a name="l02346"></a>02346         NSStringEncoding charset = 0;
<a name="l02347"></a>02347         <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *mimeType = nil;
<a name="l02348"></a>02348         [[<span class="keyword">self</span> class] parseMimeType:&amp;mimeType andResponseEncoding:&amp;charset fromContentType:[[<span class="keyword">self</span> responseHeaders] valueForKey:@&quot;Content-Type&quot;]];
<a name="l02349"></a>02349         <span class="keywordflow">if</span> (charset != 0) {
<a name="l02350"></a>02350                 [<span class="keyword">self</span> setResponseEncoding:charset];
<a name="l02351"></a>02351         } <span class="keywordflow">else</span> {
<a name="l02352"></a>02352                 [<span class="keyword">self</span> setResponseEncoding:[<span class="keyword">self</span> defaultResponseEncoding]];
<a name="l02353"></a>02353         }
<a name="l02354"></a>02354 }
<a name="l02355"></a>02355 
<a name="l02356"></a>02356 <span class="preprocessor">#pragma mark http authentication</span>
<a name="l02357"></a>02357 <span class="preprocessor"></span>
<a name="l02358"></a>02358 - (void)saveProxyCredentialsToKeychain:(NSDictionary *)newCredentials
<a name="l02359"></a>02359 {
<a name="l02360"></a>02360         NSURLCredential *authenticationCredentials = [NSURLCredential credentialWithUser:[newCredentials objectForKey:(NSString *)kCFHTTPAuthenticationUsername] password:[newCredentials objectForKey:(NSString *)kCFHTTPAuthenticationPassword] persistence:NSURLCredentialPersistencePermanent];
<a name="l02361"></a>02361         <span class="keywordflow">if</span> (authenticationCredentials) {
<a name="l02362"></a>02362                 [ASIHTTPRequest saveCredentials:authenticationCredentials forProxy:[<span class="keyword">self</span> proxyHost] port:[<span class="keyword">self</span> proxyPort] realm:[<span class="keyword">self</span> proxyAuthenticationRealm]];
<a name="l02363"></a>02363         }       
<a name="l02364"></a>02364 }
<a name="l02365"></a>02365 
<a name="l02366"></a>02366 
<a name="l02367"></a>02367 - (void)saveCredentialsToKeychain:(NSDictionary *)newCredentials
<a name="l02368"></a>02368 {
<a name="l02369"></a>02369         NSURLCredential *authenticationCredentials = [NSURLCredential credentialWithUser:[newCredentials objectForKey:(NSString *)kCFHTTPAuthenticationUsername] password:[newCredentials objectForKey:(NSString *)kCFHTTPAuthenticationPassword] persistence:NSURLCredentialPersistencePermanent];
<a name="l02370"></a>02370         
<a name="l02371"></a>02371         <span class="keywordflow">if</span> (authenticationCredentials) {
<a name="l02372"></a>02372                 [ASIHTTPRequest saveCredentials:authenticationCredentials forHost:[[<span class="keyword">self</span> url] host] port:[[[<span class="keyword">self</span> url] port] intValue] protocol:[[<span class="keyword">self</span> url] scheme] realm:[<span class="keyword">self</span> authenticationRealm]];
<a name="l02373"></a>02373         }       
<a name="l02374"></a>02374 }
<a name="l02375"></a>02375 
<a name="l02376"></a>02376 - (BOOL)applyProxyCredentials:(NSDictionary *)newCredentials
<a name="l02377"></a>02377 {
<a name="l02378"></a>02378         [<span class="keyword">self</span> setProxyAuthenticationRetryCount:[<span class="keyword">self</span> proxyAuthenticationRetryCount]+1];
<a name="l02379"></a>02379         
<a name="l02380"></a>02380         <span class="keywordflow">if</span> (newCredentials &amp;&amp; proxyAuthentication &amp;&amp; request) {
<a name="l02381"></a>02381 
<a name="l02382"></a>02382                 <span class="comment">// Apply whatever credentials we&#39;ve built up to the old request</span>
<a name="l02383"></a>02383                 <span class="keywordflow">if</span> (CFHTTPMessageApplyCredentialDictionary(request, proxyAuthentication, (CFMutableDictionaryRef)newCredentials, NULL)) {
<a name="l02384"></a>02384                         
<a name="l02385"></a>02385                         <span class="comment">//If we have credentials and they&#39;re ok, let&#39;s save them to the keychain</span>
<a name="l02386"></a>02386                         <span class="keywordflow">if</span> (useKeychainPersistence) {
<a name="l02387"></a>02387                                 [<span class="keyword">self</span> saveProxyCredentialsToKeychain:newCredentials];
<a name="l02388"></a>02388                         }
<a name="l02389"></a>02389                         <span class="keywordflow">if</span> (useSessionPersistence) {
<a name="l02390"></a>02390                                 NSMutableDictionary *sessionProxyCredentials = [NSMutableDictionary dictionary];
<a name="l02391"></a>02391                                 [sessionProxyCredentials setObject:(id)proxyAuthentication forKey:@&quot;Authentication&quot;];
<a name="l02392"></a>02392                                 [sessionProxyCredentials setObject:newCredentials forKey:@&quot;Credentials&quot;];
<a name="l02393"></a>02393                                 [sessionProxyCredentials setObject:[<span class="keyword">self</span> proxyHost] forKey:@&quot;Host&quot;];
<a name="l02394"></a>02394                                 [sessionProxyCredentials setObject:[NSNumber numberWithInt:[<span class="keyword">self</span> proxyPort]] forKey:@&quot;Port&quot;];
<a name="l02395"></a>02395                                 [sessionProxyCredentials setObject:[<span class="keyword">self</span> proxyAuthenticationScheme] forKey:@&quot;AuthenticationScheme&quot;];
<a name="l02396"></a>02396                                 [[<span class="keyword">self</span> class] storeProxyAuthenticationCredentialsInSessionStore:sessionProxyCredentials];
<a name="l02397"></a>02397                         }
<a name="l02398"></a>02398                         [<span class="keyword">self</span> setProxyCredentials:newCredentials];
<a name="l02399"></a>02399                         <span class="keywordflow">return</span> YES;
<a name="l02400"></a>02400                 } <span class="keywordflow">else</span> {
<a name="l02401"></a>02401                         [[<span class="keyword">self</span> class] removeProxyAuthenticationCredentialsFromSessionStore:newCredentials];
<a name="l02402"></a>02402                 }
<a name="l02403"></a>02403         }
<a name="l02404"></a>02404         <span class="keywordflow">return</span> NO;
<a name="l02405"></a>02405 }
<a name="l02406"></a>02406 
<a name="l02407"></a>02407 - (BOOL)applyCredentials:(NSDictionary *)newCredentials
<a name="l02408"></a>02408 {
<a name="l02409"></a>02409         [<span class="keyword">self</span> setAuthenticationRetryCount:[<span class="keyword">self</span> authenticationRetryCount]+1];
<a name="l02410"></a>02410         
<a name="l02411"></a>02411         <span class="keywordflow">if</span> (newCredentials &amp;&amp; requestAuthentication &amp;&amp; request) {
<a name="l02412"></a>02412                 <span class="comment">// Apply whatever credentials we&#39;ve built up to the old request</span>
<a name="l02413"></a>02413                 <span class="keywordflow">if</span> (CFHTTPMessageApplyCredentialDictionary(request, requestAuthentication, (CFMutableDictionaryRef)newCredentials, NULL)) {
<a name="l02414"></a>02414                         
<a name="l02415"></a>02415                         <span class="comment">//If we have credentials and they&#39;re ok, let&#39;s save them to the keychain</span>
<a name="l02416"></a>02416                         <span class="keywordflow">if</span> (useKeychainPersistence) {
<a name="l02417"></a>02417                                 [<span class="keyword">self</span> saveCredentialsToKeychain:newCredentials];
<a name="l02418"></a>02418                         }
<a name="l02419"></a>02419                         <span class="keywordflow">if</span> (useSessionPersistence) {
<a name="l02420"></a>02420                                 
<a name="l02421"></a>02421                                 NSMutableDictionary *sessionCredentials = [NSMutableDictionary dictionary];
<a name="l02422"></a>02422                                 [sessionCredentials setObject:(id)requestAuthentication forKey:@&quot;Authentication&quot;];
<a name="l02423"></a>02423                                 [sessionCredentials setObject:newCredentials forKey:@&quot;Credentials&quot;];
<a name="l02424"></a>02424                                 [sessionCredentials setObject:[<span class="keyword">self</span> url] forKey:@&quot;URL&quot;];
<a name="l02425"></a>02425                                 [sessionCredentials setObject:[<span class="keyword">self</span> authenticationScheme] forKey:@&quot;AuthenticationScheme&quot;];
<a name="l02426"></a>02426                                 <span class="keywordflow">if</span> ([<span class="keyword">self</span> authenticationRealm]) {
<a name="l02427"></a>02427                                         [sessionCredentials setObject:[<span class="keyword">self</span> authenticationRealm] forKey:@&quot;AuthenticationRealm&quot;];
<a name="l02428"></a>02428                                 }
<a name="l02429"></a>02429                                 [[<span class="keyword">self</span> class] storeAuthenticationCredentialsInSessionStore:sessionCredentials];
<a name="l02430"></a>02430 
<a name="l02431"></a>02431                         }
<a name="l02432"></a>02432                         [<span class="keyword">self</span> setRequestCredentials:newCredentials];
<a name="l02433"></a>02433                         <span class="keywordflow">return</span> YES;
<a name="l02434"></a>02434                 } <span class="keywordflow">else</span> {
<a name="l02435"></a>02435                         [[<span class="keyword">self</span> class] removeAuthenticationCredentialsFromSessionStore:newCredentials];
<a name="l02436"></a>02436                 }
<a name="l02437"></a>02437         }
<a name="l02438"></a>02438         <span class="keywordflow">return</span> NO;
<a name="l02439"></a>02439 }
<a name="l02440"></a>02440 
<a name="l02441"></a>02441 - (NSMutableDictionary *)findProxyCredentials
<a name="l02442"></a>02442 {
<a name="l02443"></a>02443         NSMutableDictionary *newCredentials = [[[NSMutableDictionary alloc] init] autorelease];
<a name="l02444"></a>02444         
<a name="l02445"></a>02445         <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *user = nil;
<a name="l02446"></a>02446         <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *pass = nil;
<a name="l02447"></a>02447         
<a name="l02448"></a>02448         ASIHTTPRequest *theRequest = [<span class="keyword">self</span> mainRequest];
<a name="l02449"></a>02449         <span class="comment">// If this is a HEAD request generated by an ASINetworkQueue, we&#39;ll try to use the details from the main request</span>
<a name="l02450"></a>02450         <span class="keywordflow">if</span> ([theRequest proxyUsername] &amp;&amp; [theRequest proxyPassword]) {
<a name="l02451"></a>02451                 user = [theRequest proxyUsername];
<a name="l02452"></a>02452                 pass = [theRequest proxyPassword];
<a name="l02453"></a>02453                 
<a name="l02454"></a>02454         <span class="comment">// Let&#39;s try to use the ones set in this object</span>
<a name="l02455"></a>02455         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ([<span class="keyword">self</span> proxyUsername] &amp;&amp; [<span class="keyword">self</span> proxyPassword]) {
<a name="l02456"></a>02456                 user = [<span class="keyword">self</span> proxyUsername];
<a name="l02457"></a>02457                 pass = [<span class="keyword">self</span> proxyPassword];
<a name="l02458"></a>02458         }
<a name="l02459"></a>02459 
<a name="l02460"></a>02460         <span class="comment">// When we connect to a website using NTLM via a proxy, we will use the main credentials</span>
<a name="l02461"></a>02461         <span class="keywordflow">if</span> ((!user || !pass) &amp;&amp; [<span class="keyword">self</span> proxyAuthenticationScheme] == (<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)kCFHTTPAuthenticationSchemeNTLM) {
<a name="l02462"></a>02462                 user = [<span class="keyword">self</span> username];
<a name="l02463"></a>02463                 pass = [<span class="keyword">self</span> password];
<a name="l02464"></a>02464         }
<a name="l02465"></a>02465 
<a name="l02466"></a>02466 
<a name="l02467"></a>02467         
<a name="l02468"></a>02468         <span class="comment">// Ok, that didn&#39;t work, let&#39;s try the keychain</span>
<a name="l02469"></a>02469         <span class="comment">// For authenticating proxies, we&#39;ll look in the keychain regardless of the value of useKeychainPersistence</span>
<a name="l02470"></a>02470         <span class="keywordflow">if</span> ((!user || !pass)) {
<a name="l02471"></a>02471                 NSURLCredential *authenticationCredentials = [ASIHTTPRequest savedCredentialsForProxy:[<span class="keyword">self</span> proxyHost] port:[<span class="keyword">self</span> proxyPort] protocol:[[<span class="keyword">self</span> url] scheme] realm:[<span class="keyword">self</span> proxyAuthenticationRealm]];
<a name="l02472"></a>02472                 <span class="keywordflow">if</span> (authenticationCredentials) {
<a name="l02473"></a>02473                         user = [authenticationCredentials user];
<a name="l02474"></a>02474                         pass = [authenticationCredentials password];
<a name="l02475"></a>02475                 }
<a name="l02476"></a>02476                 
<a name="l02477"></a>02477         }
<a name="l02478"></a>02478 
<a name="l02479"></a>02479         <span class="comment">// Handle NTLM, which requires a domain to be set too</span>
<a name="l02480"></a>02480         <span class="keywordflow">if</span> (CFHTTPAuthenticationRequiresAccountDomain(proxyAuthentication)) {
<a name="l02481"></a>02481 
<a name="l02482"></a>02482                 <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *ntlmDomain = [<span class="keyword">self</span> proxyDomain];
<a name="l02483"></a>02483 
<a name="l02484"></a>02484                 <span class="comment">// If we have no domain yet</span>
<a name="l02485"></a>02485                 <span class="keywordflow">if</span> (!ntlmDomain || [ntlmDomain length] == 0) {
<a name="l02486"></a>02486 
<a name="l02487"></a>02487                         <span class="comment">// Let&#39;s try to extract it from the username</span>
<a name="l02488"></a>02488                         NSArray* ntlmComponents = [user componentsSeparatedByString:@&quot;\\&quot;];
<a name="l02489"></a>02489                         <span class="keywordflow">if</span> ([ntlmComponents count] == 2) {
<a name="l02490"></a>02490                                 ntlmDomain = [ntlmComponents objectAtIndex:0];
<a name="l02491"></a>02491                                 user = [ntlmComponents objectAtIndex:1];
<a name="l02492"></a>02492 
<a name="l02493"></a>02493                         <span class="comment">// If we are connecting to a website using NTLM, but we are connecting via a proxy, the string we need may be in the domain property</span>
<a name="l02494"></a>02494                         } <span class="keywordflow">else</span> {
<a name="l02495"></a>02495                                 ntlmDomain = [<span class="keyword">self</span> domain];
<a name="l02496"></a>02496                         }
<a name="l02497"></a>02497                         <span class="keywordflow">if</span> (!ntlmDomain) {
<a name="l02498"></a>02498                                 ntlmDomain = <span class="stringliteral">@&quot;&quot;</span>;
<a name="l02499"></a>02499                         }
<a name="l02500"></a>02500                 }
<a name="l02501"></a>02501                 [newCredentials setObject:ntlmDomain forKey:(NSString *)kCFHTTPAuthenticationAccountDomain];
<a name="l02502"></a>02502         }
<a name="l02503"></a>02503 
<a name="l02504"></a>02504 
<a name="l02505"></a>02505         <span class="comment">// If we have a username and password, let&#39;s apply them to the request and continue</span>
<a name="l02506"></a>02506         <span class="keywordflow">if</span> (user &amp;&amp; pass) {
<a name="l02507"></a>02507                 [newCredentials setObject:user forKey:(NSString *)kCFHTTPAuthenticationUsername];
<a name="l02508"></a>02508                 [newCredentials setObject:pass forKey:(NSString *)kCFHTTPAuthenticationPassword];
<a name="l02509"></a>02509                 <span class="keywordflow">return</span> newCredentials;
<a name="l02510"></a>02510         }
<a name="l02511"></a>02511         <span class="keywordflow">return</span> nil;
<a name="l02512"></a>02512 }
<a name="l02513"></a>02513 
<a name="l02514"></a>02514 
<a name="l02515"></a>02515 - (NSMutableDictionary *)findCredentials
<a name="l02516"></a>02516 {
<a name="l02517"></a>02517         NSMutableDictionary *newCredentials = [[[NSMutableDictionary alloc] init] autorelease];
<a name="l02518"></a>02518 
<a name="l02519"></a>02519         <span class="comment">// First, let&#39;s look at the url to see if the username and password were included</span>
<a name="l02520"></a>02520         <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *user = [[<span class="keyword">self</span> url] user];
<a name="l02521"></a>02521         <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *pass = [[<span class="keyword">self</span> url] password];
<a name="l02522"></a>02522 
<a name="l02523"></a>02523         <span class="keywordflow">if</span> (user &amp;&amp; pass) {
<a name="l02524"></a>02524 
<a name="l02525"></a>02525 <span class="preprocessor">                #if DEBUG_HTTP_AUTHENTICATION</span>
<a name="l02526"></a>02526 <span class="preprocessor"></span>                NSLog(<span class="stringliteral">@&quot;[AUTH] Request %@ will use credentials set on its url&quot;</span>,<span class="keyword">self</span>);
<a name="l02527"></a>02527 <span class="preprocessor">                #endif</span>
<a name="l02528"></a>02528 <span class="preprocessor"></span>
<a name="l02529"></a>02529         } <span class="keywordflow">else</span> {
<a name="l02530"></a>02530                 
<a name="l02531"></a>02531                 <span class="comment">// If this is a HEAD request generated by an ASINetworkQueue, we&#39;ll try to use the details from the main request</span>
<a name="l02532"></a>02532                 <span class="keywordflow">if</span> ([<span class="keyword">self</span> mainRequest] &amp;&amp; [[<span class="keyword">self</span> mainRequest] username] &amp;&amp; [[<span class="keyword">self</span> mainRequest] password]) {
<a name="l02533"></a>02533                         user = [[<span class="keyword">self</span> mainRequest] username];
<a name="l02534"></a>02534                         pass = [[<span class="keyword">self</span> mainRequest] password];
<a name="l02535"></a>02535 
<a name="l02536"></a>02536 <span class="preprocessor">                        #if DEBUG_HTTP_AUTHENTICATION</span>
<a name="l02537"></a>02537 <span class="preprocessor"></span>                        NSLog(<span class="stringliteral">@&quot;[AUTH] Request %@ will use credentials from its parent request&quot;</span>,<span class="keyword">self</span>);
<a name="l02538"></a>02538 <span class="preprocessor">                        #endif</span>
<a name="l02539"></a>02539 <span class="preprocessor"></span>
<a name="l02540"></a>02540                 <span class="comment">// Let&#39;s try to use the ones set in this object</span>
<a name="l02541"></a>02541                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ([<span class="keyword">self</span> username] &amp;&amp; [<span class="keyword">self</span> password]) {
<a name="l02542"></a>02542                         user = [<span class="keyword">self</span> username];
<a name="l02543"></a>02543                         pass = [<span class="keyword">self</span> password];
<a name="l02544"></a>02544 
<a name="l02545"></a>02545 <span class="preprocessor">                        #if DEBUG_HTTP_AUTHENTICATION</span>
<a name="l02546"></a>02546 <span class="preprocessor"></span>                        NSLog(<span class="stringliteral">@&quot;[AUTH] Request %@ will use username and password properties as credentials&quot;</span>,<span class="keyword">self</span>);
<a name="l02547"></a>02547 <span class="preprocessor">                        #endif</span>
<a name="l02548"></a>02548 <span class="preprocessor"></span>                }               
<a name="l02549"></a>02549         }
<a name="l02550"></a>02550         
<a name="l02551"></a>02551         <span class="comment">// Ok, that didn&#39;t work, let&#39;s try the keychain</span>
<a name="l02552"></a>02552         <span class="keywordflow">if</span> ((!user || !pass) &amp;&amp; useKeychainPersistence) {
<a name="l02553"></a>02553                 NSURLCredential *authenticationCredentials = [ASIHTTPRequest savedCredentialsForHost:[[<span class="keyword">self</span> url] host] port:[[[<span class="keyword">self</span> url] port] intValue] protocol:[[<span class="keyword">self</span> url] scheme] realm:[<span class="keyword">self</span> authenticationRealm]];
<a name="l02554"></a>02554                 <span class="keywordflow">if</span> (authenticationCredentials) {
<a name="l02555"></a>02555                         user = [authenticationCredentials user];
<a name="l02556"></a>02556                         pass = [authenticationCredentials password];
<a name="l02557"></a>02557 <span class="preprocessor">                        #if DEBUG_HTTP_AUTHENTICATION</span>
<a name="l02558"></a>02558 <span class="preprocessor"></span>                        <span class="keywordflow">if</span> (user &amp;&amp; pass) {
<a name="l02559"></a>02559                                 NSLog(<span class="stringliteral">@&quot;[AUTH] Request %@ will use credentials from the keychain&quot;</span>,<span class="keyword">self</span>);
<a name="l02560"></a>02560                         }
<a name="l02561"></a>02561 <span class="preprocessor">                        #endif</span>
<a name="l02562"></a>02562 <span class="preprocessor"></span>                }
<a name="l02563"></a>02563         }
<a name="l02564"></a>02564 
<a name="l02565"></a>02565         <span class="comment">// Handle NTLM, which requires a domain to be set too</span>
<a name="l02566"></a>02566         <span class="keywordflow">if</span> (CFHTTPAuthenticationRequiresAccountDomain(requestAuthentication)) {
<a name="l02567"></a>02567 
<a name="l02568"></a>02568                 <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *ntlmDomain = [<span class="keyword">self</span> domain];
<a name="l02569"></a>02569 
<a name="l02570"></a>02570                 <span class="comment">// If we have no domain yet, let&#39;s try to extract it from the username</span>
<a name="l02571"></a>02571                 <span class="keywordflow">if</span> (!ntlmDomain || [ntlmDomain length] == 0) {
<a name="l02572"></a>02572                         ntlmDomain = <span class="stringliteral">@&quot;&quot;</span>;
<a name="l02573"></a>02573                         NSArray* ntlmComponents = [user componentsSeparatedByString:@&quot;\\&quot;];
<a name="l02574"></a>02574                         <span class="keywordflow">if</span> ([ntlmComponents count] == 2) {
<a name="l02575"></a>02575                                 ntlmDomain = [ntlmComponents objectAtIndex:0];
<a name="l02576"></a>02576                                 user = [ntlmComponents objectAtIndex:1];
<a name="l02577"></a>02577                         }
<a name="l02578"></a>02578                 }
<a name="l02579"></a>02579                 [newCredentials setObject:ntlmDomain forKey:(NSString *)kCFHTTPAuthenticationAccountDomain];
<a name="l02580"></a>02580         }
<a name="l02581"></a>02581 
<a name="l02582"></a>02582         <span class="comment">// If we have a username and password, let&#39;s apply them to the request and continue</span>
<a name="l02583"></a>02583         <span class="keywordflow">if</span> (user &amp;&amp; pass) {
<a name="l02584"></a>02584                 [newCredentials setObject:user forKey:(NSString *)kCFHTTPAuthenticationUsername];
<a name="l02585"></a>02585                 [newCredentials setObject:pass forKey:(NSString *)kCFHTTPAuthenticationPassword];
<a name="l02586"></a>02586                 <span class="keywordflow">return</span> newCredentials;
<a name="l02587"></a>02587         }
<a name="l02588"></a>02588         <span class="keywordflow">return</span> nil;
<a name="l02589"></a>02589 }
<a name="l02590"></a>02590 
<a name="l02591"></a>02591 <span class="comment">// Called by delegate or authentication dialog to resume loading once authentication info has been populated</span>
<a name="l02592"></a>02592 - (void)retryUsingSuppliedCredentials
<a name="l02593"></a>02593 {
<a name="l02594"></a>02594 <span class="preprocessor">        #if DEBUG_HTTP_AUTHENTICATION</span>
<a name="l02595"></a>02595 <span class="preprocessor"></span>                NSLog(<span class="stringliteral">@&quot;[AUTH] Request %@ received credentials from its delegate or an ASIAuthenticationDialog, will retry&quot;</span>,<span class="keyword">self</span>);
<a name="l02596"></a>02596 <span class="preprocessor">        #endif</span>
<a name="l02597"></a>02597 <span class="preprocessor"></span>        <span class="comment">//If the url was changed by the delegate, our CFHTTPMessageRef will be NULL and we&#39;ll go back to the start</span>
<a name="l02598"></a>02598         <span class="keywordflow">if</span> (!request) {
<a name="l02599"></a>02599                 [<span class="keyword">self</span> performSelector:@selector(main) onThread:[[<span class="keyword">self</span> class] threadForRequest:self] withObject:nil waitUntilDone:NO];
<a name="l02600"></a>02600                 <span class="keywordflow">return</span>;
<a name="l02601"></a>02601         }
<a name="l02602"></a>02602         [<span class="keyword">self</span> performSelector:@selector(attemptToApplyCredentialsAndResume) onThread:[[<span class="keyword">self</span> class] threadForRequest:self] withObject:nil waitUntilDone:NO];
<a name="l02603"></a>02603 }
<a name="l02604"></a>02604 
<a name="l02605"></a>02605 <span class="comment">// Called by delegate or authentication dialog to cancel authentication</span>
<a name="l02606"></a>02606 - (void)cancelAuthentication
<a name="l02607"></a>02607 {
<a name="l02608"></a>02608 <span class="preprocessor">        #if DEBUG_HTTP_AUTHENTICATION</span>
<a name="l02609"></a>02609 <span class="preprocessor"></span>                NSLog(<span class="stringliteral">@&quot;[AUTH] Request %@ had authentication cancelled by its delegate or an ASIAuthenticationDialog&quot;</span>,<span class="keyword">self</span>);
<a name="l02610"></a>02610 <span class="preprocessor">        #endif</span>
<a name="l02611"></a>02611 <span class="preprocessor"></span>        [<span class="keyword">self</span> performSelector:@selector(failAuthentication) onThread:[[<span class="keyword">self</span> class] threadForRequest:self] withObject:nil waitUntilDone:NO];
<a name="l02612"></a>02612 }
<a name="l02613"></a>02613 
<a name="l02614"></a>02614 - (void)failAuthentication
<a name="l02615"></a>02615 {
<a name="l02616"></a>02616         [<span class="keyword">self</span> failWithError:ASIAuthenticationError];
<a name="l02617"></a>02617 }
<a name="l02618"></a>02618 
<a name="l02619"></a>02619 - (BOOL)showProxyAuthenticationDialog
<a name="l02620"></a>02620 {
<a name="l02621"></a>02621         <span class="keywordflow">if</span> ([<span class="keyword">self</span> isSynchronous]) {
<a name="l02622"></a>02622                 <span class="keywordflow">return</span> NO;
<a name="l02623"></a>02623         }
<a name="l02624"></a>02624 
<a name="l02625"></a>02625         <span class="comment">// Mac authentication dialog coming soon!</span>
<a name="l02626"></a>02626 <span class="preprocessor">        #if TARGET_OS_IPHONE</span>
<a name="l02627"></a>02627 <span class="preprocessor"></span>        <span class="keywordflow">if</span> ([<span class="keyword">self</span> shouldPresentProxyAuthenticationDialog]) {
<a name="l02628"></a>02628                 [ASIAuthenticationDialog performSelectorOnMainThread:@selector(presentAuthenticationDialogForRequest:) withObject:self waitUntilDone:[NSThread isMainThread]];
<a name="l02629"></a>02629                 <span class="keywordflow">return</span> YES;
<a name="l02630"></a>02630         }
<a name="l02631"></a>02631         <span class="keywordflow">return</span> NO;
<a name="l02632"></a>02632 <span class="preprocessor">        #else</span>
<a name="l02633"></a>02633 <span class="preprocessor"></span>        <span class="keywordflow">return</span> NO;
<a name="l02634"></a>02634 <span class="preprocessor">        #endif</span>
<a name="l02635"></a>02635 <span class="preprocessor"></span>}
<a name="l02636"></a>02636 
<a name="l02637"></a>02637 
<a name="l02638"></a>02638 - (BOOL)willAskDelegateForProxyCredentials
<a name="l02639"></a>02639 {
<a name="l02640"></a>02640         <span class="keywordflow">if</span> ([<span class="keyword">self</span> isSynchronous]) {
<a name="l02641"></a>02641                 <span class="keywordflow">return</span> NO;
<a name="l02642"></a>02642         }
<a name="l02643"></a>02643 
<a name="l02644"></a>02644         <span class="comment">// If we have a delegate, we&#39;ll see if it can handle proxyAuthenticationNeededForRequest:.</span>
<a name="l02645"></a>02645         <span class="comment">// Otherwise, we&#39;ll try the queue (if this request is part of one) and it will pass the message on to its own delegate</span>
<a name="l02646"></a>02646         <span class="keywordtype">id</span> authenticationDelegate = [<span class="keyword">self</span> delegate];
<a name="l02647"></a>02647         <span class="keywordflow">if</span> (!authenticationDelegate) {
<a name="l02648"></a>02648                 authenticationDelegate = [<span class="keyword">self</span> queue];
<a name="l02649"></a>02649         }
<a name="l02650"></a>02650         
<a name="l02651"></a>02651         BOOL delegateOrBlockWillHandleAuthentication = NO;
<a name="l02652"></a>02652 
<a name="l02653"></a>02653         <span class="keywordflow">if</span> ([authenticationDelegate respondsToSelector:<span class="keyword">@selector</span>(proxyAuthenticationNeededForRequest:)]) {
<a name="l02654"></a>02654                 delegateOrBlockWillHandleAuthentication = YES;
<a name="l02655"></a>02655         }
<a name="l02656"></a>02656 
<a name="l02657"></a>02657 <span class="preprocessor">        #if NS_BLOCKS_AVAILABLE</span>
<a name="l02658"></a>02658 <span class="preprocessor"></span>        <span class="keywordflow">if</span>(proxyAuthenticationNeededBlock){
<a name="l02659"></a>02659                 delegateOrBlockWillHandleAuthentication = YES;
<a name="l02660"></a>02660         }
<a name="l02661"></a>02661 <span class="preprocessor">        #endif</span>
<a name="l02662"></a>02662 <span class="preprocessor"></span>
<a name="l02663"></a>02663         <span class="keywordflow">if</span> (delegateOrBlockWillHandleAuthentication) {
<a name="l02664"></a>02664                 [<span class="keyword">self</span> performSelectorOnMainThread:@selector(askDelegateForProxyCredentials) withObject:nil waitUntilDone:NO];
<a name="l02665"></a>02665         }
<a name="l02666"></a>02666         
<a name="l02667"></a>02667         <span class="keywordflow">return</span> delegateOrBlockWillHandleAuthentication;
<a name="l02668"></a>02668 }
<a name="l02669"></a>02669 
<a name="l02670"></a>02670 <span class="comment">/* ALWAYS CALLED ON MAIN THREAD! */</span>
<a name="l02671"></a>02671 - (void)askDelegateForProxyCredentials
<a name="l02672"></a>02672 {
<a name="l02673"></a>02673         <span class="keywordtype">id</span> authenticationDelegate = [<span class="keyword">self</span> delegate];
<a name="l02674"></a>02674         <span class="keywordflow">if</span> (!authenticationDelegate) {
<a name="l02675"></a>02675                 authenticationDelegate = [<span class="keyword">self</span> queue];
<a name="l02676"></a>02676         }
<a name="l02677"></a>02677         <span class="keywordflow">if</span> ([authenticationDelegate respondsToSelector:<span class="keyword">@selector</span>(proxyAuthenticationNeededForRequest:)]) {
<a name="l02678"></a>02678                 [authenticationDelegate performSelector:@selector(proxyAuthenticationNeededForRequest:) withObject:self];
<a name="l02679"></a>02679                 <span class="keywordflow">return</span>;
<a name="l02680"></a>02680         }
<a name="l02681"></a>02681 <span class="preprocessor">        #if NS_BLOCKS_AVAILABLE</span>
<a name="l02682"></a>02682 <span class="preprocessor"></span>        <span class="keywordflow">if</span>(proxyAuthenticationNeededBlock){
<a name="l02683"></a>02683                 proxyAuthenticationNeededBlock();
<a name="l02684"></a>02684         }
<a name="l02685"></a>02685 <span class="preprocessor">        #endif</span>
<a name="l02686"></a>02686 <span class="preprocessor"></span>}
<a name="l02687"></a>02687 
<a name="l02688"></a>02688 
<a name="l02689"></a>02689 - (BOOL)willAskDelegateForCredentials
<a name="l02690"></a>02690 {
<a name="l02691"></a>02691         <span class="keywordflow">if</span> ([<span class="keyword">self</span> isSynchronous]) {
<a name="l02692"></a>02692                 <span class="keywordflow">return</span> NO;
<a name="l02693"></a>02693         }
<a name="l02694"></a>02694 
<a name="l02695"></a>02695         <span class="comment">// If we have a delegate, we&#39;ll see if it can handle proxyAuthenticationNeededForRequest:.</span>
<a name="l02696"></a>02696         <span class="comment">// Otherwise, we&#39;ll try the queue (if this request is part of one) and it will pass the message on to its own delegate</span>
<a name="l02697"></a>02697         <span class="keywordtype">id</span> authenticationDelegate = [<span class="keyword">self</span> delegate];
<a name="l02698"></a>02698         <span class="keywordflow">if</span> (!authenticationDelegate) {
<a name="l02699"></a>02699                 authenticationDelegate = [<span class="keyword">self</span> queue];
<a name="l02700"></a>02700         }
<a name="l02701"></a>02701 
<a name="l02702"></a>02702         BOOL delegateOrBlockWillHandleAuthentication = NO;
<a name="l02703"></a>02703 
<a name="l02704"></a>02704         <span class="keywordflow">if</span> ([authenticationDelegate respondsToSelector:<span class="keyword">@selector</span>(authenticationNeededForRequest:)]) {
<a name="l02705"></a>02705                 delegateOrBlockWillHandleAuthentication = YES;
<a name="l02706"></a>02706         }
<a name="l02707"></a>02707 
<a name="l02708"></a>02708 <span class="preprocessor">        #if NS_BLOCKS_AVAILABLE</span>
<a name="l02709"></a>02709 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (authenticationNeededBlock) {
<a name="l02710"></a>02710                 delegateOrBlockWillHandleAuthentication = YES;
<a name="l02711"></a>02711         }
<a name="l02712"></a>02712 <span class="preprocessor">        #endif</span>
<a name="l02713"></a>02713 <span class="preprocessor"></span>
<a name="l02714"></a>02714         <span class="keywordflow">if</span> (delegateOrBlockWillHandleAuthentication) {
<a name="l02715"></a>02715                 [<span class="keyword">self</span> performSelectorOnMainThread:@selector(askDelegateForCredentials) withObject:nil waitUntilDone:NO];
<a name="l02716"></a>02716         }
<a name="l02717"></a>02717         <span class="keywordflow">return</span> delegateOrBlockWillHandleAuthentication;
<a name="l02718"></a>02718 }
<a name="l02719"></a>02719 
<a name="l02720"></a>02720 <span class="comment">/* ALWAYS CALLED ON MAIN THREAD! */</span>
<a name="l02721"></a>02721 - (void)askDelegateForCredentials
<a name="l02722"></a>02722 {
<a name="l02723"></a>02723         <span class="keywordtype">id</span> authenticationDelegate = [<span class="keyword">self</span> delegate];
<a name="l02724"></a>02724         <span class="keywordflow">if</span> (!authenticationDelegate) {
<a name="l02725"></a>02725                 authenticationDelegate = [<span class="keyword">self</span> queue];
<a name="l02726"></a>02726         }
<a name="l02727"></a>02727         
<a name="l02728"></a>02728         <span class="keywordflow">if</span> ([authenticationDelegate respondsToSelector:<span class="keyword">@selector</span>(authenticationNeededForRequest:)]) {
<a name="l02729"></a>02729                 [authenticationDelegate performSelector:@selector(authenticationNeededForRequest:) withObject:self];
<a name="l02730"></a>02730                 <span class="keywordflow">return</span>;
<a name="l02731"></a>02731         }
<a name="l02732"></a>02732         
<a name="l02733"></a>02733 <span class="preprocessor">        #if NS_BLOCKS_AVAILABLE</span>
<a name="l02734"></a>02734 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (authenticationNeededBlock) {
<a name="l02735"></a>02735                 authenticationNeededBlock();
<a name="l02736"></a>02736         }
<a name="l02737"></a>02737 <span class="preprocessor">        #endif  </span>
<a name="l02738"></a>02738 <span class="preprocessor"></span>}
<a name="l02739"></a>02739 
<a name="l02740"></a>02740 - (void)attemptToApplyProxyCredentialsAndResume
<a name="l02741"></a>02741 {
<a name="l02742"></a>02742         
<a name="l02743"></a>02743         <span class="keywordflow">if</span> ([<span class="keyword">self</span> error] || [<span class="keyword">self</span> isCancelled]) {
<a name="l02744"></a>02744                 <span class="keywordflow">return</span>;
<a name="l02745"></a>02745         }
<a name="l02746"></a>02746         
<a name="l02747"></a>02747         <span class="comment">// Read authentication data</span>
<a name="l02748"></a>02748         <span class="keywordflow">if</span> (!proxyAuthentication) {
<a name="l02749"></a>02749                 CFHTTPMessageRef responseHeader = (CFHTTPMessageRef) CFReadStreamCopyProperty((CFReadStreamRef)[<span class="keyword">self</span> readStream],kCFStreamPropertyHTTPResponseHeader);
<a name="l02750"></a>02750                 proxyAuthentication = CFHTTPAuthenticationCreateFromResponse(NULL, responseHeader);
<a name="l02751"></a>02751                 CFRelease(responseHeader);
<a name="l02752"></a>02752                 [<span class="keyword">self</span> setProxyAuthenticationScheme:[(<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">CFHTTPAuthenticationCopyMethod</a>(proxyAuthentication) autorelease]];
<a name="l02753"></a>02753         }
<a name="l02754"></a>02754         
<a name="l02755"></a>02755         <span class="comment">// If we haven&#39;t got a CFHTTPAuthenticationRef by now, something is badly wrong, so we&#39;ll have to give up</span>
<a name="l02756"></a>02756         <span class="keywordflow">if</span> (!proxyAuthentication) {
<a name="l02757"></a>02757                 [<span class="keyword">self</span> cancelLoad];
<a name="l02758"></a>02758                 [<span class="keyword">self</span> failWithError:[NSError errorWithDomain:NetworkRequestErrorDomain code:ASIInternalErrorWhileApplyingCredentialsType userInfo:[NSDictionary dictionaryWithObjectsAndKeys:@&quot;Failed to get authentication object from response headers&quot;,NSLocalizedDescriptionKey,nil]]];
<a name="l02759"></a>02759                 <span class="keywordflow">return</span>;
<a name="l02760"></a>02760         }
<a name="l02761"></a>02761         
<a name="l02762"></a>02762         <span class="comment">// Get the authentication realm</span>
<a name="l02763"></a>02763         [<span class="keyword">self</span> setProxyAuthenticationRealm:nil];
<a name="l02764"></a>02764         <span class="keywordflow">if</span> (!CFHTTPAuthenticationRequiresAccountDomain(proxyAuthentication)) {
<a name="l02765"></a>02765                 [<span class="keyword">self</span> setProxyAuthenticationRealm:[(<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">CFHTTPAuthenticationCopyRealm</a>(proxyAuthentication) autorelease]];
<a name="l02766"></a>02766         }
<a name="l02767"></a>02767         
<a name="l02768"></a>02768         <span class="comment">// See if authentication is valid</span>
<a name="l02769"></a>02769         CFStreamError err;              
<a name="l02770"></a>02770         <span class="keywordflow">if</span> (!CFHTTPAuthenticationIsValid(proxyAuthentication, &amp;err)) {
<a name="l02771"></a>02771                 
<a name="l02772"></a>02772                 CFRelease(proxyAuthentication);
<a name="l02773"></a>02773                 proxyAuthentication = NULL;
<a name="l02774"></a>02774                 
<a name="l02775"></a>02775                 <span class="comment">// check for bad credentials, so we can give the delegate a chance to replace them</span>
<a name="l02776"></a>02776                 <span class="keywordflow">if</span> (err.domain == kCFStreamErrorDomainHTTP &amp;&amp; (err.error == kCFStreamErrorHTTPAuthenticationBadUserName || err.error == kCFStreamErrorHTTPAuthenticationBadPassword)) {
<a name="l02777"></a>02777                         
<a name="l02778"></a>02778                         <span class="comment">// Prevent more than one request from asking for credentials at once</span>
<a name="l02779"></a>02779                         [delegateAuthenticationLock lock];
<a name="l02780"></a>02780                         
<a name="l02781"></a>02781                         <span class="comment">// We know the credentials we just presented are bad, we should remove them from the session store too</span>
<a name="l02782"></a>02782                         [[<span class="keyword">self</span> class] removeProxyAuthenticationCredentialsFromSessionStore:proxyCredentials];
<a name="l02783"></a>02783                         [<span class="keyword">self</span> setProxyCredentials:nil];
<a name="l02784"></a>02784                         
<a name="l02785"></a>02785                         
<a name="l02786"></a>02786                         <span class="comment">// If the user cancelled authentication via a dialog presented by another request, our queue may have cancelled us</span>
<a name="l02787"></a>02787                         <span class="keywordflow">if</span> ([<span class="keyword">self</span> error] || [<span class="keyword">self</span> isCancelled]) {
<a name="l02788"></a>02788                                 [delegateAuthenticationLock unlock];
<a name="l02789"></a>02789                                 <span class="keywordflow">return</span>;
<a name="l02790"></a>02790                         }
<a name="l02791"></a>02791                         
<a name="l02792"></a>02792                         
<a name="l02793"></a>02793                         <span class="comment">// Now we&#39;ve acquired the lock, it may be that the session contains credentials we can re-use for this request</span>
<a name="l02794"></a>02794                         <span class="keywordflow">if</span> ([<span class="keyword">self</span> useSessionPersistence]) {
<a name="l02795"></a>02795                                 NSDictionary *credentials = [<span class="keyword">self</span> findSessionProxyAuthenticationCredentials];
<a name="l02796"></a>02796                                 <span class="keywordflow">if</span> (credentials &amp;&amp; [<span class="keyword">self</span> applyProxyCredentials:[credentials objectForKey:<span class="stringliteral">@&quot;Credentials&quot;</span>]]) {
<a name="l02797"></a>02797                                         [delegateAuthenticationLock unlock];
<a name="l02798"></a>02798                                         [<span class="keyword">self</span> startRequest];
<a name="l02799"></a>02799                                         <span class="keywordflow">return</span>;
<a name="l02800"></a>02800                                 }
<a name="l02801"></a>02801                         }
<a name="l02802"></a>02802                         
<a name="l02803"></a>02803                         [<span class="keyword">self</span> setLastActivityTime:nil];
<a name="l02804"></a>02804                         
<a name="l02805"></a>02805                         <span class="keywordflow">if</span> ([<span class="keyword">self</span> willAskDelegateForProxyCredentials]) {
<a name="l02806"></a>02806                                 [<span class="keyword">self</span> attemptToApplyProxyCredentialsAndResume];
<a name="l02807"></a>02807                                 [delegateAuthenticationLock unlock];
<a name="l02808"></a>02808                                 <span class="keywordflow">return</span>;
<a name="l02809"></a>02809                         }
<a name="l02810"></a>02810                         <span class="keywordflow">if</span> ([<span class="keyword">self</span> showProxyAuthenticationDialog]) {
<a name="l02811"></a>02811                                 [<span class="keyword">self</span> attemptToApplyProxyCredentialsAndResume];
<a name="l02812"></a>02812                                 [delegateAuthenticationLock unlock];
<a name="l02813"></a>02813                                 <span class="keywordflow">return</span>;
<a name="l02814"></a>02814                         }
<a name="l02815"></a>02815                         [delegateAuthenticationLock unlock];
<a name="l02816"></a>02816                 }
<a name="l02817"></a>02817                 [<span class="keyword">self</span> cancelLoad];
<a name="l02818"></a>02818                 [<span class="keyword">self</span> failWithError:ASIAuthenticationError];
<a name="l02819"></a>02819                 <span class="keywordflow">return</span>;
<a name="l02820"></a>02820         }
<a name="l02821"></a>02821 
<a name="l02822"></a>02822         [<span class="keyword">self</span> cancelLoad];
<a name="l02823"></a>02823         
<a name="l02824"></a>02824         <span class="keywordflow">if</span> (proxyCredentials) {
<a name="l02825"></a>02825                 
<a name="l02826"></a>02826                 <span class="comment">// We use startRequest rather than starting all over again in load request because NTLM requires we reuse the request</span>
<a name="l02827"></a>02827                 <span class="keywordflow">if</span> ((([<span class="keyword">self</span> proxyAuthenticationScheme] != (<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)kCFHTTPAuthenticationSchemeNTLM) || [<span class="keyword">self</span> proxyAuthenticationRetryCount] &lt; 2) &amp;&amp; [<span class="keyword">self</span> applyProxyCredentials:proxyCredentials]) {
<a name="l02828"></a>02828                         [<span class="keyword">self</span> startRequest];
<a name="l02829"></a>02829                         
<a name="l02830"></a>02830                 <span class="comment">// We&#39;ve failed NTLM authentication twice, we should assume our credentials are wrong</span>
<a name="l02831"></a>02831                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ([<span class="keyword">self</span> proxyAuthenticationScheme] == (<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)kCFHTTPAuthenticationSchemeNTLM &amp;&amp; [<span class="keyword">self</span> proxyAuthenticationRetryCount] == 2) {
<a name="l02832"></a>02832                         [<span class="keyword">self</span> failWithError:ASIAuthenticationError];
<a name="l02833"></a>02833                         
<a name="l02834"></a>02834                 <span class="comment">// Something went wrong, we&#39;ll have to give up</span>
<a name="l02835"></a>02835                 } <span class="keywordflow">else</span> {
<a name="l02836"></a>02836                         [<span class="keyword">self</span> failWithError:[NSError errorWithDomain:NetworkRequestErrorDomain code:ASIInternalErrorWhileApplyingCredentialsType userInfo:[NSDictionary dictionaryWithObjectsAndKeys:@&quot;Failed to apply proxy credentials to request&quot;,NSLocalizedDescriptionKey,nil]]];
<a name="l02837"></a>02837                 }
<a name="l02838"></a>02838                 
<a name="l02839"></a>02839         <span class="comment">// Are a user name &amp; password needed?</span>
<a name="l02840"></a>02840         }  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (CFHTTPAuthenticationRequiresUserNameAndPassword(proxyAuthentication)) {
<a name="l02841"></a>02841                 
<a name="l02842"></a>02842                 <span class="comment">// Prevent more than one request from asking for credentials at once</span>
<a name="l02843"></a>02843                 [delegateAuthenticationLock lock];
<a name="l02844"></a>02844                 
<a name="l02845"></a>02845                 <span class="comment">// If the user cancelled authentication via a dialog presented by another request, our queue may have cancelled us</span>
<a name="l02846"></a>02846                 <span class="keywordflow">if</span> ([<span class="keyword">self</span> error] || [<span class="keyword">self</span> isCancelled]) {
<a name="l02847"></a>02847                         [delegateAuthenticationLock unlock];
<a name="l02848"></a>02848                         <span class="keywordflow">return</span>;
<a name="l02849"></a>02849                 }
<a name="l02850"></a>02850                 
<a name="l02851"></a>02851                 <span class="comment">// Now we&#39;ve acquired the lock, it may be that the session contains credentials we can re-use for this request</span>
<a name="l02852"></a>02852                 <span class="keywordflow">if</span> ([<span class="keyword">self</span> useSessionPersistence]) {
<a name="l02853"></a>02853                         NSDictionary *credentials = [<span class="keyword">self</span> findSessionProxyAuthenticationCredentials];
<a name="l02854"></a>02854                         <span class="keywordflow">if</span> (credentials &amp;&amp; [<span class="keyword">self</span> applyProxyCredentials:[credentials objectForKey:<span class="stringliteral">@&quot;Credentials&quot;</span>]]) {
<a name="l02855"></a>02855                                 [delegateAuthenticationLock unlock];
<a name="l02856"></a>02856                                 [<span class="keyword">self</span> startRequest];
<a name="l02857"></a>02857                                 <span class="keywordflow">return</span>;
<a name="l02858"></a>02858                         }
<a name="l02859"></a>02859                 }
<a name="l02860"></a>02860                 
<a name="l02861"></a>02861                 NSMutableDictionary *newCredentials = [<span class="keyword">self</span> findProxyCredentials];
<a name="l02862"></a>02862                 
<a name="l02863"></a>02863                 <span class="comment">//If we have some credentials to use let&#39;s apply them to the request and continue</span>
<a name="l02864"></a>02864                 <span class="keywordflow">if</span> (newCredentials) {
<a name="l02865"></a>02865                         
<a name="l02866"></a>02866                         <span class="keywordflow">if</span> ([<span class="keyword">self</span> applyProxyCredentials:newCredentials]) {
<a name="l02867"></a>02867                                 [delegateAuthenticationLock unlock];
<a name="l02868"></a>02868                                 [<span class="keyword">self</span> startRequest];
<a name="l02869"></a>02869                         } <span class="keywordflow">else</span> {
<a name="l02870"></a>02870                                 [delegateAuthenticationLock unlock];
<a name="l02871"></a>02871                                 [<span class="keyword">self</span> failWithError:[NSError errorWithDomain:NetworkRequestErrorDomain code:ASIInternalErrorWhileApplyingCredentialsType userInfo:[NSDictionary dictionaryWithObjectsAndKeys:@&quot;Failed to apply proxy credentials to request&quot;,NSLocalizedDescriptionKey,nil]]];
<a name="l02872"></a>02872                         }
<a name="l02873"></a>02873                         
<a name="l02874"></a>02874                         <span class="keywordflow">return</span>;
<a name="l02875"></a>02875                 }
<a name="l02876"></a>02876                 
<a name="l02877"></a>02877                 <span class="keywordflow">if</span> ([<span class="keyword">self</span> willAskDelegateForProxyCredentials]) {
<a name="l02878"></a>02878                         [delegateAuthenticationLock unlock];
<a name="l02879"></a>02879                         <span class="keywordflow">return</span>;
<a name="l02880"></a>02880                 }
<a name="l02881"></a>02881                 
<a name="l02882"></a>02882                 <span class="keywordflow">if</span> ([<span class="keyword">self</span> showProxyAuthenticationDialog]) {
<a name="l02883"></a>02883                         [delegateAuthenticationLock unlock];
<a name="l02884"></a>02884                         <span class="keywordflow">return</span>;
<a name="l02885"></a>02885                 }
<a name="l02886"></a>02886                 [delegateAuthenticationLock unlock];
<a name="l02887"></a>02887                 
<a name="l02888"></a>02888                 <span class="comment">// The delegate isn&#39;t interested and we aren&#39;t showing the authentication dialog, we&#39;ll have to give up</span>
<a name="l02889"></a>02889                 [<span class="keyword">self</span> failWithError:ASIAuthenticationError];
<a name="l02890"></a>02890                 <span class="keywordflow">return</span>;
<a name="l02891"></a>02891         }
<a name="l02892"></a>02892         
<a name="l02893"></a>02893 }
<a name="l02894"></a>02894 
<a name="l02895"></a>02895 - (BOOL)showAuthenticationDialog
<a name="l02896"></a>02896 {
<a name="l02897"></a>02897         <span class="keywordflow">if</span> ([<span class="keyword">self</span> isSynchronous]) {
<a name="l02898"></a>02898                 <span class="keywordflow">return</span> NO;
<a name="l02899"></a>02899         }
<a name="l02900"></a>02900         <span class="comment">// Mac authentication dialog coming soon!</span>
<a name="l02901"></a>02901 <span class="preprocessor">        #if TARGET_OS_IPHONE</span>
<a name="l02902"></a>02902 <span class="preprocessor"></span>        <span class="keywordflow">if</span> ([<span class="keyword">self</span> shouldPresentAuthenticationDialog]) {
<a name="l02903"></a>02903                 [ASIAuthenticationDialog performSelectorOnMainThread:@selector(presentAuthenticationDialogForRequest:) withObject:self waitUntilDone:[NSThread isMainThread]];
<a name="l02904"></a>02904                 <span class="keywordflow">return</span> YES;
<a name="l02905"></a>02905         }
<a name="l02906"></a>02906         <span class="keywordflow">return</span> NO;
<a name="l02907"></a>02907 <span class="preprocessor">        #else</span>
<a name="l02908"></a>02908 <span class="preprocessor"></span>        <span class="keywordflow">return</span> NO;
<a name="l02909"></a>02909 <span class="preprocessor">        #endif</span>
<a name="l02910"></a>02910 <span class="preprocessor"></span>}
<a name="l02911"></a>02911 
<a name="l02912"></a>02912 - (void)attemptToApplyCredentialsAndResume
<a name="l02913"></a>02913 {
<a name="l02914"></a>02914         <span class="keywordflow">if</span> ([<span class="keyword">self</span> error] || [<span class="keyword">self</span> isCancelled]) {
<a name="l02915"></a>02915                 <span class="keywordflow">return</span>;
<a name="l02916"></a>02916         }
<a name="l02917"></a>02917         
<a name="l02918"></a>02918         <span class="comment">// Do we actually need to authenticate with a proxy?</span>
<a name="l02919"></a>02919         <span class="keywordflow">if</span> ([<span class="keyword">self</span> authenticationNeeded] == ASIProxyAuthenticationNeeded) {
<a name="l02920"></a>02920                 [<span class="keyword">self</span> attemptToApplyProxyCredentialsAndResume];
<a name="l02921"></a>02921                 <span class="keywordflow">return</span>;
<a name="l02922"></a>02922         }
<a name="l02923"></a>02923         
<a name="l02924"></a>02924         <span class="comment">// Read authentication data</span>
<a name="l02925"></a>02925         <span class="keywordflow">if</span> (!requestAuthentication) {
<a name="l02926"></a>02926                 CFHTTPMessageRef responseHeader = (CFHTTPMessageRef) CFReadStreamCopyProperty((CFReadStreamRef)[<span class="keyword">self</span> readStream],kCFStreamPropertyHTTPResponseHeader);
<a name="l02927"></a>02927                 requestAuthentication = CFHTTPAuthenticationCreateFromResponse(NULL, responseHeader);
<a name="l02928"></a>02928                 CFRelease(responseHeader);
<a name="l02929"></a>02929                 [<span class="keyword">self</span> setAuthenticationScheme:[(<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">CFHTTPAuthenticationCopyMethod</a>(requestAuthentication) autorelease]];
<a name="l02930"></a>02930         }
<a name="l02931"></a>02931         
<a name="l02932"></a>02932         <span class="keywordflow">if</span> (!requestAuthentication) {
<a name="l02933"></a>02933 <span class="preprocessor">                #if DEBUG_HTTP_AUTHENTICATION</span>
<a name="l02934"></a>02934 <span class="preprocessor"></span>                NSLog(<span class="stringliteral">@&quot;[AUTH] Request %@ failed to read authentication information from response headers&quot;</span>,<span class="keyword">self</span>);
<a name="l02935"></a>02935 <span class="preprocessor">                #endif</span>
<a name="l02936"></a>02936 <span class="preprocessor"></span>
<a name="l02937"></a>02937                 [<span class="keyword">self</span> cancelLoad];
<a name="l02938"></a>02938                 [<span class="keyword">self</span> failWithError:[NSError errorWithDomain:NetworkRequestErrorDomain code:ASIInternalErrorWhileApplyingCredentialsType userInfo:[NSDictionary dictionaryWithObjectsAndKeys:@&quot;Failed to get authentication object from response headers&quot;,NSLocalizedDescriptionKey,nil]]];
<a name="l02939"></a>02939                 <span class="keywordflow">return</span>;
<a name="l02940"></a>02940         }
<a name="l02941"></a>02941         
<a name="l02942"></a>02942         <span class="comment">// Get the authentication realm</span>
<a name="l02943"></a>02943         [<span class="keyword">self</span> setAuthenticationRealm:nil];
<a name="l02944"></a>02944         <span class="keywordflow">if</span> (!CFHTTPAuthenticationRequiresAccountDomain(requestAuthentication)) {
<a name="l02945"></a>02945                 [<span class="keyword">self</span> setAuthenticationRealm:[(<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">CFHTTPAuthenticationCopyRealm</a>(requestAuthentication) autorelease]];
<a name="l02946"></a>02946         }
<a name="l02947"></a>02947         
<a name="l02948"></a>02948 <span class="preprocessor">        #if DEBUG_HTTP_AUTHENTICATION</span>
<a name="l02949"></a>02949 <span class="preprocessor"></span>                <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *realm = [<span class="keyword">self</span> authenticationRealm];
<a name="l02950"></a>02950                 <span class="keywordflow">if</span> (realm) {
<a name="l02951"></a>02951                         realm = [<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> stringWithFormat:@&quot; (Realm: %@)&quot;,realm];
<a name="l02952"></a>02952                 } <span class="keywordflow">else</span> {
<a name="l02953"></a>02953                         realm = <span class="stringliteral">@&quot;&quot;</span>;
<a name="l02954"></a>02954                 }
<a name="l02955"></a>02955                 <span class="keywordflow">if</span> ([<span class="keyword">self</span> authenticationScheme] != (<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)kCFHTTPAuthenticationSchemeNTLM || [<span class="keyword">self</span> authenticationRetryCount] == 0) {
<a name="l02956"></a>02956                         NSLog(<span class="stringliteral">@&quot;[AUTH] Request %@ received 401 challenge and must authenticate using %@%@&quot;</span>,<span class="keyword">self</span>,[<span class="keyword">self</span> authenticationScheme],realm);
<a name="l02957"></a>02957                 } <span class="keywordflow">else</span> {
<a name="l02958"></a>02958                         NSLog(<span class="stringliteral">@&quot;[AUTH] Request %@ NTLM handshake step %i&quot;</span>,<span class="keyword">self</span>,[<span class="keyword">self</span> authenticationRetryCount]+1);
<a name="l02959"></a>02959                 }
<a name="l02960"></a>02960 <span class="preprocessor">        #endif</span>
<a name="l02961"></a>02961 <span class="preprocessor"></span>
<a name="l02962"></a>02962         <span class="comment">// See if authentication is valid</span>
<a name="l02963"></a>02963         CFStreamError err;              
<a name="l02964"></a>02964         <span class="keywordflow">if</span> (!CFHTTPAuthenticationIsValid(requestAuthentication, &amp;err)) {
<a name="l02965"></a>02965                 
<a name="l02966"></a>02966                 CFRelease(requestAuthentication);
<a name="l02967"></a>02967                 requestAuthentication = NULL;
<a name="l02968"></a>02968                 
<a name="l02969"></a>02969                 <span class="comment">// check for bad credentials, so we can give the delegate a chance to replace them</span>
<a name="l02970"></a>02970                 <span class="keywordflow">if</span> (err.domain == kCFStreamErrorDomainHTTP &amp;&amp; (err.error == kCFStreamErrorHTTPAuthenticationBadUserName || err.error == kCFStreamErrorHTTPAuthenticationBadPassword)) {
<a name="l02971"></a>02971 
<a name="l02972"></a>02972 <span class="preprocessor">                        #if DEBUG_HTTP_AUTHENTICATION</span>
<a name="l02973"></a>02973 <span class="preprocessor"></span>                        NSLog(<span class="stringliteral">@&quot;[AUTH] Request %@ had bad credentials, will remove them from the session store if they are cached&quot;</span>,<span class="keyword">self</span>);
<a name="l02974"></a>02974 <span class="preprocessor">                        #endif</span>
<a name="l02975"></a>02975 <span class="preprocessor"></span>
<a name="l02976"></a>02976                         <span class="comment">// Prevent more than one request from asking for credentials at once</span>
<a name="l02977"></a>02977                         [delegateAuthenticationLock lock];
<a name="l02978"></a>02978                         
<a name="l02979"></a>02979                         <span class="comment">// We know the credentials we just presented are bad, we should remove them from the session store too</span>
<a name="l02980"></a>02980                         [[<span class="keyword">self</span> class] removeAuthenticationCredentialsFromSessionStore:requestCredentials];
<a name="l02981"></a>02981                         [<span class="keyword">self</span> setRequestCredentials:nil];
<a name="l02982"></a>02982                         
<a name="l02983"></a>02983                         <span class="comment">// If the user cancelled authentication via a dialog presented by another request, our queue may have cancelled us</span>
<a name="l02984"></a>02984                         <span class="keywordflow">if</span> ([<span class="keyword">self</span> error] || [<span class="keyword">self</span> isCancelled]) {
<a name="l02985"></a>02985 
<a name="l02986"></a>02986 <span class="preprocessor">                                #if DEBUG_HTTP_AUTHENTICATION</span>
<a name="l02987"></a>02987 <span class="preprocessor"></span>                                NSLog(<span class="stringliteral">@&quot;[AUTH] Request %@ failed or was cancelled while waiting to access credentials&quot;</span>,<span class="keyword">self</span>);
<a name="l02988"></a>02988 <span class="preprocessor">                                #endif</span>
<a name="l02989"></a>02989 <span class="preprocessor"></span>
<a name="l02990"></a>02990                                 [delegateAuthenticationLock unlock];
<a name="l02991"></a>02991                                 <span class="keywordflow">return</span>;
<a name="l02992"></a>02992                         }
<a name="l02993"></a>02993 
<a name="l02994"></a>02994                         <span class="comment">// Now we&#39;ve acquired the lock, it may be that the session contains credentials we can re-use for this request</span>
<a name="l02995"></a>02995                         <span class="keywordflow">if</span> ([<span class="keyword">self</span> useSessionPersistence]) {
<a name="l02996"></a>02996                                 NSDictionary *credentials = [<span class="keyword">self</span> findSessionAuthenticationCredentials];
<a name="l02997"></a>02997                                 <span class="keywordflow">if</span> (credentials &amp;&amp; [<span class="keyword">self</span> applyCredentials:[credentials objectForKey:<span class="stringliteral">@&quot;Credentials&quot;</span>]]) {
<a name="l02998"></a>02998 
<a name="l02999"></a>02999 <span class="preprocessor">                                        #if DEBUG_HTTP_AUTHENTICATION</span>
<a name="l03000"></a>03000 <span class="preprocessor"></span>                                        NSLog(<span class="stringliteral">@&quot;[AUTH] Request %@ will reuse cached credentials from the session (%@)&quot;</span>,<span class="keyword">self</span>,[credentials objectForKey:<span class="stringliteral">@&quot;AuthenticationScheme&quot;</span>]);
<a name="l03001"></a>03001 <span class="preprocessor">                                        #endif</span>
<a name="l03002"></a>03002 <span class="preprocessor"></span>
<a name="l03003"></a>03003                                         [delegateAuthenticationLock unlock];
<a name="l03004"></a>03004                                         [<span class="keyword">self</span> startRequest];
<a name="l03005"></a>03005                                         <span class="keywordflow">return</span>;
<a name="l03006"></a>03006                                 }
<a name="l03007"></a>03007                         }
<a name="l03008"></a>03008                         
<a name="l03009"></a>03009                         [<span class="keyword">self</span> setLastActivityTime:nil];
<a name="l03010"></a>03010                         
<a name="l03011"></a>03011                         <span class="keywordflow">if</span> ([<span class="keyword">self</span> willAskDelegateForCredentials]) {
<a name="l03012"></a>03012 
<a name="l03013"></a>03013 <span class="preprocessor">                                #if DEBUG_HTTP_AUTHENTICATION</span>
<a name="l03014"></a>03014 <span class="preprocessor"></span>                                NSLog(<span class="stringliteral">@&quot;[AUTH] Request %@ will ask its delegate for credentials to use&quot;</span>,<span class="keyword">self</span>);
<a name="l03015"></a>03015 <span class="preprocessor">                                #endif</span>
<a name="l03016"></a>03016 <span class="preprocessor"></span>
<a name="l03017"></a>03017                                 [delegateAuthenticationLock unlock];
<a name="l03018"></a>03018                                 <span class="keywordflow">return</span>;
<a name="l03019"></a>03019                         }
<a name="l03020"></a>03020                         <span class="keywordflow">if</span> ([<span class="keyword">self</span> showAuthenticationDialog]) {
<a name="l03021"></a>03021 
<a name="l03022"></a>03022 <span class="preprocessor">                                #if DEBUG_HTTP_AUTHENTICATION</span>
<a name="l03023"></a>03023 <span class="preprocessor"></span>                                NSLog(<span class="stringliteral">@&quot;[AUTH] Request %@ will ask ASIAuthenticationDialog for credentials&quot;</span>,<span class="keyword">self</span>);
<a name="l03024"></a>03024 <span class="preprocessor">                                #endif</span>
<a name="l03025"></a>03025 <span class="preprocessor"></span>
<a name="l03026"></a>03026                                 [delegateAuthenticationLock unlock];
<a name="l03027"></a>03027                                 <span class="keywordflow">return</span>;
<a name="l03028"></a>03028                         }
<a name="l03029"></a>03029                         [delegateAuthenticationLock unlock];
<a name="l03030"></a>03030                 }
<a name="l03031"></a>03031 
<a name="l03032"></a>03032 <span class="preprocessor">                #if DEBUG_HTTP_AUTHENTICATION</span>
<a name="l03033"></a>03033 <span class="preprocessor"></span>                NSLog(<span class="stringliteral">@&quot;[AUTH] Request %@ has no credentials to present and must give up&quot;</span>,<span class="keyword">self</span>);
<a name="l03034"></a>03034 <span class="preprocessor">                #endif</span>
<a name="l03035"></a>03035 <span class="preprocessor"></span>
<a name="l03036"></a>03036                 [<span class="keyword">self</span> cancelLoad];
<a name="l03037"></a>03037                 [<span class="keyword">self</span> failWithError:ASIAuthenticationError];
<a name="l03038"></a>03038                 <span class="keywordflow">return</span>;
<a name="l03039"></a>03039         }
<a name="l03040"></a>03040         
<a name="l03041"></a>03041         [<span class="keyword">self</span> cancelLoad];
<a name="l03042"></a>03042         
<a name="l03043"></a>03043         <span class="keywordflow">if</span> (requestCredentials) {
<a name="l03044"></a>03044                 
<a name="l03045"></a>03045                 <span class="keywordflow">if</span> ((([<span class="keyword">self</span> authenticationScheme] != (<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)kCFHTTPAuthenticationSchemeNTLM) || [<span class="keyword">self</span> authenticationRetryCount] &lt; 2) &amp;&amp; [<span class="keyword">self</span> applyCredentials:requestCredentials]) {
<a name="l03046"></a>03046                         [<span class="keyword">self</span> startRequest];
<a name="l03047"></a>03047                         
<a name="l03048"></a>03048                         <span class="comment">// We&#39;ve failed NTLM authentication twice, we should assume our credentials are wrong</span>
<a name="l03049"></a>03049                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ([<span class="keyword">self</span> authenticationScheme] == (<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)kCFHTTPAuthenticationSchemeNTLM &amp;&amp; [<span class="keyword">self</span> authenticationRetryCount ] == 2) {
<a name="l03050"></a>03050 <span class="preprocessor">                        #if DEBUG_HTTP_AUTHENTICATION</span>
<a name="l03051"></a>03051 <span class="preprocessor"></span>                        NSLog(<span class="stringliteral">@&quot;[AUTH] Request %@ has failed NTLM authentication&quot;</span>,<span class="keyword">self</span>);
<a name="l03052"></a>03052 <span class="preprocessor">                        #endif</span>
<a name="l03053"></a>03053 <span class="preprocessor"></span>
<a name="l03054"></a>03054                         [<span class="keyword">self</span> failWithError:ASIAuthenticationError];
<a name="l03055"></a>03055                         
<a name="l03056"></a>03056                 } <span class="keywordflow">else</span> {
<a name="l03057"></a>03057 
<a name="l03058"></a>03058 <span class="preprocessor">                        #if DEBUG_HTTP_AUTHENTICATION</span>
<a name="l03059"></a>03059 <span class="preprocessor"></span>                        NSLog(<span class="stringliteral">@&quot;[AUTH] Request %@ had credentials and they were not marked as bad, but we got a 401 all the same.&quot;</span>,<span class="keyword">self</span>);
<a name="l03060"></a>03060 <span class="preprocessor">                        #endif</span>
<a name="l03061"></a>03061 <span class="preprocessor"></span>
<a name="l03062"></a>03062                         [<span class="keyword">self</span> failWithError:[NSError errorWithDomain:NetworkRequestErrorDomain code:ASIInternalErrorWhileApplyingCredentialsType userInfo:[NSDictionary dictionaryWithObjectsAndKeys:@&quot;Failed to apply credentials to request&quot;,NSLocalizedDescriptionKey,nil]]];
<a name="l03063"></a>03063                 }
<a name="l03064"></a>03064                 
<a name="l03065"></a>03065                 <span class="comment">// Are a user name &amp; password needed?</span>
<a name="l03066"></a>03066         }  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (CFHTTPAuthenticationRequiresUserNameAndPassword(requestAuthentication)) {
<a name="l03067"></a>03067                 
<a name="l03068"></a>03068                 <span class="comment">// Prevent more than one request from asking for credentials at once</span>
<a name="l03069"></a>03069                 [delegateAuthenticationLock lock];
<a name="l03070"></a>03070                 
<a name="l03071"></a>03071                 <span class="comment">// If the user cancelled authentication via a dialog presented by another request, our queue may have cancelled us</span>
<a name="l03072"></a>03072                 <span class="keywordflow">if</span> ([<span class="keyword">self</span> error] || [<span class="keyword">self</span> isCancelled]) {
<a name="l03073"></a>03073 
<a name="l03074"></a>03074 <span class="preprocessor">                        #if DEBUG_HTTP_AUTHENTICATION</span>
<a name="l03075"></a>03075 <span class="preprocessor"></span>                        NSLog(<span class="stringliteral">@&quot;[AUTH] Request %@ failed or was cancelled while waiting to access credentials&quot;</span>,<span class="keyword">self</span>);
<a name="l03076"></a>03076 <span class="preprocessor">                        #endif</span>
<a name="l03077"></a>03077 <span class="preprocessor"></span>
<a name="l03078"></a>03078                         [delegateAuthenticationLock unlock];
<a name="l03079"></a>03079                         <span class="keywordflow">return</span>;
<a name="l03080"></a>03080                 }
<a name="l03081"></a>03081                 
<a name="l03082"></a>03082                 <span class="comment">// Now we&#39;ve acquired the lock, it may be that the session contains credentials we can re-use for this request</span>
<a name="l03083"></a>03083                 <span class="keywordflow">if</span> ([<span class="keyword">self</span> useSessionPersistence]) {
<a name="l03084"></a>03084                         NSDictionary *credentials = [<span class="keyword">self</span> findSessionAuthenticationCredentials];
<a name="l03085"></a>03085                         <span class="keywordflow">if</span> (credentials &amp;&amp; [<span class="keyword">self</span> applyCredentials:[credentials objectForKey:<span class="stringliteral">@&quot;Credentials&quot;</span>]]) {
<a name="l03086"></a>03086 
<a name="l03087"></a>03087 <span class="preprocessor">                                #if DEBUG_HTTP_AUTHENTICATION</span>
<a name="l03088"></a>03088 <span class="preprocessor"></span>                                NSLog(<span class="stringliteral">@&quot;[AUTH] Request %@ will reuse cached credentials from the session (%@)&quot;</span>,<span class="keyword">self</span>,[credentials objectForKey:<span class="stringliteral">@&quot;AuthenticationScheme&quot;</span>]);
<a name="l03089"></a>03089 <span class="preprocessor">                                #endif</span>
<a name="l03090"></a>03090 <span class="preprocessor"></span>
<a name="l03091"></a>03091                                 [delegateAuthenticationLock unlock];
<a name="l03092"></a>03092                                 [<span class="keyword">self</span> startRequest];
<a name="l03093"></a>03093                                 <span class="keywordflow">return</span>;
<a name="l03094"></a>03094                         }
<a name="l03095"></a>03095                 }
<a name="l03096"></a>03096                 
<a name="l03097"></a>03097 
<a name="l03098"></a>03098                 NSMutableDictionary *newCredentials = [<span class="keyword">self</span> findCredentials];
<a name="l03099"></a>03099                 
<a name="l03100"></a>03100                 <span class="comment">//If we have some credentials to use let&#39;s apply them to the request and continue</span>
<a name="l03101"></a>03101                 <span class="keywordflow">if</span> (newCredentials) {
<a name="l03102"></a>03102                         
<a name="l03103"></a>03103                         <span class="keywordflow">if</span> ([<span class="keyword">self</span> applyCredentials:newCredentials]) {
<a name="l03104"></a>03104                                 [delegateAuthenticationLock unlock];
<a name="l03105"></a>03105                                 [<span class="keyword">self</span> startRequest];
<a name="l03106"></a>03106                         } <span class="keywordflow">else</span> {
<a name="l03107"></a>03107 <span class="preprocessor">                                #if DEBUG_HTTP_AUTHENTICATION</span>
<a name="l03108"></a>03108 <span class="preprocessor"></span>                                NSLog(<span class="stringliteral">@&quot;[AUTH] Request %@ failed to apply credentials&quot;</span>,<span class="keyword">self</span>);
<a name="l03109"></a>03109 <span class="preprocessor">                                #endif</span>
<a name="l03110"></a>03110 <span class="preprocessor"></span>                                [delegateAuthenticationLock unlock];
<a name="l03111"></a>03111                                 [<span class="keyword">self</span> failWithError:[NSError errorWithDomain:NetworkRequestErrorDomain code:ASIInternalErrorWhileApplyingCredentialsType userInfo:[NSDictionary dictionaryWithObjectsAndKeys:@&quot;Failed to apply credentials to request&quot;,NSLocalizedDescriptionKey,nil]]];
<a name="l03112"></a>03112                         }
<a name="l03113"></a>03113                         <span class="keywordflow">return</span>;
<a name="l03114"></a>03114                 }
<a name="l03115"></a>03115                 <span class="keywordflow">if</span> ([<span class="keyword">self</span> willAskDelegateForCredentials]) {
<a name="l03116"></a>03116 
<a name="l03117"></a>03117 <span class="preprocessor">                        #if DEBUG_HTTP_AUTHENTICATION</span>
<a name="l03118"></a>03118 <span class="preprocessor"></span>                        NSLog(<span class="stringliteral">@&quot;[AUTH] Request %@ will ask its delegate for credentials to use&quot;</span>,<span class="keyword">self</span>);
<a name="l03119"></a>03119 <span class="preprocessor">                        #endif</span>
<a name="l03120"></a>03120 <span class="preprocessor"></span>
<a name="l03121"></a>03121                         [delegateAuthenticationLock unlock];
<a name="l03122"></a>03122                         <span class="keywordflow">return</span>;
<a name="l03123"></a>03123                 }
<a name="l03124"></a>03124                 <span class="keywordflow">if</span> ([<span class="keyword">self</span> showAuthenticationDialog]) {
<a name="l03125"></a>03125 
<a name="l03126"></a>03126 <span class="preprocessor">                        #if DEBUG_HTTP_AUTHENTICATION</span>
<a name="l03127"></a>03127 <span class="preprocessor"></span>                        NSLog(<span class="stringliteral">@&quot;[AUTH] Request %@ will ask ASIAuthenticationDialog for credentials&quot;</span>,<span class="keyword">self</span>);
<a name="l03128"></a>03128 <span class="preprocessor">                        #endif</span>
<a name="l03129"></a>03129 <span class="preprocessor"></span>
<a name="l03130"></a>03130                         [delegateAuthenticationLock unlock];
<a name="l03131"></a>03131                         <span class="keywordflow">return</span>;
<a name="l03132"></a>03132                 }
<a name="l03133"></a>03133 
<a name="l03134"></a>03134 <span class="preprocessor">                #if DEBUG_HTTP_AUTHENTICATION</span>
<a name="l03135"></a>03135 <span class="preprocessor"></span>                NSLog(<span class="stringliteral">@&quot;[AUTH] Request %@ has no credentials to present and must give up&quot;</span>,<span class="keyword">self</span>);
<a name="l03136"></a>03136 <span class="preprocessor">                #endif</span>
<a name="l03137"></a>03137 <span class="preprocessor"></span>                [delegateAuthenticationLock unlock];
<a name="l03138"></a>03138                 [<span class="keyword">self</span> failWithError:ASIAuthenticationError];
<a name="l03139"></a>03139                 <span class="keywordflow">return</span>;
<a name="l03140"></a>03140         }
<a name="l03141"></a>03141         
<a name="l03142"></a>03142 }
<a name="l03143"></a>03143 
<a name="l03144"></a>03144 - (void)addBasicAuthenticationHeaderWithUsername:(<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)theUsername andPassword:(<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)thePassword
<a name="l03145"></a>03145 {
<a name="l03146"></a>03146         [<span class="keyword">self</span> addRequestHeader:@&quot;Authorization&quot; value:[<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> stringWithFormat:@&quot;Basic %@&quot;,[ASIHTTPRequest base64forData:[[<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> stringWithFormat:@&quot;%@:%@&quot;,theUsername,thePassword] dataUsingEncoding:NSUTF8StringEncoding]]]];    
<a name="l03147"></a>03147         [<span class="keyword">self</span> setAuthenticationScheme:(NSString *)kCFHTTPAuthenticationSchemeBasic];
<a name="l03148"></a>03148 
<a name="l03149"></a>03149 }
<a name="l03150"></a>03150 
<a name="l03151"></a>03151 
<a name="l03152"></a>03152 <span class="preprocessor">#pragma mark stream status handlers</span>
<a name="l03153"></a>03153 <span class="preprocessor"></span>
<a name="l03154"></a>03154 - (void)handleNetworkEvent:(CFStreamEventType)type
<a name="l03155"></a>03155 {       
<a name="l03156"></a>03156         NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
<a name="l03157"></a>03157 
<a name="l03158"></a>03158         [[<span class="keyword">self</span> cancelledLock] lock];
<a name="l03159"></a>03159         
<a name="l03160"></a>03160         <span class="keywordflow">if</span> ([<span class="keyword">self</span> complete] || [<span class="keyword">self</span> isCancelled]) {
<a name="l03161"></a>03161                 [[<span class="keyword">self</span> cancelledLock] unlock];
<a name="l03162"></a>03162                 [pool release];
<a name="l03163"></a>03163                 <span class="keywordflow">return</span>;
<a name="l03164"></a>03164         }
<a name="l03165"></a>03165 
<a name="l03166"></a>03166         CFRetain(<span class="keyword">self</span>);
<a name="l03167"></a>03167 
<a name="l03168"></a>03168     <span class="comment">// Dispatch the stream events.</span>
<a name="l03169"></a>03169     <span class="keywordflow">switch</span> (type) {
<a name="l03170"></a>03170         <span class="keywordflow">case</span> kCFStreamEventHasBytesAvailable:
<a name="l03171"></a>03171             [<span class="keyword">self</span> handleBytesAvailable];
<a name="l03172"></a>03172             <span class="keywordflow">break</span>;
<a name="l03173"></a>03173             
<a name="l03174"></a>03174         <span class="keywordflow">case</span> kCFStreamEventEndEncountered:
<a name="l03175"></a>03175             [<span class="keyword">self</span> handleStreamComplete];
<a name="l03176"></a>03176             <span class="keywordflow">break</span>;
<a name="l03177"></a>03177             
<a name="l03178"></a>03178         <span class="keywordflow">case</span> kCFStreamEventErrorOccurred:
<a name="l03179"></a>03179             [<span class="keyword">self</span> handleStreamError];
<a name="l03180"></a>03180             <span class="keywordflow">break</span>;
<a name="l03181"></a>03181             
<a name="l03182"></a>03182         <span class="keywordflow">default</span>:
<a name="l03183"></a>03183             <span class="keywordflow">break</span>;
<a name="l03184"></a>03184     }
<a name="l03185"></a>03185         
<a name="l03186"></a>03186         [<span class="keyword">self</span> performThrottling];
<a name="l03187"></a>03187         
<a name="l03188"></a>03188         [[<span class="keyword">self</span> cancelledLock] unlock];
<a name="l03189"></a>03189         
<a name="l03190"></a>03190         <span class="keywordflow">if</span> ([<span class="keyword">self</span> downloadComplete] &amp;&amp; [<span class="keyword">self</span> needsRedirect]) {
<a name="l03191"></a>03191                 <span class="keywordflow">if</span> (![<span class="keyword">self</span> willAskDelegateToConfirmRedirect]) {
<a name="l03192"></a>03192                         [<span class="keyword">self</span> performRedirect];
<a name="l03193"></a>03193                 }
<a name="l03194"></a>03194         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ([<span class="keyword">self</span> downloadComplete] &amp;&amp; [<span class="keyword">self</span> authenticationNeeded]) {
<a name="l03195"></a>03195                 [<span class="keyword">self</span> attemptToApplyCredentialsAndResume];
<a name="l03196"></a>03196         }
<a name="l03197"></a>03197 
<a name="l03198"></a>03198         CFRelease(<span class="keyword">self</span>);
<a name="l03199"></a>03199         [pool release];
<a name="l03200"></a>03200 }
<a name="l03201"></a>03201 
<a name="l03202"></a>03202 - (BOOL)willAskDelegateToConfirmRedirect
<a name="l03203"></a>03203 {
<a name="l03204"></a>03204         <span class="comment">// We must lock to ensure delegate / queue aren&#39;t changed while we check them</span>
<a name="l03205"></a>03205         [[<span class="keyword">self</span> cancelledLock] lock];
<a name="l03206"></a>03206 
<a name="l03207"></a>03207         <span class="comment">// Here we perform an initial check to see if either the delegate or the queue wants to be asked about the redirect, because if not we should redirect straight away</span>
<a name="l03208"></a>03208         <span class="comment">// We will check again on the main thread later</span>
<a name="l03209"></a>03209         BOOL needToAskDelegateAboutRedirect = (([<span class="keyword">self</span> delegate] &amp;&amp; [[<span class="keyword">self</span> delegate] respondsToSelector:[<span class="keyword">self</span> willRedirectSelector]]) || ([<span class="keyword">self</span> queue] &amp;&amp; [[<span class="keyword">self</span> queue] respondsToSelector:<span class="keyword">@selector</span>(request:willRedirectToURL:)]));
<a name="l03210"></a>03210 
<a name="l03211"></a>03211         [[<span class="keyword">self</span> cancelledLock] unlock];
<a name="l03212"></a>03212 
<a name="l03213"></a>03213         <span class="comment">// Either the delegate or the queue&#39;s delegate is interested in being told when we are about to redirect</span>
<a name="l03214"></a>03214         <span class="keywordflow">if</span> (needToAskDelegateAboutRedirect) {
<a name="l03215"></a>03215                 NSURL *newURL = [[[<span class="keyword">self</span> redirectURL] copy] autorelease];
<a name="l03216"></a>03216                 [<span class="keyword">self</span> setRedirectURL:nil];
<a name="l03217"></a>03217                 [<span class="keyword">self</span> performSelectorOnMainThread:@selector(requestWillRedirectToURL:) withObject:newURL waitUntilDone:[NSThread isMainThread]];
<a name="l03218"></a>03218                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l03219"></a>03219         }
<a name="l03220"></a>03220         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03221"></a>03221 }
<a name="l03222"></a>03222 
<a name="l03223"></a>03223 - (void)handleBytesAvailable
<a name="l03224"></a>03224 {
<a name="l03225"></a>03225         <span class="keywordflow">if</span> (![<span class="keyword">self</span> responseHeaders]) {
<a name="l03226"></a>03226                 [<span class="keyword">self</span> readResponseHeaders];
<a name="l03227"></a>03227         }
<a name="l03228"></a>03228         
<a name="l03229"></a>03229         <span class="comment">// If we&#39;ve cancelled the load part way through (for example, after deciding to use a cached version)</span>
<a name="l03230"></a>03230         <span class="keywordflow">if</span> ([<span class="keyword">self</span> complete]) {
<a name="l03231"></a>03231                 <span class="keywordflow">return</span>;
<a name="l03232"></a>03232         }
<a name="l03233"></a>03233         
<a name="l03234"></a>03234         <span class="comment">// In certain (presumably very rare) circumstances, handleBytesAvailable seems to be called when there isn&#39;t actually any data available</span>
<a name="l03235"></a>03235         <span class="comment">// We&#39;ll check that there is actually data available to prevent blocking on CFReadStreamRead()</span>
<a name="l03236"></a>03236         <span class="comment">// So far, I&#39;ve only seen this in the stress tests, so it might never happen in real-world situations.</span>
<a name="l03237"></a>03237         <span class="keywordflow">if</span> (!CFReadStreamHasBytesAvailable((CFReadStreamRef)[<span class="keyword">self</span> readStream])) {
<a name="l03238"></a>03238                 <span class="keywordflow">return</span>;
<a name="l03239"></a>03239         }
<a name="l03240"></a>03240 
<a name="l03241"></a>03241         <span class="keywordtype">long</span> <span class="keywordtype">long</span> bufferSize = 16384;
<a name="l03242"></a>03242         <span class="keywordflow">if</span> (contentLength &gt; 262144) {
<a name="l03243"></a>03243                 bufferSize = 262144;
<a name="l03244"></a>03244         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (contentLength &gt; 65536) {
<a name="l03245"></a>03245                 bufferSize = 65536;
<a name="l03246"></a>03246         }
<a name="l03247"></a>03247         
<a name="l03248"></a>03248         <span class="comment">// Reduce the buffer size if we&#39;re receiving data too quickly when bandwidth throttling is active</span>
<a name="l03249"></a>03249         <span class="comment">// This just augments the throttling done in measureBandwidthUsage to reduce the amount we go over the limit</span>
<a name="l03250"></a>03250         
<a name="l03251"></a>03251         <span class="keywordflow">if</span> ([[<span class="keyword">self</span> <span class="keyword">class</span>] isBandwidthThrottled]) {
<a name="l03252"></a>03252                 [bandwidthThrottlingLock lock];
<a name="l03253"></a>03253                 <span class="keywordflow">if</span> (maxBandwidthPerSecond &gt; 0) {
<a name="l03254"></a>03254                         <span class="keywordtype">long</span> <span class="keywordtype">long</span> maxiumumSize  = (<span class="keywordtype">long</span> long)maxBandwidthPerSecond-(<span class="keywordtype">long</span> <span class="keywordtype">long</span>)bandwidthUsedInLastSecond;
<a name="l03255"></a>03255                         <span class="keywordflow">if</span> (maxiumumSize &lt; 0) {
<a name="l03256"></a>03256                                 <span class="comment">// We aren&#39;t supposed to read any more data right now, but we&#39;ll read a single byte anyway so the CFNetwork&#39;s buffer isn&#39;t full</span>
<a name="l03257"></a>03257                                 bufferSize = 1;
<a name="l03258"></a>03258                         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (maxiumumSize/4 &lt; bufferSize) {
<a name="l03259"></a>03259                                 <span class="comment">// We were going to fetch more data that we should be allowed, so we&#39;ll reduce the size of our read</span>
<a name="l03260"></a>03260                                 bufferSize = maxiumumSize/4;
<a name="l03261"></a>03261                         }
<a name="l03262"></a>03262                 }
<a name="l03263"></a>03263                 <span class="keywordflow">if</span> (bufferSize &lt; 1) {
<a name="l03264"></a>03264                         bufferSize = 1;
<a name="l03265"></a>03265                 }
<a name="l03266"></a>03266                 [bandwidthThrottlingLock unlock];
<a name="l03267"></a>03267         }
<a name="l03268"></a>03268         
<a name="l03269"></a>03269         
<a name="l03270"></a>03270     UInt8 buffer[bufferSize];
<a name="l03271"></a>03271     NSInteger bytesRead = [[<span class="keyword">self</span> readStream] read:buffer maxLength:sizeof(buffer)];
<a name="l03272"></a>03272 
<a name="l03273"></a>03273     <span class="comment">// Less than zero is an error</span>
<a name="l03274"></a>03274     <span class="keywordflow">if</span> (bytesRead &lt; 0) {
<a name="l03275"></a>03275         [<span class="keyword">self</span> handleStreamError];
<a name="l03276"></a>03276                 
<a name="l03277"></a>03277         <span class="comment">// If zero bytes were read, wait for the EOF to come.</span>
<a name="l03278"></a>03278     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bytesRead) {
<a name="l03279"></a>03279 
<a name="l03280"></a>03280                 <span class="comment">// If we are inflating the response on the fly</span>
<a name="l03281"></a>03281                 <a class="code" href="class_n_s_data.html" title="For hashing raw data.">NSData</a> *inflatedData = nil;
<a name="l03282"></a>03282                 <span class="keywordflow">if</span> ([<span class="keyword">self</span> isResponseCompressed] &amp;&amp; ![<span class="keyword">self</span> shouldWaitToInflateCompressedResponses]) {
<a name="l03283"></a>03283                         <span class="keywordflow">if</span> (![<span class="keyword">self</span> dataDecompressor]) {
<a name="l03284"></a>03284                                 [<span class="keyword">self</span> setDataDecompressor:[ASIDataDecompressor decompressor]];
<a name="l03285"></a>03285                         }
<a name="l03286"></a>03286                         NSError *err = nil;
<a name="l03287"></a>03287                         inflatedData = [[<span class="keyword">self</span> dataDecompressor] uncompressBytes:buffer length:bytesRead error:&amp;err];
<a name="l03288"></a>03288                         <span class="keywordflow">if</span> (err) {
<a name="l03289"></a>03289                                 [<span class="keyword">self</span> failWithError:err];
<a name="l03290"></a>03290                                 <span class="keywordflow">return</span>;
<a name="l03291"></a>03291                         }
<a name="l03292"></a>03292                 }
<a name="l03293"></a>03293                 
<a name="l03294"></a>03294                 [<span class="keyword">self</span> setTotalBytesRead:[<span class="keyword">self</span> totalBytesRead]+bytesRead];
<a name="l03295"></a>03295                 [<span class="keyword">self</span> setLastActivityTime:[NSDate date]];
<a name="l03296"></a>03296 
<a name="l03297"></a>03297                 <span class="comment">// For bandwidth measurement / throttling</span>
<a name="l03298"></a>03298                 [ASIHTTPRequest incrementBandwidthUsedInLastSecond:bytesRead];
<a name="l03299"></a>03299                 
<a name="l03300"></a>03300                 <span class="comment">// If we need to redirect, and have automatic redirect on, and might be resuming a download, let&#39;s do nothing with the content</span>
<a name="l03301"></a>03301                 <span class="keywordflow">if</span> ([<span class="keyword">self</span> needsRedirect] &amp;&amp; [<span class="keyword">self</span> shouldRedirect] &amp;&amp; [<span class="keyword">self</span> allowResumeForFileDownloads]) {
<a name="l03302"></a>03302                         <span class="keywordflow">return</span>;
<a name="l03303"></a>03303                 }
<a name="l03304"></a>03304                 
<a name="l03305"></a>03305                 BOOL dataWillBeHandledExternally = NO;
<a name="l03306"></a>03306                 <span class="keywordflow">if</span> ([[<span class="keyword">self</span> delegate] respondsToSelector:[<span class="keyword">self</span> didReceiveDataSelector]]) {
<a name="l03307"></a>03307                         dataWillBeHandledExternally = YES;
<a name="l03308"></a>03308                 }
<a name="l03309"></a>03309 <span class="preprocessor">                #if NS_BLOCKS_AVAILABLE</span>
<a name="l03310"></a>03310 <span class="preprocessor"></span>                <span class="keywordflow">if</span> (dataReceivedBlock) {
<a name="l03311"></a>03311                         dataWillBeHandledExternally = YES;
<a name="l03312"></a>03312                 }
<a name="l03313"></a>03313 <span class="preprocessor">                #endif</span>
<a name="l03314"></a>03314 <span class="preprocessor"></span>                <span class="comment">// Does the delegate want to handle the data manually?</span>
<a name="l03315"></a>03315                 <span class="keywordflow">if</span> (dataWillBeHandledExternally) {
<a name="l03316"></a>03316 
<a name="l03317"></a>03317                         <a class="code" href="class_n_s_data.html" title="For hashing raw data.">NSData</a> *data = nil;
<a name="l03318"></a>03318                         <span class="keywordflow">if</span> ([<span class="keyword">self</span> isResponseCompressed] &amp;&amp; ![<span class="keyword">self</span> shouldWaitToInflateCompressedResponses]) {
<a name="l03319"></a>03319                                 data = inflatedData;
<a name="l03320"></a>03320                         } <span class="keywordflow">else</span> {
<a name="l03321"></a>03321                                 data = [<a class="code" href="class_n_s_data.html" title="For hashing raw data.">NSData</a> dataWithBytes:buffer length:bytesRead];
<a name="l03322"></a>03322                         }
<a name="l03323"></a>03323                         [<span class="keyword">self</span> performSelectorOnMainThread:@selector(passOnReceivedData:) withObject:data waitUntilDone:[NSThread isMainThread]];
<a name="l03324"></a>03324                         
<a name="l03325"></a>03325                 <span class="comment">// Are we downloading to a file?</span>
<a name="l03326"></a>03326                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ([<span class="keyword">self</span> downloadDestinationPath]) {
<a name="l03327"></a>03327                         BOOL append = NO;
<a name="l03328"></a>03328                         <span class="keywordflow">if</span> (![<span class="keyword">self</span> fileDownloadOutputStream]) {
<a name="l03329"></a>03329                                 <span class="keywordflow">if</span> (![<span class="keyword">self</span> temporaryFileDownloadPath]) {
<a name="l03330"></a>03330                                         [<span class="keyword">self</span> setTemporaryFileDownloadPath:[NSTemporaryDirectory() stringByAppendingPathComponent:[[NSProcessInfo processInfo] globallyUniqueString]]];
<a name="l03331"></a>03331                                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ([<span class="keyword">self</span> allowResumeForFileDownloads] &amp;&amp; [[<span class="keyword">self</span> requestHeaders] objectForKey:<span class="stringliteral">@&quot;Range&quot;</span>]) {
<a name="l03332"></a>03332                                         <span class="keywordflow">if</span> ([[<span class="keyword">self</span> responseHeaders] objectForKey:<span class="stringliteral">@&quot;Content-Range&quot;</span>]) {
<a name="l03333"></a>03333                                                 append = YES;
<a name="l03334"></a>03334                                         } <span class="keywordflow">else</span> {
<a name="l03335"></a>03335                                                 [<span class="keyword">self</span> incrementDownloadSizeBy:-[<span class="keyword">self</span> partialDownloadSize]];
<a name="l03336"></a>03336                                                 [<span class="keyword">self</span> setPartialDownloadSize:0];
<a name="l03337"></a>03337                                         }
<a name="l03338"></a>03338                                 }
<a name="l03339"></a>03339 
<a name="l03340"></a>03340                                 [<span class="keyword">self</span> setFileDownloadOutputStream:[[[NSOutputStream alloc] initToFileAtPath:[<span class="keyword">self</span> temporaryFileDownloadPath] append:append] autorelease]];
<a name="l03341"></a>03341                                 [[<span class="keyword">self</span> fileDownloadOutputStream] open];
<a name="l03342"></a>03342 
<a name="l03343"></a>03343                         }
<a name="l03344"></a>03344                         [[<span class="keyword">self</span> fileDownloadOutputStream] write:buffer maxLength:bytesRead];
<a name="l03345"></a>03345 
<a name="l03346"></a>03346                         <span class="keywordflow">if</span> ([<span class="keyword">self</span> isResponseCompressed] &amp;&amp; ![<span class="keyword">self</span> shouldWaitToInflateCompressedResponses]) {
<a name="l03347"></a>03347                                 
<a name="l03348"></a>03348                                 <span class="keywordflow">if</span> (![<span class="keyword">self</span> inflatedFileDownloadOutputStream]) {
<a name="l03349"></a>03349                                         <span class="keywordflow">if</span> (![<span class="keyword">self</span> temporaryUncompressedDataDownloadPath]) {
<a name="l03350"></a>03350                                                 [<span class="keyword">self</span> setTemporaryUncompressedDataDownloadPath:[NSTemporaryDirectory() stringByAppendingPathComponent:[[NSProcessInfo processInfo] globallyUniqueString]]];
<a name="l03351"></a>03351                                         }
<a name="l03352"></a>03352                                         
<a name="l03353"></a>03353                                         [<span class="keyword">self</span> setInflatedFileDownloadOutputStream:[[[NSOutputStream alloc] initToFileAtPath:[<span class="keyword">self</span> temporaryUncompressedDataDownloadPath] append:append] autorelease]];
<a name="l03354"></a>03354                                         [[<span class="keyword">self</span> inflatedFileDownloadOutputStream] open];
<a name="l03355"></a>03355                                 }
<a name="l03356"></a>03356 
<a name="l03357"></a>03357                                 [[<span class="keyword">self</span> inflatedFileDownloadOutputStream] write:[inflatedData bytes] maxLength:[inflatedData length]];
<a name="l03358"></a>03358                         }
<a name="l03359"></a>03359 
<a name="l03360"></a>03360                         
<a name="l03361"></a>03361                 <span class="comment">//Otherwise, let&#39;s add the data to our in-memory store</span>
<a name="l03362"></a>03362                 } <span class="keywordflow">else</span> {
<a name="l03363"></a>03363                         <span class="keywordflow">if</span> ([<span class="keyword">self</span> isResponseCompressed] &amp;&amp; ![<span class="keyword">self</span> shouldWaitToInflateCompressedResponses]) {
<a name="l03364"></a>03364                                 [rawResponseData appendData:inflatedData];
<a name="l03365"></a>03365                         } <span class="keywordflow">else</span> {
<a name="l03366"></a>03366                                 [rawResponseData appendBytes:buffer length:bytesRead];
<a name="l03367"></a>03367                         }
<a name="l03368"></a>03368                 }
<a name="l03369"></a>03369     }
<a name="l03370"></a>03370 }
<a name="l03371"></a>03371 
<a name="l03372"></a>03372 - (void)handleStreamComplete
<a name="l03373"></a>03373 {       
<a name="l03374"></a>03374 
<a name="l03375"></a>03375 <span class="preprocessor">#if DEBUG_REQUEST_STATUS</span>
<a name="l03376"></a>03376 <span class="preprocessor"></span>        NSLog(<span class="stringliteral">@&quot;[STATUS] Request %@ finished downloading data (%qu bytes)&quot;</span>,<span class="keyword">self</span>, [<span class="keyword">self</span> totalBytesRead]);
<a name="l03377"></a>03377 <span class="preprocessor">#endif</span>
<a name="l03378"></a>03378 <span class="preprocessor"></span>        [<span class="keyword">self</span> setStatusTimer:nil];
<a name="l03379"></a>03379         [<span class="keyword">self</span> setDownloadComplete:YES];
<a name="l03380"></a>03380         
<a name="l03381"></a>03381         <span class="keywordflow">if</span> (![<span class="keyword">self</span> responseHeaders]) {
<a name="l03382"></a>03382                 [<span class="keyword">self</span> readResponseHeaders];
<a name="l03383"></a>03383         }
<a name="l03384"></a>03384 
<a name="l03385"></a>03385         [progressLock lock];    
<a name="l03386"></a>03386         <span class="comment">// Find out how much data we&#39;ve uploaded so far</span>
<a name="l03387"></a>03387         [<span class="keyword">self</span> setLastBytesSent:totalBytesSent]; 
<a name="l03388"></a>03388         [<span class="keyword">self</span> setTotalBytesSent:[NSMakeCollectable([(NSNumber *)CFReadStreamCopyProperty((CFReadStreamRef)[<span class="keyword">self</span> readStream], kCFStreamPropertyHTTPRequestBytesWrittenCount) autorelease]) unsignedLongLongValue]];
<a name="l03389"></a>03389         [<span class="keyword">self</span> setComplete:YES];
<a name="l03390"></a>03390         <span class="keywordflow">if</span> (![<span class="keyword">self</span> contentLength]) {
<a name="l03391"></a>03391                 [<span class="keyword">self</span> setContentLength:[<span class="keyword">self</span> totalBytesRead]];
<a name="l03392"></a>03392         }
<a name="l03393"></a>03393         [<span class="keyword">self</span> updateProgressIndicators];
<a name="l03394"></a>03394 
<a name="l03395"></a>03395         
<a name="l03396"></a>03396         [[<span class="keyword">self</span> postBodyReadStream] close];
<a name="l03397"></a>03397         [<span class="keyword">self</span> setPostBodyReadStream:nil];
<a name="l03398"></a>03398         
<a name="l03399"></a>03399         [<span class="keyword">self</span> setDataDecompressor:nil];
<a name="l03400"></a>03400 
<a name="l03401"></a>03401         NSError *fileError = nil;
<a name="l03402"></a>03402         
<a name="l03403"></a>03403         <span class="comment">// Delete up the request body temporary file, if it exists</span>
<a name="l03404"></a>03404         <span class="keywordflow">if</span> ([<span class="keyword">self</span> didCreateTemporaryPostDataFile] &amp;&amp; ![<span class="keyword">self</span> authenticationNeeded]) {
<a name="l03405"></a>03405                 [<span class="keyword">self</span> removeTemporaryUploadFile];
<a name="l03406"></a>03406                 [<span class="keyword">self</span> removeTemporaryCompressedUploadFile];
<a name="l03407"></a>03407         }
<a name="l03408"></a>03408         
<a name="l03409"></a>03409         <span class="comment">// Close the output stream as we&#39;re done writing to the file</span>
<a name="l03410"></a>03410         <span class="keywordflow">if</span> ([<span class="keyword">self</span> temporaryFileDownloadPath]) {
<a name="l03411"></a>03411                 
<a name="l03412"></a>03412                 [[<span class="keyword">self</span> fileDownloadOutputStream] close];
<a name="l03413"></a>03413                 [<span class="keyword">self</span> setFileDownloadOutputStream:nil];
<a name="l03414"></a>03414 
<a name="l03415"></a>03415                 [[<span class="keyword">self</span> inflatedFileDownloadOutputStream] close];
<a name="l03416"></a>03416                 [<span class="keyword">self</span> setInflatedFileDownloadOutputStream:nil];
<a name="l03417"></a>03417 
<a name="l03418"></a>03418                 <span class="comment">// If we are going to redirect and we are resuming, let&#39;s ignore this download</span>
<a name="l03419"></a>03419                 <span class="keywordflow">if</span> ([<span class="keyword">self</span> shouldRedirect] &amp;&amp; [<span class="keyword">self</span> needsRedirect] &amp;&amp; [<span class="keyword">self</span> allowResumeForFileDownloads]) {
<a name="l03420"></a>03420                 
<a name="l03421"></a>03421                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ([<span class="keyword">self</span> isResponseCompressed]) {
<a name="l03422"></a>03422                         
<a name="l03423"></a>03423                         <span class="comment">// Decompress the file directly to the destination path</span>
<a name="l03424"></a>03424                         <span class="keywordflow">if</span> ([<span class="keyword">self</span> shouldWaitToInflateCompressedResponses]) {
<a name="l03425"></a>03425                                 [ASIDataDecompressor uncompressDataFromFile:[<span class="keyword">self</span> temporaryFileDownloadPath] toFile:[<span class="keyword">self</span> downloadDestinationPath] error:&amp;fileError];
<a name="l03426"></a>03426 
<a name="l03427"></a>03427                         <span class="comment">// Response should already have been inflated, move the temporary file to the destination path</span>
<a name="l03428"></a>03428                         } <span class="keywordflow">else</span> {
<a name="l03429"></a>03429                                 NSError *moveError = nil;
<a name="l03430"></a>03430                                 [[[[NSFileManager alloc] init] autorelease] moveItemAtPath:[<span class="keyword">self</span> temporaryUncompressedDataDownloadPath] toPath:[<span class="keyword">self</span> downloadDestinationPath] error:&amp;moveError];
<a name="l03431"></a>03431                                 <span class="keywordflow">if</span> (moveError) {
<a name="l03432"></a>03432                                         fileError = [NSError errorWithDomain:NetworkRequestErrorDomain code:ASIFileManagementError userInfo:[NSDictionary dictionaryWithObjectsAndKeys:[<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> stringWithFormat:@&quot;Failed to move file from &#39;%@&#39; to &#39;%@&#39;&quot;,[<span class="keyword">self</span> temporaryFileDownloadPath],[<span class="keyword">self</span> downloadDestinationPath]],NSLocalizedDescriptionKey,moveError,NSUnderlyingErrorKey,nil]];
<a name="l03433"></a>03433                                 }
<a name="l03434"></a>03434                                 [<span class="keyword">self</span> setTemporaryUncompressedDataDownloadPath:nil];
<a name="l03435"></a>03435 
<a name="l03436"></a>03436                         }
<a name="l03437"></a>03437                         [<span class="keyword">self</span> removeTemporaryDownloadFile];
<a name="l03438"></a>03438 
<a name="l03439"></a>03439                 } <span class="keywordflow">else</span> {
<a name="l03440"></a>03440         
<a name="l03441"></a>03441                         <span class="comment">//Remove any file at the destination path</span>
<a name="l03442"></a>03442                         NSError *moveError = nil;
<a name="l03443"></a>03443                         <span class="keywordflow">if</span> (![[<span class="keyword">self</span> <span class="keyword">class</span>] removeFileAtPath:[<span class="keyword">self</span> downloadDestinationPath] error:&amp;moveError]) {
<a name="l03444"></a>03444                                 fileError = moveError;
<a name="l03445"></a>03445 
<a name="l03446"></a>03446                         }
<a name="l03447"></a>03447 
<a name="l03448"></a>03448                         <span class="comment">//Move the temporary file to the destination path</span>
<a name="l03449"></a>03449                         <span class="keywordflow">if</span> (!fileError) {
<a name="l03450"></a>03450                                 [[[[NSFileManager alloc] init] autorelease] moveItemAtPath:[<span class="keyword">self</span> temporaryFileDownloadPath] toPath:[<span class="keyword">self</span> downloadDestinationPath] error:&amp;moveError];
<a name="l03451"></a>03451                                 <span class="keywordflow">if</span> (moveError) {
<a name="l03452"></a>03452                                         fileError = [NSError errorWithDomain:NetworkRequestErrorDomain code:ASIFileManagementError userInfo:[NSDictionary dictionaryWithObjectsAndKeys:[<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> stringWithFormat:@&quot;Failed to move file from &#39;%@&#39; to &#39;%@&#39;&quot;,[<span class="keyword">self</span> temporaryFileDownloadPath],[<span class="keyword">self</span> downloadDestinationPath]],NSLocalizedDescriptionKey,moveError,NSUnderlyingErrorKey,nil]];
<a name="l03453"></a>03453                                 }
<a name="l03454"></a>03454                                 [<span class="keyword">self</span> setTemporaryFileDownloadPath:nil];
<a name="l03455"></a>03455                         }
<a name="l03456"></a>03456                         
<a name="l03457"></a>03457                 }
<a name="l03458"></a>03458         }
<a name="l03459"></a>03459         
<a name="l03460"></a>03460         <span class="comment">// Save to the cache</span>
<a name="l03461"></a>03461         <span class="keywordflow">if</span> ([<span class="keyword">self</span> downloadCache] &amp;&amp; ![<span class="keyword">self</span> didUseCachedResponse]) {
<a name="l03462"></a>03462                 [[<span class="keyword">self</span> downloadCache] storeResponseForRequest:self maxAge:[<span class="keyword">self</span> secondsToCache]];
<a name="l03463"></a>03463         }
<a name="l03464"></a>03464         
<a name="l03465"></a>03465         [progressLock unlock];
<a name="l03466"></a>03466 
<a name="l03467"></a>03467         
<a name="l03468"></a>03468         [connectionsLock lock];
<a name="l03469"></a>03469         <span class="keywordflow">if</span> (![<span class="keyword">self</span> connectionCanBeReused]) {
<a name="l03470"></a>03470                 [<span class="keyword">self</span> unscheduleReadStream];
<a name="l03471"></a>03471         }
<a name="l03472"></a>03472 <span class="preprocessor">        #if DEBUG_PERSISTENT_CONNECTIONS</span>
<a name="l03473"></a>03473 <span class="preprocessor"></span>        <span class="keywordflow">if</span> ([<span class="keyword">self</span> requestID]) {
<a name="l03474"></a>03474                 NSLog(<span class="stringliteral">@&quot;[CONNECTION] Request #%@ finished using connection #%@&quot;</span>,[<span class="keyword">self</span> requestID], [[<span class="keyword">self</span> connectionInfo] objectForKey:<span class="stringliteral">@&quot;id&quot;</span>]);
<a name="l03475"></a>03475         }
<a name="l03476"></a>03476 <span class="preprocessor">        #endif</span>
<a name="l03477"></a>03477 <span class="preprocessor"></span>        [[<span class="keyword">self</span> connectionInfo] removeObjectForKey:@&quot;request&quot;];
<a name="l03478"></a>03478         [[<span class="keyword">self</span> connectionInfo] setObject:[NSDate dateWithTimeIntervalSinceNow:[<span class="keyword">self</span> persistentConnectionTimeoutSeconds]] forKey:@&quot;expires&quot;];
<a name="l03479"></a>03479         [connectionsLock unlock];
<a name="l03480"></a>03480         
<a name="l03481"></a>03481         <span class="keywordflow">if</span> (![<span class="keyword">self</span> authenticationNeeded]) {
<a name="l03482"></a>03482                 [<span class="keyword">self</span> destroyReadStream];
<a name="l03483"></a>03483         }
<a name="l03484"></a>03484         
<a name="l03485"></a>03485 
<a name="l03486"></a>03486         <span class="keywordflow">if</span> (![<span class="keyword">self</span> needsRedirect] &amp;&amp; ![<span class="keyword">self</span> authenticationNeeded] &amp;&amp; ![<span class="keyword">self</span> didUseCachedResponse]) {
<a name="l03487"></a>03487                 
<a name="l03488"></a>03488                 <span class="keywordflow">if</span> (fileError) {
<a name="l03489"></a>03489                         [<span class="keyword">self</span> failWithError:fileError];
<a name="l03490"></a>03490                 } <span class="keywordflow">else</span> {
<a name="l03491"></a>03491                         [<span class="keyword">self</span> requestFinished];
<a name="l03492"></a>03492                 }
<a name="l03493"></a>03493 
<a name="l03494"></a>03494                 [<span class="keyword">self</span> markAsFinished];
<a name="l03495"></a>03495                 
<a name="l03496"></a>03496         <span class="comment">// If request has asked delegate or ASIAuthenticationDialog for credentials</span>
<a name="l03497"></a>03497         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ([<span class="keyword">self</span> authenticationNeeded]) {
<a name="l03498"></a>03498                 CFRunLoopStop(CFRunLoopGetCurrent());
<a name="l03499"></a>03499         }
<a name="l03500"></a>03500 
<a name="l03501"></a>03501 }
<a name="l03502"></a>03502 
<a name="l03503"></a>03503 - (void)markAsFinished
<a name="l03504"></a>03504 {
<a name="l03505"></a>03505         <span class="comment">// Autoreleased requests may well be dealloced here otherwise</span>
<a name="l03506"></a>03506         CFRetain(<span class="keyword">self</span>);
<a name="l03507"></a>03507 
<a name="l03508"></a>03508         <span class="comment">// dealloc won&#39;t be called when running with GC, so we&#39;ll clean these up now</span>
<a name="l03509"></a>03509         <span class="keywordflow">if</span> (request) {
<a name="l03510"></a>03510                 CFMakeCollectable(request);
<a name="l03511"></a>03511         }
<a name="l03512"></a>03512         <span class="keywordflow">if</span> (requestAuthentication) {
<a name="l03513"></a>03513                 CFMakeCollectable(requestAuthentication);
<a name="l03514"></a>03514         }
<a name="l03515"></a>03515         <span class="keywordflow">if</span> (proxyAuthentication) {
<a name="l03516"></a>03516                 CFMakeCollectable(proxyAuthentication);
<a name="l03517"></a>03517         }
<a name="l03518"></a>03518 
<a name="l03519"></a>03519     BOOL wasInProgress = inProgress;
<a name="l03520"></a>03520     BOOL wasFinished = finished;
<a name="l03521"></a>03521 
<a name="l03522"></a>03522     <span class="keywordflow">if</span> (!wasFinished)
<a name="l03523"></a>03523         [<span class="keyword">self</span> willChangeValueForKey:@&quot;isFinished&quot;];
<a name="l03524"></a>03524     <span class="keywordflow">if</span> (wasInProgress)
<a name="l03525"></a>03525         [<span class="keyword">self</span> willChangeValueForKey:@&quot;isExecuting&quot;];
<a name="l03526"></a>03526 
<a name="l03527"></a>03527         [<span class="keyword">self</span> setInProgress:NO];
<a name="l03528"></a>03528     finished = YES;
<a name="l03529"></a>03529 
<a name="l03530"></a>03530     <span class="keywordflow">if</span> (wasInProgress)
<a name="l03531"></a>03531         [<span class="keyword">self</span> didChangeValueForKey:@&quot;isExecuting&quot;];
<a name="l03532"></a>03532     <span class="keywordflow">if</span> (!wasFinished)
<a name="l03533"></a>03533         [<span class="keyword">self</span> didChangeValueForKey:@&quot;isFinished&quot;];
<a name="l03534"></a>03534 
<a name="l03535"></a>03535         CFRunLoopStop(CFRunLoopGetCurrent());
<a name="l03536"></a>03536 
<a name="l03537"></a>03537 <span class="preprocessor">        #if TARGET_OS_IPHONE &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_4_0</span>
<a name="l03538"></a>03538 <span class="preprocessor"></span>        <span class="keywordflow">if</span> ([ASIHTTPRequest isMultitaskingSupported] &amp;&amp; [<span class="keyword">self</span> shouldContinueWhenAppEntersBackground]) {
<a name="l03539"></a>03539                 dispatch_async(dispatch_get_main_queue(), ^{
<a name="l03540"></a>03540                         <span class="keywordflow">if</span> (backgroundTask != UIBackgroundTaskInvalid) {
<a name="l03541"></a>03541                                 [[UIApplication sharedApplication] endBackgroundTask:backgroundTask];
<a name="l03542"></a>03542                                 backgroundTask = UIBackgroundTaskInvalid;
<a name="l03543"></a>03543                         }
<a name="l03544"></a>03544                 });
<a name="l03545"></a>03545         }
<a name="l03546"></a>03546 <span class="preprocessor">        #endif</span>
<a name="l03547"></a>03547 <span class="preprocessor"></span>        CFRelease(<span class="keyword">self</span>);
<a name="l03548"></a>03548 }
<a name="l03549"></a>03549 
<a name="l03550"></a>03550 - (void)useDataFromCache
<a name="l03551"></a>03551 {
<a name="l03552"></a>03552         NSDictionary *headers = [[<span class="keyword">self</span> downloadCache] cachedResponseHeadersForURL:[<span class="keyword">self</span> url]];
<a name="l03553"></a>03553         <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *dataPath = [[<span class="keyword">self</span> downloadCache] pathToCachedResponseDataForURL:[<span class="keyword">self</span> url]];
<a name="l03554"></a>03554 
<a name="l03555"></a>03555         ASIHTTPRequest *theRequest = <span class="keyword">self</span>;
<a name="l03556"></a>03556         <span class="keywordflow">if</span> ([<span class="keyword">self</span> mainRequest]) {
<a name="l03557"></a>03557                 theRequest = [<span class="keyword">self</span> mainRequest];
<a name="l03558"></a>03558         }
<a name="l03559"></a>03559 
<a name="l03560"></a>03560         <span class="keywordflow">if</span> (headers &amp;&amp; dataPath) {
<a name="l03561"></a>03561 
<a name="l03562"></a>03562                 [<span class="keyword">self</span> setResponseStatusCode:[[headers objectForKey:@&quot;X-ASIHTTPRequest-Response-Status-Code&quot;] intValue]];
<a name="l03563"></a>03563                 [<span class="keyword">self</span> setDidUseCachedResponse:YES];
<a name="l03564"></a>03564                 [theRequest setResponseHeaders:headers];
<a name="l03565"></a>03565 
<a name="l03566"></a>03566                 <span class="keywordflow">if</span> ([theRequest downloadDestinationPath]) {
<a name="l03567"></a>03567                         [theRequest setDownloadDestinationPath:dataPath];
<a name="l03568"></a>03568                 } <span class="keywordflow">else</span> {
<a name="l03569"></a>03569                         [theRequest setRawResponseData:[NSMutableData dataWithData:[[<span class="keyword">self</span> downloadCache] cachedResponseDataForURL:[<span class="keyword">self</span> url]]]];
<a name="l03570"></a>03570                 }
<a name="l03571"></a>03571                 [theRequest setContentLength:[[[<span class="keyword">self</span> responseHeaders] objectForKey:@&quot;Content-Length&quot;] longLongValue]];
<a name="l03572"></a>03572                 [theRequest setTotalBytesRead:[<span class="keyword">self</span> contentLength]];
<a name="l03573"></a>03573 
<a name="l03574"></a>03574                 [theRequest parseStringEncodingFromHeaders];
<a name="l03575"></a>03575 
<a name="l03576"></a>03576                 [theRequest setResponseCookies:[NSHTTPCookie cookiesWithResponseHeaderFields:headers forURL:[<span class="keyword">self</span> url]]];
<a name="l03577"></a>03577 
<a name="l03578"></a>03578                 <span class="comment">// See if we need to redirect</span>
<a name="l03579"></a>03579                 <span class="keywordflow">if</span> ([<span class="keyword">self</span> willRedirect]) {
<a name="l03580"></a>03580                         <span class="keywordflow">if</span> (![<span class="keyword">self</span> willAskDelegateToConfirmRedirect]) {
<a name="l03581"></a>03581                                 [<span class="keyword">self</span> performRedirect];
<a name="l03582"></a>03582                         }
<a name="l03583"></a>03583                         <span class="keywordflow">return</span>;
<a name="l03584"></a>03584                 }
<a name="l03585"></a>03585         }
<a name="l03586"></a>03586 
<a name="l03587"></a>03587         [theRequest setComplete:YES];
<a name="l03588"></a>03588         [theRequest setDownloadComplete:YES];
<a name="l03589"></a>03589 
<a name="l03590"></a>03590         <span class="comment">// If we&#39;re pulling data from the cache without contacting the server at all, we won&#39;t have set originalURL yet</span>
<a name="l03591"></a>03591         <span class="keywordflow">if</span> ([<span class="keyword">self</span> redirectCount] == 0) {
<a name="l03592"></a>03592                 [theRequest setOriginalURL:[theRequest url]];
<a name="l03593"></a>03593         }
<a name="l03594"></a>03594 
<a name="l03595"></a>03595         [theRequest updateProgressIndicators];
<a name="l03596"></a>03596         [theRequest requestFinished];
<a name="l03597"></a>03597         [theRequest markAsFinished];    
<a name="l03598"></a>03598         <span class="keywordflow">if</span> ([<span class="keyword">self</span> mainRequest]) {
<a name="l03599"></a>03599                 [<span class="keyword">self</span> markAsFinished];
<a name="l03600"></a>03600         }
<a name="l03601"></a>03601 }
<a name="l03602"></a>03602 
<a name="l03603"></a>03603 - (BOOL)retryUsingNewConnection
<a name="l03604"></a>03604 {
<a name="l03605"></a>03605         <span class="keywordflow">if</span> ([<span class="keyword">self</span> retryCount] == 0) {
<a name="l03606"></a>03606 
<a name="l03607"></a>03607                 [<span class="keyword">self</span> setWillRetryRequest:YES];
<a name="l03608"></a>03608                 [<span class="keyword">self</span> cancelLoad];
<a name="l03609"></a>03609                 [<span class="keyword">self</span> setWillRetryRequest:NO];
<a name="l03610"></a>03610 
<a name="l03611"></a>03611 <span class="preprocessor">                #if DEBUG_PERSISTENT_CONNECTIONS</span>
<a name="l03612"></a>03612 <span class="preprocessor"></span>                        NSLog(<span class="stringliteral">@&quot;[CONNECTION] Request attempted to use connection #%@, but it has been closed - will retry with a new connection&quot;</span>, [[<span class="keyword">self</span> connectionInfo] objectForKey:<span class="stringliteral">@&quot;id&quot;</span>]);
<a name="l03613"></a>03613 <span class="preprocessor">                #endif</span>
<a name="l03614"></a>03614 <span class="preprocessor"></span>                [connectionsLock lock];
<a name="l03615"></a>03615                 [[<span class="keyword">self</span> connectionInfo] removeObjectForKey:@&quot;request&quot;];
<a name="l03616"></a>03616                 [persistentConnectionsPool removeObject:[<span class="keyword">self</span> connectionInfo]];
<a name="l03617"></a>03617                 [<span class="keyword">self</span> setConnectionInfo:nil];
<a name="l03618"></a>03618                 [connectionsLock unlock];
<a name="l03619"></a>03619                 [<span class="keyword">self</span> setRetryCount:[<span class="keyword">self</span> retryCount]+1];
<a name="l03620"></a>03620                 [<span class="keyword">self</span> startRequest];
<a name="l03621"></a>03621                 <span class="keywordflow">return</span> YES;
<a name="l03622"></a>03622         }
<a name="l03623"></a>03623 <span class="preprocessor">        #if DEBUG_PERSISTENT_CONNECTIONS</span>
<a name="l03624"></a>03624 <span class="preprocessor"></span>                NSLog(<span class="stringliteral">@&quot;[CONNECTION] Request attempted to use connection #%@, but it has been closed - we have already retried with a new connection, so we must give up&quot;</span>, [[<span class="keyword">self</span> connectionInfo] objectForKey:<span class="stringliteral">@&quot;id&quot;</span>]);
<a name="l03625"></a>03625 <span class="preprocessor">        #endif  </span>
<a name="l03626"></a>03626 <span class="preprocessor"></span>        <span class="keywordflow">return</span> NO;
<a name="l03627"></a>03627 }
<a name="l03628"></a>03628 
<a name="l03629"></a>03629 - (void)handleStreamError
<a name="l03630"></a>03630 
<a name="l03631"></a>03631 {
<a name="l03632"></a>03632         NSError *underlyingError = NSMakeCollectable([(NSError *)CFReadStreamCopyError((CFReadStreamRef)[<span class="keyword">self</span> readStream]) autorelease]);
<a name="l03633"></a>03633 
<a name="l03634"></a>03634         <span class="keywordflow">if</span> (![<span class="keyword">self</span> error]) { <span class="comment">// We may already have handled this error</span>
<a name="l03635"></a>03635                 
<a name="l03636"></a>03636                 <span class="comment">// First, check for a &#39;socket not connected&#39;, &#39;broken pipe&#39; or &#39;connection lost&#39; error</span>
<a name="l03637"></a>03637                 <span class="comment">// This may occur when we&#39;ve attempted to reuse a connection that should have been closed</span>
<a name="l03638"></a>03638                 <span class="comment">// If we get this, we need to retry the request</span>
<a name="l03639"></a>03639                 <span class="comment">// We&#39;ll only do this once - if it happens again on retry, we&#39;ll give up</span>
<a name="l03640"></a>03640                 <span class="comment">// -1005 = kCFURLErrorNetworkConnectionLost - this doesn&#39;t seem to be declared on Mac OS 10.5</span>
<a name="l03641"></a>03641                 <span class="keywordflow">if</span> (([[underlyingError domain] isEqualToString:NSPOSIXErrorDomain] &amp;&amp; ([underlyingError code] == ENOTCONN || [underlyingError code] == EPIPE)) 
<a name="l03642"></a>03642                         || ([[underlyingError domain] isEqualToString:(<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)kCFErrorDomainCFNetwork] &amp;&amp; [underlyingError code] == -1005)) {
<a name="l03643"></a>03643                         <span class="keywordflow">if</span> ([<span class="keyword">self</span> retryUsingNewConnection]) {
<a name="l03644"></a>03644                                 <span class="keywordflow">return</span>;
<a name="l03645"></a>03645                         }
<a name="l03646"></a>03646                 }
<a name="l03647"></a>03647                 
<a name="l03648"></a>03648                 <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *reason = <span class="stringliteral">@&quot;A connection failure occurred&quot;</span>;
<a name="l03649"></a>03649                 
<a name="l03650"></a>03650                 <span class="comment">// We&#39;ll use a custom error message for SSL errors, but you should always check underlying error if you want more details</span>
<a name="l03651"></a>03651                 <span class="comment">// For some reason SecureTransport.h doesn&#39;t seem to be available on iphone, so error codes hard-coded</span>
<a name="l03652"></a>03652                 <span class="comment">// Also, iPhone seems to handle errors differently from Mac OS X - a self-signed certificate returns a different error code on each platform, so we&#39;ll just provide a general error</span>
<a name="l03653"></a>03653                 <span class="keywordflow">if</span> ([[underlyingError domain] isEqualToString:NSOSStatusErrorDomain]) {
<a name="l03654"></a>03654                         <span class="keywordflow">if</span> ([underlyingError code] &lt;= -9800 &amp;&amp; [underlyingError code] &gt;= -9818) {
<a name="l03655"></a>03655                                 reason = [<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> stringWithFormat:@&quot;%@: SSL problem (Possible causes may include a bad/expired/self-signed certificate, clock set to wrong date)&quot;,reason];
<a name="l03656"></a>03656                         }
<a name="l03657"></a>03657                 }
<a name="l03658"></a>03658                 [<span class="keyword">self</span> cancelLoad];
<a name="l03659"></a>03659                 [<span class="keyword">self</span> failWithError:[NSError errorWithDomain:NetworkRequestErrorDomain code:ASIConnectionFailureErrorType userInfo:[NSDictionary dictionaryWithObjectsAndKeys:reason,NSLocalizedDescriptionKey,underlyingError,NSUnderlyingErrorKey,nil]]];
<a name="l03660"></a>03660         } <span class="keywordflow">else</span> {
<a name="l03661"></a>03661                 [<span class="keyword">self</span> cancelLoad];
<a name="l03662"></a>03662         }
<a name="l03663"></a>03663         [<span class="keyword">self</span> checkRequestStatus];
<a name="l03664"></a>03664 }
<a name="l03665"></a>03665 
<a name="l03666"></a>03666 <span class="preprocessor">#pragma mark managing the read stream</span>
<a name="l03667"></a>03667 <span class="preprocessor"></span>
<a name="l03668"></a>03668 - (void)destroyReadStream
<a name="l03669"></a>03669 {
<a name="l03670"></a>03670     <span class="keywordflow">if</span> ([<span class="keyword">self</span> readStream]) {
<a name="l03671"></a>03671                 [<span class="keyword">self</span> unscheduleReadStream];
<a name="l03672"></a>03672                 <span class="keywordflow">if</span> (![<span class="keyword">self</span> connectionCanBeReused]) {
<a name="l03673"></a>03673                         [[<span class="keyword">self</span> readStream] removeFromRunLoop:[NSRunLoop currentRunLoop] forMode:[<span class="keyword">self</span> runLoopMode]];
<a name="l03674"></a>03674                         [[<span class="keyword">self</span> readStream] close];
<a name="l03675"></a>03675                 }
<a name="l03676"></a>03676                 [<span class="keyword">self</span> setReadStream:nil];
<a name="l03677"></a>03677     }   
<a name="l03678"></a>03678 }
<a name="l03679"></a>03679 
<a name="l03680"></a>03680 - (void)scheduleReadStream
<a name="l03681"></a>03681 {
<a name="l03682"></a>03682         <span class="keywordflow">if</span> ([<span class="keyword">self</span> readStream] &amp;&amp; ![<span class="keyword">self</span> readStreamIsScheduled]) {
<a name="l03683"></a>03683 
<a name="l03684"></a>03684                 [connectionsLock lock];
<a name="l03685"></a>03685                 runningRequestCount++;
<a name="l03686"></a>03686                 <span class="keywordflow">if</span> (shouldUpdateNetworkActivityIndicator) {
<a name="l03687"></a>03687                         [[<span class="keyword">self</span> class] showNetworkActivityIndicator];
<a name="l03688"></a>03688                 }
<a name="l03689"></a>03689                 [connectionsLock unlock];
<a name="l03690"></a>03690 
<a name="l03691"></a>03691                 <span class="comment">// Reset the timeout</span>
<a name="l03692"></a>03692                 [<span class="keyword">self</span> setLastActivityTime:[NSDate date]];
<a name="l03693"></a>03693                 CFStreamClientContext ctxt = {0, <span class="keyword">self</span>, NULL, NULL, NULL};
<a name="l03694"></a>03694                 CFReadStreamSetClient((CFReadStreamRef)[<span class="keyword">self</span> readStream], kNetworkEvents, ReadStreamClientCallBack, &amp;ctxt);
<a name="l03695"></a>03695                 [[<span class="keyword">self</span> readStream] scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:[<span class="keyword">self</span> runLoopMode]];
<a name="l03696"></a>03696                 [<span class="keyword">self</span> setReadStreamIsScheduled:YES];
<a name="l03697"></a>03697         }
<a name="l03698"></a>03698 }
<a name="l03699"></a>03699 
<a name="l03700"></a>03700 
<a name="l03701"></a>03701 - (void)unscheduleReadStream
<a name="l03702"></a>03702 {
<a name="l03703"></a>03703         <span class="keywordflow">if</span> ([<span class="keyword">self</span> readStream] &amp;&amp; [<span class="keyword">self</span> readStreamIsScheduled]) {
<a name="l03704"></a>03704 
<a name="l03705"></a>03705                 [connectionsLock lock];
<a name="l03706"></a>03706                 runningRequestCount--;
<a name="l03707"></a>03707                 <span class="keywordflow">if</span> (shouldUpdateNetworkActivityIndicator &amp;&amp; runningRequestCount == 0) {
<a name="l03708"></a>03708                         <span class="comment">// This call will wait half a second before turning off the indicator</span>
<a name="l03709"></a>03709                         <span class="comment">// This can prevent flicker when you have a single request finish and then immediately start another request</span>
<a name="l03710"></a>03710                         <span class="comment">// We run this on the main thread because we have no guarantee this thread will have a runloop in 0.5 seconds time</span>
<a name="l03711"></a>03711                         <span class="comment">// We don&#39;t bother the cancel this call if we start a new request, because we&#39;ll check if requests are running before we hide it</span>
<a name="l03712"></a>03712                         [[<span class="keyword">self</span> class] performSelectorOnMainThread:@selector(hideNetworkActivityIndicatorAfterDelay) withObject:nil waitUntilDone:[NSThread isMainThread]];
<a name="l03713"></a>03713                 }
<a name="l03714"></a>03714                 [connectionsLock unlock];
<a name="l03715"></a>03715 
<a name="l03716"></a>03716                 CFReadStreamSetClient((CFReadStreamRef)[<span class="keyword">self</span> readStream], kCFStreamEventNone, NULL, NULL);
<a name="l03717"></a>03717                 [[<span class="keyword">self</span> readStream] removeFromRunLoop:[NSRunLoop currentRunLoop] forMode:[<span class="keyword">self</span> runLoopMode]];
<a name="l03718"></a>03718                 [<span class="keyword">self</span> setReadStreamIsScheduled:NO];
<a name="l03719"></a>03719         }
<a name="l03720"></a>03720 }
<a name="l03721"></a>03721 
<a name="l03722"></a>03722 <span class="preprocessor">#pragma mark cleanup</span>
<a name="l03723"></a>03723 <span class="preprocessor"></span>
<a name="l03724"></a>03724 - (BOOL)removeTemporaryDownloadFile
<a name="l03725"></a>03725 {
<a name="l03726"></a>03726         NSError *err = nil;
<a name="l03727"></a>03727         <span class="keywordflow">if</span> ([<span class="keyword">self</span> temporaryFileDownloadPath]) {
<a name="l03728"></a>03728                 <span class="keywordflow">if</span> (![[<span class="keyword">self</span> <span class="keyword">class</span>] removeFileAtPath:[<span class="keyword">self</span> temporaryFileDownloadPath] error:&amp;err]) {
<a name="l03729"></a>03729                         [<span class="keyword">self</span> failWithError:err];
<a name="l03730"></a>03730                 }
<a name="l03731"></a>03731                 [<span class="keyword">self</span> setTemporaryFileDownloadPath:nil];
<a name="l03732"></a>03732         }
<a name="l03733"></a>03733         <span class="keywordflow">return</span> (!err);
<a name="l03734"></a>03734 }
<a name="l03735"></a>03735 
<a name="l03736"></a>03736 - (BOOL)removeTemporaryUncompressedDownloadFile
<a name="l03737"></a>03737 {
<a name="l03738"></a>03738         NSError *err = nil;
<a name="l03739"></a>03739         <span class="keywordflow">if</span> ([<span class="keyword">self</span> temporaryUncompressedDataDownloadPath]) {
<a name="l03740"></a>03740                 <span class="keywordflow">if</span> (![[<span class="keyword">self</span> <span class="keyword">class</span>] removeFileAtPath:[<span class="keyword">self</span> temporaryUncompressedDataDownloadPath] error:&amp;err]) {
<a name="l03741"></a>03741                         [<span class="keyword">self</span> failWithError:err];
<a name="l03742"></a>03742                 }
<a name="l03743"></a>03743                 [<span class="keyword">self</span> setTemporaryUncompressedDataDownloadPath:nil];
<a name="l03744"></a>03744         }
<a name="l03745"></a>03745         <span class="keywordflow">return</span> (!err);
<a name="l03746"></a>03746 }
<a name="l03747"></a>03747 
<a name="l03748"></a>03748 - (BOOL)removeTemporaryUploadFile
<a name="l03749"></a>03749 {
<a name="l03750"></a>03750         NSError *err = nil;
<a name="l03751"></a>03751         <span class="keywordflow">if</span> ([<span class="keyword">self</span> postBodyFilePath]) {
<a name="l03752"></a>03752                 <span class="keywordflow">if</span> (![[<span class="keyword">self</span> <span class="keyword">class</span>] removeFileAtPath:[<span class="keyword">self</span> postBodyFilePath] error:&amp;err]) {
<a name="l03753"></a>03753                         [<span class="keyword">self</span> failWithError:err];
<a name="l03754"></a>03754                 }
<a name="l03755"></a>03755                 [<span class="keyword">self</span> setPostBodyFilePath:nil];
<a name="l03756"></a>03756         }
<a name="l03757"></a>03757         <span class="keywordflow">return</span> (!err);
<a name="l03758"></a>03758 }
<a name="l03759"></a>03759 
<a name="l03760"></a>03760 - (BOOL)removeTemporaryCompressedUploadFile
<a name="l03761"></a>03761 {
<a name="l03762"></a>03762         NSError *err = nil;
<a name="l03763"></a>03763         <span class="keywordflow">if</span> ([<span class="keyword">self</span> compressedPostBodyFilePath]) {
<a name="l03764"></a>03764                 <span class="keywordflow">if</span> (![[<span class="keyword">self</span> <span class="keyword">class</span>] removeFileAtPath:[<span class="keyword">self</span> compressedPostBodyFilePath] error:&amp;err]) {
<a name="l03765"></a>03765                         [<span class="keyword">self</span> failWithError:err];
<a name="l03766"></a>03766                 }
<a name="l03767"></a>03767                 [<span class="keyword">self</span> setCompressedPostBodyFilePath:nil];
<a name="l03768"></a>03768         }
<a name="l03769"></a>03769         <span class="keywordflow">return</span> (!err);
<a name="l03770"></a>03770 }
<a name="l03771"></a>03771 
<a name="l03772"></a>03772 + (BOOL)removeFileAtPath:(<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)path error:(NSError **)err
<a name="l03773"></a>03773 {
<a name="l03774"></a>03774         NSFileManager *fileManager = [[[NSFileManager alloc] init] autorelease];
<a name="l03775"></a>03775 
<a name="l03776"></a>03776         <span class="keywordflow">if</span> ([fileManager fileExistsAtPath:path]) {
<a name="l03777"></a>03777                 NSError *removeError = nil;
<a name="l03778"></a>03778                 [fileManager removeItemAtPath:path error:&amp;removeError];
<a name="l03779"></a>03779                 <span class="keywordflow">if</span> (removeError) {
<a name="l03780"></a>03780                         <span class="keywordflow">if</span> (err) {
<a name="l03781"></a>03781                                 *err = [NSError errorWithDomain:NetworkRequestErrorDomain code:ASIFileManagementError userInfo:[NSDictionary dictionaryWithObjectsAndKeys:[<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> stringWithFormat:@&quot;Failed to delete file at path &#39;%@&#39;&quot;,path],NSLocalizedDescriptionKey,removeError,NSUnderlyingErrorKey,nil]];
<a name="l03782"></a>03782                         }
<a name="l03783"></a>03783                         <span class="keywordflow">return</span> NO;
<a name="l03784"></a>03784                 }
<a name="l03785"></a>03785         }
<a name="l03786"></a>03786         <span class="keywordflow">return</span> YES;
<a name="l03787"></a>03787 }
<a name="l03788"></a>03788 
<a name="l03789"></a>03789 <span class="preprocessor">#pragma mark Proxies</span>
<a name="l03790"></a>03790 <span class="preprocessor"></span>
<a name="l03791"></a>03791 - (BOOL)configureProxies
<a name="l03792"></a>03792 {
<a name="l03793"></a>03793         <span class="comment">// Have details of the proxy been set on this request</span>
<a name="l03794"></a>03794         <span class="keywordflow">if</span> (![<span class="keyword">self</span> isPACFileRequest] &amp;&amp; (![<span class="keyword">self</span> proxyHost] &amp;&amp; ![<span class="keyword">self</span> proxyPort])) {
<a name="l03795"></a>03795 
<a name="l03796"></a>03796                 <span class="comment">// If not, we need to figure out what they&#39;ll be</span>
<a name="l03797"></a>03797                 NSArray *proxies = nil;
<a name="l03798"></a>03798 
<a name="l03799"></a>03799                 <span class="comment">// Have we been given a proxy auto config file?</span>
<a name="l03800"></a>03800                 <span class="keywordflow">if</span> ([<span class="keyword">self</span> PACurl]) {
<a name="l03801"></a>03801 
<a name="l03802"></a>03802                         <span class="comment">// If yes, we&#39;ll need to fetch the PAC file asynchronously, so we stop this request to wait until we have the proxy details.</span>
<a name="l03803"></a>03803                         [<span class="keyword">self</span> fetchPACFile];
<a name="l03804"></a>03804                         <span class="keywordflow">return</span> NO;
<a name="l03805"></a>03805 
<a name="l03806"></a>03806                         <span class="comment">// Detect proxy settings and apply them</span>
<a name="l03807"></a>03807                 } <span class="keywordflow">else</span> {
<a name="l03808"></a>03808 
<a name="l03809"></a>03809 <span class="preprocessor">#if TARGET_OS_IPHONE</span>
<a name="l03810"></a>03810 <span class="preprocessor"></span>                        NSDictionary *proxySettings = NSMakeCollectable([(NSDictionary *)CFNetworkCopySystemProxySettings() autorelease]);
<a name="l03811"></a>03811 <span class="preprocessor">#else</span>
<a name="l03812"></a>03812 <span class="preprocessor"></span>                        NSDictionary *proxySettings = NSMakeCollectable([(NSDictionary *)SCDynamicStoreCopyProxies(NULL) autorelease]);
<a name="l03813"></a>03813 <span class="preprocessor">#endif</span>
<a name="l03814"></a>03814 <span class="preprocessor"></span>
<a name="l03815"></a>03815                         proxies = NSMakeCollectable([(NSArray *)CFNetworkCopyProxiesForURL((CFURLRef)[<span class="keyword">self</span> url], (CFDictionaryRef)proxySettings) autorelease]);
<a name="l03816"></a>03816 
<a name="l03817"></a>03817                         <span class="comment">// Now check to see if the proxy settings contained a PAC url, we need to run the script to get the real list of proxies if so</span>
<a name="l03818"></a>03818                         NSDictionary *settings = [proxies objectAtIndex:0];
<a name="l03819"></a>03819                         <span class="keywordflow">if</span> ([settings objectForKey:(<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)kCFProxyAutoConfigurationURLKey]) {
<a name="l03820"></a>03820                                 [<span class="keyword">self</span> setPACurl:[settings objectForKey:(NSString *)kCFProxyAutoConfigurationURLKey]];
<a name="l03821"></a>03821                                 [<span class="keyword">self</span> fetchPACFile];
<a name="l03822"></a>03822                                 <span class="keywordflow">return</span> NO;
<a name="l03823"></a>03823                         }
<a name="l03824"></a>03824                 }
<a name="l03825"></a>03825 
<a name="l03826"></a>03826                 <span class="keywordflow">if</span> (!proxies) {
<a name="l03827"></a>03827                         [<span class="keyword">self</span> setReadStream:nil];
<a name="l03828"></a>03828                         [<span class="keyword">self</span> failWithError:[NSError errorWithDomain:NetworkRequestErrorDomain code:ASIInternalErrorWhileBuildingRequestType userInfo:[NSDictionary dictionaryWithObjectsAndKeys:@&quot;Unable to obtain information on proxy servers needed for request&quot;,NSLocalizedDescriptionKey,nil]]];
<a name="l03829"></a>03829                         <span class="keywordflow">return</span> NO;
<a name="l03830"></a>03830                 }
<a name="l03831"></a>03831                 <span class="comment">// I don&#39;t really understand why the dictionary returned by CFNetworkCopyProxiesForURL uses different key names from CFNetworkCopySystemProxySettings/SCDynamicStoreCopyProxies</span>
<a name="l03832"></a>03832                 <span class="comment">// and why its key names are documented while those we actually need to use don&#39;t seem to be (passing the kCF* keys doesn&#39;t seem to work)</span>
<a name="l03833"></a>03833                 <span class="keywordflow">if</span> ([proxies count] &gt; 0) {
<a name="l03834"></a>03834                         NSDictionary *settings = [proxies objectAtIndex:0];
<a name="l03835"></a>03835                         [<span class="keyword">self</span> setProxyHost:[settings objectForKey:(NSString *)kCFProxyHostNameKey]];
<a name="l03836"></a>03836                         [<span class="keyword">self</span> setProxyPort:[[settings objectForKey:(NSString *)kCFProxyPortNumberKey] intValue]];
<a name="l03837"></a>03837                         [<span class="keyword">self</span> setProxyType:[settings objectForKey:(NSString *)kCFProxyTypeKey]];
<a name="l03838"></a>03838                 }
<a name="l03839"></a>03839         }
<a name="l03840"></a>03840         <span class="keywordflow">return</span> YES;
<a name="l03841"></a>03841 }
<a name="l03842"></a>03842 
<a name="l03843"></a>03843 
<a name="l03844"></a>03844 
<a name="l03845"></a>03845 <span class="comment">// Attempts to download a PAC (Proxy Auto-Configuration) file</span>
<a name="l03846"></a>03846 <span class="comment">// PAC files at file://, http:// and https:// addresses are supported</span>
<a name="l03847"></a>03847 - (void)fetchPACFile
<a name="l03848"></a>03848 {
<a name="l03849"></a>03849         <span class="comment">// For file:// urls, we&#39;ll use an async NSInputStream (ASIHTTPRequest does not support file:// urls)</span>
<a name="l03850"></a>03850         <span class="keywordflow">if</span> ([[<span class="keyword">self</span> PACurl] isFileURL]) {
<a name="l03851"></a>03851                 NSInputStream *stream = [[[NSInputStream alloc] initWithFileAtPath:[[<span class="keyword">self</span> PACurl] path]] autorelease];
<a name="l03852"></a>03852                 [<span class="keyword">self</span> setPACFileReadStream:stream];
<a name="l03853"></a>03853                 [stream setDelegate:(id)self];
<a name="l03854"></a>03854                 [stream scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:[<span class="keyword">self</span> runLoopMode]];
<a name="l03855"></a>03855                 [stream open];
<a name="l03856"></a>03856                 <span class="comment">// If it takes more than timeOutSeconds to read the PAC, we&#39;ll just give up and assume no proxies</span>
<a name="l03857"></a>03857                 <span class="comment">// We won&#39;t bother to handle cases where the first part of the PAC is read within timeOutSeconds, but the whole thing takes longer</span>
<a name="l03858"></a>03858                 <span class="comment">// Either our PAC file is in easy reach, or it&#39;s going to slow things down to the point that it&#39;s probably better requests fail</span>
<a name="l03859"></a>03859                 [<span class="keyword">self</span> performSelector:@selector(timeOutPACRead) withObject:nil afterDelay:[<span class="keyword">self</span> timeOutSeconds]];
<a name="l03860"></a>03860                 <span class="keywordflow">return</span>;
<a name="l03861"></a>03861         }
<a name="l03862"></a>03862 
<a name="l03863"></a>03863         <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *scheme = [[[<span class="keyword">self</span> PACurl] scheme] lowercaseString];
<a name="l03864"></a>03864         <span class="keywordflow">if</span> (![scheme isEqualToString:<span class="stringliteral">@&quot;http&quot;</span>] &amp;&amp; ![scheme isEqualToString:<span class="stringliteral">@&quot;https&quot;</span>]) {
<a name="l03865"></a>03865                 <span class="comment">// Don&#39;t know how to read data from this URL, we&#39;ll have to give up</span>
<a name="l03866"></a>03866                 <span class="comment">// We&#39;ll simply assume no proxies, and start the request as normal</span>
<a name="l03867"></a>03867                 [<span class="keyword">self</span> startRequest];
<a name="l03868"></a>03868                 <span class="keywordflow">return</span>;
<a name="l03869"></a>03869         }
<a name="l03870"></a>03870 
<a name="l03871"></a>03871         <span class="comment">// Create an ASIHTTPRequest to fetch the PAC file</span>
<a name="l03872"></a>03872         ASIHTTPRequest *PACRequest = [ASIHTTPRequest requestWithURL:[<span class="keyword">self</span> PACurl]];
<a name="l03873"></a>03873 
<a name="l03874"></a>03874         <span class="comment">// Will prevent this request attempting to configure proxy settings for itself</span>
<a name="l03875"></a>03875         [PACRequest setIsPACFileRequest:YES];
<a name="l03876"></a>03876 
<a name="l03877"></a>03877         [PACRequest setTimeOutSeconds:[<span class="keyword">self</span> timeOutSeconds]];
<a name="l03878"></a>03878 
<a name="l03879"></a>03879         <span class="comment">// If we&#39;re a synchronous request, we&#39;ll download the PAC file synchronously</span>
<a name="l03880"></a>03880         <span class="keywordflow">if</span> ([<span class="keyword">self</span> isSynchronous]) {
<a name="l03881"></a>03881                 [PACRequest startSynchronous];
<a name="l03882"></a>03882                 <span class="keywordflow">if</span> (![PACRequest error] &amp;&amp; [PACRequest responseString]) {
<a name="l03883"></a>03883                         [<span class="keyword">self</span> runPACScript:[PACRequest responseString]];
<a name="l03884"></a>03884                 }
<a name="l03885"></a>03885                 [<span class="keyword">self</span> startRequest];
<a name="l03886"></a>03886                 <span class="keywordflow">return</span>;
<a name="l03887"></a>03887         }
<a name="l03888"></a>03888 
<a name="l03889"></a>03889         [<span class="keyword">self</span> setPACFileRequest:PACRequest];
<a name="l03890"></a>03890 
<a name="l03891"></a>03891         <span class="comment">// Force this request to run before others in the shared queue</span>
<a name="l03892"></a>03892         [PACRequest setQueuePriority:NSOperationQueuePriorityHigh];
<a name="l03893"></a>03893 
<a name="l03894"></a>03894         <span class="comment">// We&#39;ll treat failure to download the PAC file the same as success - if we were unable to fetch a PAC file, we proceed as if we have no proxy server and let this request fail itself if necessary</span>
<a name="l03895"></a>03895         [PACRequest setDelegate:self];
<a name="l03896"></a>03896         [PACRequest setDidFinishSelector:@selector(finishedDownloadingPACFile:)];
<a name="l03897"></a>03897         [PACRequest setDidFailSelector:@selector(finishedDownloadingPACFile:)];
<a name="l03898"></a>03898         [PACRequest startAsynchronous];
<a name="l03899"></a>03899 
<a name="l03900"></a>03900         <span class="comment">// Temporarily increase the number of operations in the shared queue to give our request a chance to run</span>
<a name="l03901"></a>03901         [connectionsLock lock];
<a name="l03902"></a>03902         [sharedQueue setMaxConcurrentOperationCount:[sharedQueue maxConcurrentOperationCount]+1];
<a name="l03903"></a>03903         [connectionsLock unlock];
<a name="l03904"></a>03904 }
<a name="l03905"></a>03905 
<a name="l03906"></a>03906 <span class="comment">// Called as we read the PAC file from a file:// url</span>
<a name="l03907"></a>03907 - (void)stream:(NSStream *)stream handleEvent:(NSStreamEvent)eventCode
<a name="l03908"></a>03908 {
<a name="l03909"></a>03909         <span class="keywordflow">if</span> (![<span class="keyword">self</span> PACFileReadStream]) {
<a name="l03910"></a>03910                 <span class="keywordflow">return</span>;
<a name="l03911"></a>03911         }
<a name="l03912"></a>03912         <span class="keywordflow">if</span> (eventCode == NSStreamEventHasBytesAvailable) {
<a name="l03913"></a>03913 
<a name="l03914"></a>03914                 <span class="keywordflow">if</span> (![<span class="keyword">self</span> PACFileData]) {
<a name="l03915"></a>03915                         [<span class="keyword">self</span> setPACFileData:[NSMutableData data]];
<a name="l03916"></a>03916                 }
<a name="l03917"></a>03917                 <span class="comment">// If your PAC file is larger than 16KB, you&#39;re just being cruel.</span>
<a name="l03918"></a>03918                 uint8_t buf[16384];
<a name="l03919"></a>03919                 NSInteger len = [(NSInputStream *)stream read:buf maxLength:16384];
<a name="l03920"></a>03920                 <span class="keywordflow">if</span> (len) {
<a name="l03921"></a>03921                         [[<span class="keyword">self</span> PACFileData] appendBytes:(const void *)buf length:len];
<a name="l03922"></a>03922                 }
<a name="l03923"></a>03923 
<a name="l03924"></a>03924         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (eventCode == NSStreamEventErrorOccurred || eventCode == NSStreamEventEndEncountered) {
<a name="l03925"></a>03925 
<a name="l03926"></a>03926                 [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(timeOutPACRead) object:nil];
<a name="l03927"></a>03927 
<a name="l03928"></a>03928                 [stream close];
<a name="l03929"></a>03929                 [stream removeFromRunLoop:[NSRunLoop currentRunLoop] forMode:[<span class="keyword">self</span> runLoopMode]];
<a name="l03930"></a>03930                 [<span class="keyword">self</span> setPACFileReadStream:nil];
<a name="l03931"></a>03931 
<a name="l03932"></a>03932                 <span class="keywordflow">if</span> (eventCode == NSStreamEventEndEncountered) {
<a name="l03933"></a>03933                         <span class="comment">// It sounds as though we have no idea what encoding a PAC file will use</span>
<a name="l03934"></a>03934                         <span class="keyword">static</span> NSStringEncoding encodingsToTry[2] = {NSUTF8StringEncoding,NSISOLatin1StringEncoding};
<a name="l03935"></a>03935                         NSUInteger i;
<a name="l03936"></a>03936                         <span class="keywordflow">for</span> (i=0; i&lt;2; i++) {
<a name="l03937"></a>03937                                 <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *pacScript =  [[[<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> alloc] initWithBytes:[[<span class="keyword">self</span> PACFileData] bytes] length:[[<span class="keyword">self</span> PACFileData] length] encoding:encodingsToTry[i]] autorelease];
<a name="l03938"></a>03938                                 <span class="keywordflow">if</span> (pacScript) {
<a name="l03939"></a>03939                                         [<span class="keyword">self</span> runPACScript:pacScript];
<a name="l03940"></a>03940                                         <span class="keywordflow">break</span>;
<a name="l03941"></a>03941                                 }
<a name="l03942"></a>03942                         }
<a name="l03943"></a>03943                 }
<a name="l03944"></a>03944                 [<span class="keyword">self</span> setPACFileData:nil];
<a name="l03945"></a>03945                 [<span class="keyword">self</span> startRequest];
<a name="l03946"></a>03946         }
<a name="l03947"></a>03947 }
<a name="l03948"></a>03948 
<a name="l03949"></a>03949 <span class="comment">// Called if it takes longer than timeOutSeconds to read the whole PAC file (when reading from a file:// url)</span>
<a name="l03950"></a>03950 - (void)timeOutPACRead
<a name="l03951"></a>03951 {
<a name="l03952"></a>03952         [<span class="keyword">self</span> stream:[<span class="keyword">self</span> PACFileReadStream] handleEvent:NSStreamEventErrorOccurred];
<a name="l03953"></a>03953 }
<a name="l03954"></a>03954 
<a name="l03955"></a>03955 <span class="comment">// Runs the downloaded PAC script</span>
<a name="l03956"></a>03956 - (void)runPACScript:(<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)script
<a name="l03957"></a>03957 {
<a name="l03958"></a>03958         <span class="keywordflow">if</span> (script) {
<a name="l03959"></a>03959                 <span class="comment">// From: http://developer.apple.com/samplecode/CFProxySupportTool/listing1.html</span>
<a name="l03960"></a>03960                 <span class="comment">// Work around &lt;rdar://problem/5530166&gt;.  This dummy call to </span>
<a name="l03961"></a>03961                 <span class="comment">// CFNetworkCopyProxiesForURL initialise some state within CFNetwork </span>
<a name="l03962"></a>03962                 <span class="comment">// that is required by CFNetworkCopyProxiesForAutoConfigurationScript.</span>
<a name="l03963"></a>03963                 CFRelease(CFNetworkCopyProxiesForURL((CFURLRef)[<span class="keyword">self</span> url], NULL));
<a name="l03964"></a>03964 
<a name="l03965"></a>03965                 <span class="comment">// Obtain the list of proxies by running the autoconfiguration script</span>
<a name="l03966"></a>03966                 CFErrorRef err = NULL;
<a name="l03967"></a>03967                 NSArray *proxies = NSMakeCollectable([(NSArray *)CFNetworkCopyProxiesForAutoConfigurationScript((CFStringRef)script,(CFURLRef)[<span class="keyword">self</span> url], &amp;err) autorelease]);
<a name="l03968"></a>03968                 <span class="keywordflow">if</span> (!err &amp;&amp; [proxies count] &gt; 0) {
<a name="l03969"></a>03969                         NSDictionary *settings = [proxies objectAtIndex:0];
<a name="l03970"></a>03970                         [<span class="keyword">self</span> setProxyHost:[settings objectForKey:(NSString *)kCFProxyHostNameKey]];
<a name="l03971"></a>03971                         [<span class="keyword">self</span> setProxyPort:[[settings objectForKey:(NSString *)kCFProxyPortNumberKey] intValue]];
<a name="l03972"></a>03972                         [<span class="keyword">self</span> setProxyType:[settings objectForKey:(NSString *)kCFProxyTypeKey]];
<a name="l03973"></a>03973                 }
<a name="l03974"></a>03974         }
<a name="l03975"></a>03975 }
<a name="l03976"></a>03976 
<a name="l03977"></a>03977 <span class="comment">// Called if we successfully downloaded a PAC file from a webserver</span>
<a name="l03978"></a>03978 - (void)finishedDownloadingPACFile:(ASIHTTPRequest *)theRequest
<a name="l03979"></a>03979 {
<a name="l03980"></a>03980         <span class="keywordflow">if</span> (![theRequest error] &amp;&amp; [theRequest responseString]) {
<a name="l03981"></a>03981                 [<span class="keyword">self</span> runPACScript:[theRequest responseString]];
<a name="l03982"></a>03982         }
<a name="l03983"></a>03983 
<a name="l03984"></a>03984         <span class="comment">// Set the shared queue&#39;s maxConcurrentOperationCount back to normal</span>
<a name="l03985"></a>03985         [connectionsLock lock];
<a name="l03986"></a>03986         [sharedQueue setMaxConcurrentOperationCount:[sharedQueue maxConcurrentOperationCount]-1];
<a name="l03987"></a>03987         [connectionsLock unlock];
<a name="l03988"></a>03988 
<a name="l03989"></a>03989         <span class="comment">// We no longer need our PAC file request</span>
<a name="l03990"></a>03990         [<span class="keyword">self</span> setPACFileRequest:nil];
<a name="l03991"></a>03991 
<a name="l03992"></a>03992         <span class="comment">// Start the request</span>
<a name="l03993"></a>03993         [<span class="keyword">self</span> startRequest];
<a name="l03994"></a>03994 }
<a name="l03995"></a>03995 
<a name="l03996"></a>03996 
<a name="l03997"></a>03997 <span class="preprocessor">#pragma mark persistent connections</span>
<a name="l03998"></a>03998 <span class="preprocessor"></span>
<a name="l03999"></a>03999 - (NSNumber *)connectionID
<a name="l04000"></a>04000 {
<a name="l04001"></a>04001         <span class="keywordflow">return</span> [[<span class="keyword">self</span> connectionInfo] objectForKey:@&quot;id&quot;];
<a name="l04002"></a>04002 }
<a name="l04003"></a>04003 
<a name="l04004"></a>04004 + (void)expirePersistentConnections
<a name="l04005"></a>04005 {
<a name="l04006"></a>04006         [connectionsLock lock];
<a name="l04007"></a>04007         NSUInteger i;
<a name="l04008"></a>04008         <span class="keywordflow">for</span> (i=0; i&lt;[persistentConnectionsPool count]; i++) {
<a name="l04009"></a>04009                 NSDictionary *existingConnection = [persistentConnectionsPool objectAtIndex:i];
<a name="l04010"></a>04010                 <span class="keywordflow">if</span> (![existingConnection objectForKey:<span class="stringliteral">@&quot;request&quot;</span>] &amp;&amp; [[existingConnection objectForKey:<span class="stringliteral">@&quot;expires&quot;</span>] timeIntervalSinceNow] &lt;= 0) {
<a name="l04011"></a>04011 <span class="preprocessor">#if DEBUG_PERSISTENT_CONNECTIONS</span>
<a name="l04012"></a>04012 <span class="preprocessor"></span>                        NSLog(<span class="stringliteral">@&quot;[CONNECTION] Closing connection #%i because it has expired&quot;</span>,[[existingConnection objectForKey:<span class="stringliteral">@&quot;id&quot;</span>] intValue]);
<a name="l04013"></a>04013 <span class="preprocessor">#endif</span>
<a name="l04014"></a>04014 <span class="preprocessor"></span>                        NSInputStream *stream = [existingConnection objectForKey:@&quot;stream&quot;];
<a name="l04015"></a>04015                         <span class="keywordflow">if</span> (stream) {
<a name="l04016"></a>04016                                 [stream close];
<a name="l04017"></a>04017                         }
<a name="l04018"></a>04018                         [persistentConnectionsPool removeObject:existingConnection];
<a name="l04019"></a>04019                         i--;
<a name="l04020"></a>04020                 }
<a name="l04021"></a>04021         }       
<a name="l04022"></a>04022         [connectionsLock unlock];
<a name="l04023"></a>04023 }
<a name="l04024"></a>04024 
<a name="l04025"></a>04025 <span class="preprocessor">#pragma mark NSCopying</span>
<a name="l04026"></a>04026 <span class="preprocessor"></span>
<a name="l04027"></a>04027 - (id)copyWithZone:(NSZone *)zone
<a name="l04028"></a>04028 {
<a name="l04029"></a>04029         <span class="comment">// Don&#39;t forget - this will return a retained copy!</span>
<a name="l04030"></a>04030         ASIHTTPRequest *newRequest = [[[<span class="keyword">self</span> class] alloc] initWithURL:[<span class="keyword">self</span> url]];
<a name="l04031"></a>04031         [newRequest setDelegate:[<span class="keyword">self</span> delegate]];
<a name="l04032"></a>04032         [newRequest setRequestMethod:[<span class="keyword">self</span> requestMethod]];
<a name="l04033"></a>04033         [newRequest setPostBody:[<span class="keyword">self</span> postBody]];
<a name="l04034"></a>04034         [newRequest setShouldStreamPostDataFromDisk:[<span class="keyword">self</span> shouldStreamPostDataFromDisk]];
<a name="l04035"></a>04035         [newRequest setPostBodyFilePath:[<span class="keyword">self</span> postBodyFilePath]];
<a name="l04036"></a>04036         [newRequest setRequestHeaders:[[[<span class="keyword">self</span> requestHeaders] mutableCopyWithZone:zone] autorelease]];
<a name="l04037"></a>04037         [newRequest setRequestCookies:[[[<span class="keyword">self</span> requestCookies] mutableCopyWithZone:zone] autorelease]];
<a name="l04038"></a>04038         [newRequest setUseCookiePersistence:[<span class="keyword">self</span> useCookiePersistence]];
<a name="l04039"></a>04039         [newRequest setUseKeychainPersistence:[<span class="keyword">self</span> useKeychainPersistence]];
<a name="l04040"></a>04040         [newRequest setUseSessionPersistence:[<span class="keyword">self</span> useSessionPersistence]];
<a name="l04041"></a>04041         [newRequest setAllowCompressedResponse:[<span class="keyword">self</span> allowCompressedResponse]];
<a name="l04042"></a>04042         [newRequest setDownloadDestinationPath:[<span class="keyword">self</span> downloadDestinationPath]];
<a name="l04043"></a>04043         [newRequest setTemporaryFileDownloadPath:[<span class="keyword">self</span> temporaryFileDownloadPath]];
<a name="l04044"></a>04044         [newRequest setUsername:[<span class="keyword">self</span> username]];
<a name="l04045"></a>04045         [newRequest setPassword:[<span class="keyword">self</span> password]];
<a name="l04046"></a>04046         [newRequest setDomain:[<span class="keyword">self</span> domain]];
<a name="l04047"></a>04047         [newRequest setProxyUsername:[<span class="keyword">self</span> proxyUsername]];
<a name="l04048"></a>04048         [newRequest setProxyPassword:[<span class="keyword">self</span> proxyPassword]];
<a name="l04049"></a>04049         [newRequest setProxyDomain:[<span class="keyword">self</span> proxyDomain]];
<a name="l04050"></a>04050         [newRequest setProxyHost:[<span class="keyword">self</span> proxyHost]];
<a name="l04051"></a>04051         [newRequest setProxyPort:[<span class="keyword">self</span> proxyPort]];
<a name="l04052"></a>04052         [newRequest setProxyType:[<span class="keyword">self</span> proxyType]];
<a name="l04053"></a>04053         [newRequest setUploadProgressDelegate:[<span class="keyword">self</span> uploadProgressDelegate]];
<a name="l04054"></a>04054         [newRequest setDownloadProgressDelegate:[<span class="keyword">self</span> downloadProgressDelegate]];
<a name="l04055"></a>04055         [newRequest setShouldPresentAuthenticationDialog:[<span class="keyword">self</span> shouldPresentAuthenticationDialog]];
<a name="l04056"></a>04056         [newRequest setShouldPresentProxyAuthenticationDialog:[<span class="keyword">self</span> shouldPresentProxyAuthenticationDialog]];
<a name="l04057"></a>04057         [newRequest setPostLength:[<span class="keyword">self</span> postLength]];
<a name="l04058"></a>04058         [newRequest setHaveBuiltPostBody:[<span class="keyword">self</span> haveBuiltPostBody]];
<a name="l04059"></a>04059         [newRequest setDidStartSelector:[<span class="keyword">self</span> didStartSelector]];
<a name="l04060"></a>04060         [newRequest setDidFinishSelector:[<span class="keyword">self</span> didFinishSelector]];
<a name="l04061"></a>04061         [newRequest setDidFailSelector:[<span class="keyword">self</span> didFailSelector]];
<a name="l04062"></a>04062         [newRequest setTimeOutSeconds:[<span class="keyword">self</span> timeOutSeconds]];
<a name="l04063"></a>04063         [newRequest setShouldResetDownloadProgress:[<span class="keyword">self</span> shouldResetDownloadProgress]];
<a name="l04064"></a>04064         [newRequest setShouldResetUploadProgress:[<span class="keyword">self</span> shouldResetUploadProgress]];
<a name="l04065"></a>04065         [newRequest setShowAccurateProgress:[<span class="keyword">self</span> showAccurateProgress]];
<a name="l04066"></a>04066         [newRequest setDefaultResponseEncoding:[<span class="keyword">self</span> defaultResponseEncoding]];
<a name="l04067"></a>04067         [newRequest setAllowResumeForFileDownloads:[<span class="keyword">self</span> allowResumeForFileDownloads]];
<a name="l04068"></a>04068         [newRequest setUserInfo:[[[<span class="keyword">self</span> userInfo] copyWithZone:zone] autorelease]];
<a name="l04069"></a>04069         [newRequest setTag:[<span class="keyword">self</span> tag]];
<a name="l04070"></a>04070         [newRequest setUseHTTPVersionOne:[<span class="keyword">self</span> useHTTPVersionOne]];
<a name="l04071"></a>04071         [newRequest setShouldRedirect:[<span class="keyword">self</span> shouldRedirect]];
<a name="l04072"></a>04072         [newRequest setValidatesSecureCertificate:[<span class="keyword">self</span> validatesSecureCertificate]];
<a name="l04073"></a>04073     [newRequest setClientCertificateIdentity:clientCertificateIdentity];
<a name="l04074"></a>04074         [newRequest setClientCertificates:[[clientCertificates copy] autorelease]];
<a name="l04075"></a>04075         [newRequest setPACurl:[<span class="keyword">self</span> PACurl]];
<a name="l04076"></a>04076         [newRequest setShouldPresentCredentialsBeforeChallenge:[<span class="keyword">self</span> shouldPresentCredentialsBeforeChallenge]];
<a name="l04077"></a>04077         [newRequest setNumberOfTimesToRetryOnTimeout:[<span class="keyword">self</span> numberOfTimesToRetryOnTimeout]];
<a name="l04078"></a>04078         [newRequest setShouldUseRFC2616RedirectBehaviour:[<span class="keyword">self</span> shouldUseRFC2616RedirectBehaviour]];
<a name="l04079"></a>04079         [newRequest setShouldAttemptPersistentConnection:[<span class="keyword">self</span> shouldAttemptPersistentConnection]];
<a name="l04080"></a>04080         [newRequest setPersistentConnectionTimeoutSeconds:[<span class="keyword">self</span> persistentConnectionTimeoutSeconds]];
<a name="l04081"></a>04081         <span class="keywordflow">return</span> newRequest;
<a name="l04082"></a>04082 }
<a name="l04083"></a>04083 
<a name="l04084"></a>04084 <span class="preprocessor">#pragma mark default time out</span>
<a name="l04085"></a>04085 <span class="preprocessor"></span>
<a name="l04086"></a>04086 + (NSTimeInterval)defaultTimeOutSeconds
<a name="l04087"></a>04087 {
<a name="l04088"></a>04088         <span class="keywordflow">return</span> defaultTimeOutSeconds;
<a name="l04089"></a>04089 }
<a name="l04090"></a>04090 
<a name="l04091"></a>04091 + (void)setDefaultTimeOutSeconds:(NSTimeInterval)newTimeOutSeconds
<a name="l04092"></a>04092 {
<a name="l04093"></a>04093         defaultTimeOutSeconds = newTimeOutSeconds;
<a name="l04094"></a>04094 }
<a name="l04095"></a>04095 
<a name="l04096"></a>04096 
<a name="l04097"></a>04097 <span class="preprocessor">#pragma mark client certificate</span>
<a name="l04098"></a>04098 <span class="preprocessor"></span>
<a name="l04099"></a>04099 - (void)setClientCertificateIdentity:(SecIdentityRef)anIdentity {
<a name="l04100"></a>04100     <span class="keywordflow">if</span>(clientCertificateIdentity) {
<a name="l04101"></a>04101         CFRelease(clientCertificateIdentity);
<a name="l04102"></a>04102     }
<a name="l04103"></a>04103     
<a name="l04104"></a>04104     clientCertificateIdentity = anIdentity;
<a name="l04105"></a>04105     
<a name="l04106"></a>04106         <span class="keywordflow">if</span> (clientCertificateIdentity) {
<a name="l04107"></a>04107                 CFRetain(clientCertificateIdentity);
<a name="l04108"></a>04108         }
<a name="l04109"></a>04109 }
<a name="l04110"></a>04110 
<a name="l04111"></a>04111 
<a name="l04112"></a>04112 <span class="preprocessor">#pragma mark session credentials</span>
<a name="l04113"></a>04113 <span class="preprocessor"></span>
<a name="l04114"></a>04114 + (NSMutableArray *)sessionProxyCredentialsStore
<a name="l04115"></a>04115 {
<a name="l04116"></a>04116         [sessionCredentialsLock lock];
<a name="l04117"></a>04117         <span class="keywordflow">if</span> (!sessionProxyCredentialsStore) {
<a name="l04118"></a>04118                 sessionProxyCredentialsStore = [[NSMutableArray alloc] init];
<a name="l04119"></a>04119         }
<a name="l04120"></a>04120         [sessionCredentialsLock unlock];
<a name="l04121"></a>04121         <span class="keywordflow">return</span> sessionProxyCredentialsStore;
<a name="l04122"></a>04122 }
<a name="l04123"></a>04123 
<a name="l04124"></a>04124 + (NSMutableArray *)sessionCredentialsStore
<a name="l04125"></a>04125 {
<a name="l04126"></a>04126         [sessionCredentialsLock lock];
<a name="l04127"></a>04127         <span class="keywordflow">if</span> (!sessionCredentialsStore) {
<a name="l04128"></a>04128                 sessionCredentialsStore = [[NSMutableArray alloc] init];
<a name="l04129"></a>04129         }
<a name="l04130"></a>04130         [sessionCredentialsLock unlock];
<a name="l04131"></a>04131         <span class="keywordflow">return</span> sessionCredentialsStore;
<a name="l04132"></a>04132 }
<a name="l04133"></a>04133 
<a name="l04134"></a>04134 + (void)storeProxyAuthenticationCredentialsInSessionStore:(NSDictionary *)credentials
<a name="l04135"></a>04135 {
<a name="l04136"></a>04136         [sessionCredentialsLock lock];
<a name="l04137"></a>04137         [<span class="keyword">self</span> removeProxyAuthenticationCredentialsFromSessionStore:[credentials objectForKey:@&quot;Credentials&quot;]];
<a name="l04138"></a>04138         [[[<span class="keyword">self</span> class] sessionProxyCredentialsStore] addObject:credentials];
<a name="l04139"></a>04139         [sessionCredentialsLock unlock];
<a name="l04140"></a>04140 }
<a name="l04141"></a>04141 
<a name="l04142"></a>04142 + (void)storeAuthenticationCredentialsInSessionStore:(NSDictionary *)credentials
<a name="l04143"></a>04143 {
<a name="l04144"></a>04144         [sessionCredentialsLock lock];
<a name="l04145"></a>04145         [<span class="keyword">self</span> removeAuthenticationCredentialsFromSessionStore:[credentials objectForKey:@&quot;Credentials&quot;]];
<a name="l04146"></a>04146         [[[<span class="keyword">self</span> class] sessionCredentialsStore] addObject:credentials];
<a name="l04147"></a>04147         [sessionCredentialsLock unlock];
<a name="l04148"></a>04148 }
<a name="l04149"></a>04149 
<a name="l04150"></a>04150 + (void)removeProxyAuthenticationCredentialsFromSessionStore:(NSDictionary *)credentials
<a name="l04151"></a>04151 {
<a name="l04152"></a>04152         [sessionCredentialsLock lock];
<a name="l04153"></a>04153         NSMutableArray *sessionCredentialsList = [[<span class="keyword">self</span> class] sessionProxyCredentialsStore];
<a name="l04154"></a>04154         NSUInteger i;
<a name="l04155"></a>04155         <span class="keywordflow">for</span> (i=0; i&lt;[sessionCredentialsList count]; i++) {
<a name="l04156"></a>04156                 NSDictionary *theCredentials = [sessionCredentialsList objectAtIndex:i];
<a name="l04157"></a>04157                 <span class="keywordflow">if</span> ([theCredentials objectForKey:<span class="stringliteral">@&quot;Credentials&quot;</span>] == credentials) {
<a name="l04158"></a>04158                         [sessionCredentialsList removeObjectAtIndex:i];
<a name="l04159"></a>04159                         [sessionCredentialsLock unlock];
<a name="l04160"></a>04160                         <span class="keywordflow">return</span>;
<a name="l04161"></a>04161                 }
<a name="l04162"></a>04162         }
<a name="l04163"></a>04163         [sessionCredentialsLock unlock];
<a name="l04164"></a>04164 }
<a name="l04165"></a>04165 
<a name="l04166"></a>04166 + (void)removeAuthenticationCredentialsFromSessionStore:(NSDictionary *)credentials
<a name="l04167"></a>04167 {
<a name="l04168"></a>04168         [sessionCredentialsLock lock];
<a name="l04169"></a>04169         NSMutableArray *sessionCredentialsList = [[<span class="keyword">self</span> class] sessionCredentialsStore];
<a name="l04170"></a>04170         NSUInteger i;
<a name="l04171"></a>04171         <span class="keywordflow">for</span> (i=0; i&lt;[sessionCredentialsList count]; i++) {
<a name="l04172"></a>04172                 NSDictionary *theCredentials = [sessionCredentialsList objectAtIndex:i];
<a name="l04173"></a>04173                 <span class="keywordflow">if</span> ([theCredentials objectForKey:<span class="stringliteral">@&quot;Credentials&quot;</span>] == credentials) {
<a name="l04174"></a>04174                         [sessionCredentialsList removeObjectAtIndex:i];
<a name="l04175"></a>04175                         [sessionCredentialsLock unlock];
<a name="l04176"></a>04176                         <span class="keywordflow">return</span>;
<a name="l04177"></a>04177                 }
<a name="l04178"></a>04178         }
<a name="l04179"></a>04179         [sessionCredentialsLock unlock];
<a name="l04180"></a>04180 }
<a name="l04181"></a>04181 
<a name="l04182"></a>04182 - (NSDictionary *)findSessionProxyAuthenticationCredentials
<a name="l04183"></a>04183 {
<a name="l04184"></a>04184         [sessionCredentialsLock lock];
<a name="l04185"></a>04185         NSMutableArray *sessionCredentialsList = [[<span class="keyword">self</span> class] sessionProxyCredentialsStore];
<a name="l04186"></a>04186         <span class="keywordflow">for</span> (NSDictionary *theCredentials in sessionCredentialsList) {
<a name="l04187"></a>04187                 <span class="keywordflow">if</span> ([[theCredentials objectForKey:<span class="stringliteral">@&quot;Host&quot;</span>] isEqualToString:[<span class="keyword">self</span> proxyHost]] &amp;&amp; [[theCredentials objectForKey:<span class="stringliteral">@&quot;Port&quot;</span>] intValue] == [<span class="keyword">self</span> proxyPort]) {
<a name="l04188"></a>04188                         [sessionCredentialsLock unlock];
<a name="l04189"></a>04189                         <span class="keywordflow">return</span> theCredentials;
<a name="l04190"></a>04190                 }
<a name="l04191"></a>04191         }
<a name="l04192"></a>04192         [sessionCredentialsLock unlock];
<a name="l04193"></a>04193         <span class="keywordflow">return</span> nil;
<a name="l04194"></a>04194 }
<a name="l04195"></a>04195 
<a name="l04196"></a>04196 
<a name="l04197"></a>04197 - (NSDictionary *)findSessionAuthenticationCredentials
<a name="l04198"></a>04198 {
<a name="l04199"></a>04199         [sessionCredentialsLock lock];
<a name="l04200"></a>04200         NSMutableArray *sessionCredentialsList = [[<span class="keyword">self</span> class] sessionCredentialsStore];
<a name="l04201"></a>04201         NSURL *requestURL = [<span class="keyword">self</span> url];
<a name="l04202"></a>04202 
<a name="l04203"></a>04203         BOOL haveFoundExactMatch;
<a name="l04204"></a>04204         NSDictionary *closeMatch = nil;
<a name="l04205"></a>04205 
<a name="l04206"></a>04206         <span class="comment">// Loop through all the cached credentials we have, looking for the best match for this request</span>
<a name="l04207"></a>04207         <span class="keywordflow">for</span> (NSDictionary *theCredentials in sessionCredentialsList) {
<a name="l04208"></a>04208                 
<a name="l04209"></a>04209                 haveFoundExactMatch = NO;
<a name="l04210"></a>04210                 NSURL *cachedCredentialsURL = [theCredentials objectForKey:@&quot;URL&quot;];
<a name="l04211"></a>04211 
<a name="l04212"></a>04212                 <span class="comment">// Find an exact match (same url)</span>
<a name="l04213"></a>04213                 <span class="keywordflow">if</span> ([cachedCredentialsURL isEqual:[<span class="keyword">self</span> url]]) {
<a name="l04214"></a>04214                         haveFoundExactMatch = YES;
<a name="l04215"></a>04215 
<a name="l04216"></a>04216                 <span class="comment">// This is not an exact match for the url, and we already have a close match we can use</span>
<a name="l04217"></a>04217                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (closeMatch) {
<a name="l04218"></a>04218                         <span class="keywordflow">continue</span>;
<a name="l04219"></a>04219 
<a name="l04220"></a>04220                 <span class="comment">// Find a close match (same host, scheme and port)</span>
<a name="l04221"></a>04221                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ([[cachedCredentialsURL host] isEqualToString:[requestURL host]] &amp;&amp; ([cachedCredentialsURL port] == [requestURL port] || ([requestURL port] &amp;&amp; [[cachedCredentialsURL port] isEqualToNumber:[requestURL port]])) &amp;&amp; [[cachedCredentialsURL scheme] isEqualToString:[requestURL scheme]]) {
<a name="l04222"></a>04222                 } <span class="keywordflow">else</span> {
<a name="l04223"></a>04223                         <span class="keywordflow">continue</span>;
<a name="l04224"></a>04224                 }
<a name="l04225"></a>04225 
<a name="l04226"></a>04226                 <span class="comment">// Just a sanity check to ensure we never choose credentials from a different realm. Can&#39;t really do more than that, as either this request or the stored credentials may not have a realm when the other does</span>
<a name="l04227"></a>04227                 <span class="keywordflow">if</span> ([<span class="keyword">self</span> authenticationRealm] &amp;&amp; ([theCredentials objectForKey:<span class="stringliteral">@&quot;AuthenticationRealm&quot;</span>] &amp;&amp; ![[theCredentials objectForKey:<span class="stringliteral">@&quot;AuthenticationRealm&quot;</span>] isEqualToString:[<span class="keyword">self</span> authenticationRealm]])) {
<a name="l04228"></a>04228                         <span class="keywordflow">continue</span>;
<a name="l04229"></a>04229                 }
<a name="l04230"></a>04230 
<a name="l04231"></a>04231                 <span class="comment">// If we have a username and password set on the request, check that they are the same as the cached ones</span>
<a name="l04232"></a>04232                 <span class="keywordflow">if</span> ([<span class="keyword">self</span> username] &amp;&amp; [<span class="keyword">self</span> password]) {
<a name="l04233"></a>04233                         NSDictionary *usernameAndPassword = [theCredentials objectForKey:@&quot;Credentials&quot;];
<a name="l04234"></a>04234                         <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *storedUsername = [usernameAndPassword objectForKey:(NSString *)kCFHTTPAuthenticationUsername];
<a name="l04235"></a>04235                         <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *storedPassword = [usernameAndPassword objectForKey:(NSString *)kCFHTTPAuthenticationUsername];
<a name="l04236"></a>04236                         <span class="keywordflow">if</span> (![storedUsername isEqualToString:[<span class="keyword">self</span> username]] || ![storedPassword isEqualToString:[<span class="keyword">self</span> password]]) {
<a name="l04237"></a>04237                                 <span class="keywordflow">continue</span>;
<a name="l04238"></a>04238                         }
<a name="l04239"></a>04239                 }
<a name="l04240"></a>04240 
<a name="l04241"></a>04241                 <span class="comment">// If we have an exact match for the url, use those credentials</span>
<a name="l04242"></a>04242                 <span class="keywordflow">if</span> (haveFoundExactMatch) {
<a name="l04243"></a>04243                         [sessionCredentialsLock unlock];
<a name="l04244"></a>04244                         <span class="keywordflow">return</span> theCredentials;
<a name="l04245"></a>04245                 }
<a name="l04246"></a>04246 
<a name="l04247"></a>04247                 <span class="comment">// We have no exact match, let&#39;s remember that we have a good match for this server, and we&#39;ll use it at the end if we don&#39;t find an exact match</span>
<a name="l04248"></a>04248                 closeMatch = theCredentials;
<a name="l04249"></a>04249         }
<a name="l04250"></a>04250         [sessionCredentialsLock unlock];
<a name="l04251"></a>04251 
<a name="l04252"></a>04252         <span class="comment">// Return credentials that matched on host, port and scheme, or nil if we didn&#39;t find any</span>
<a name="l04253"></a>04253         <span class="keywordflow">return</span> closeMatch;
<a name="l04254"></a>04254 }
<a name="l04255"></a>04255 
<a name="l04256"></a>04256 <span class="preprocessor">#pragma mark keychain storage</span>
<a name="l04257"></a>04257 <span class="preprocessor"></span>
<a name="l04258"></a>04258 + (void)saveCredentials:(NSURLCredential *)credentials forHost:(<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)host port:(<span class="keywordtype">int</span>)port protocol:(<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)protocol realm:(<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)realm
<a name="l04259"></a>04259 {
<a name="l04260"></a>04260         NSURLProtectionSpace *protectionSpace = [[[NSURLProtectionSpace alloc] initWithHost:host port:port protocol:protocol realm:realm authenticationMethod:NSURLAuthenticationMethodDefault] autorelease];
<a name="l04261"></a>04261         [[NSURLCredentialStorage sharedCredentialStorage] setDefaultCredential:credentials forProtectionSpace:protectionSpace];
<a name="l04262"></a>04262 }
<a name="l04263"></a>04263 
<a name="l04264"></a>04264 + (void)saveCredentials:(NSURLCredential *)credentials forProxy:(<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)host port:(<span class="keywordtype">int</span>)port realm:(<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)realm
<a name="l04265"></a>04265 {
<a name="l04266"></a>04266         NSURLProtectionSpace *protectionSpace = [[[NSURLProtectionSpace alloc] initWithProxyHost:host port:port type:NSURLProtectionSpaceHTTPProxy realm:realm authenticationMethod:NSURLAuthenticationMethodDefault] autorelease];
<a name="l04267"></a>04267         [[NSURLCredentialStorage sharedCredentialStorage] setDefaultCredential:credentials forProtectionSpace:protectionSpace];
<a name="l04268"></a>04268 }
<a name="l04269"></a>04269 
<a name="l04270"></a>04270 + (NSURLCredential *)savedCredentialsForHost:(<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)host port:(<span class="keywordtype">int</span>)port protocol:(<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)protocol realm:(<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)realm
<a name="l04271"></a>04271 {
<a name="l04272"></a>04272         NSURLProtectionSpace *protectionSpace = [[[NSURLProtectionSpace alloc] initWithHost:host port:port protocol:protocol realm:realm authenticationMethod:NSURLAuthenticationMethodDefault] autorelease];
<a name="l04273"></a>04273         <span class="keywordflow">return</span> [[NSURLCredentialStorage sharedCredentialStorage] defaultCredentialForProtectionSpace:protectionSpace];
<a name="l04274"></a>04274 }
<a name="l04275"></a>04275 
<a name="l04276"></a>04276 + (NSURLCredential *)savedCredentialsForProxy:(<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)host port:(<span class="keywordtype">int</span>)port protocol:(<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)protocol realm:(<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)realm
<a name="l04277"></a>04277 {
<a name="l04278"></a>04278         NSURLProtectionSpace *protectionSpace = [[[NSURLProtectionSpace alloc] initWithProxyHost:host port:port type:NSURLProtectionSpaceHTTPProxy realm:realm authenticationMethod:NSURLAuthenticationMethodDefault] autorelease];
<a name="l04279"></a>04279         <span class="keywordflow">return</span> [[NSURLCredentialStorage sharedCredentialStorage] defaultCredentialForProtectionSpace:protectionSpace];
<a name="l04280"></a>04280 }
<a name="l04281"></a>04281 
<a name="l04282"></a>04282 + (void)removeCredentialsForHost:(<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)host port:(<span class="keywordtype">int</span>)port protocol:(<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)protocol realm:(<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)realm
<a name="l04283"></a>04283 {
<a name="l04284"></a>04284         NSURLProtectionSpace *protectionSpace = [[[NSURLProtectionSpace alloc] initWithHost:host port:port protocol:protocol realm:realm authenticationMethod:NSURLAuthenticationMethodDefault] autorelease];
<a name="l04285"></a>04285         NSURLCredential *credential = [[NSURLCredentialStorage sharedCredentialStorage] defaultCredentialForProtectionSpace:protectionSpace];
<a name="l04286"></a>04286         <span class="keywordflow">if</span> (credential) {
<a name="l04287"></a>04287                 [[NSURLCredentialStorage sharedCredentialStorage] removeCredential:credential forProtectionSpace:protectionSpace];
<a name="l04288"></a>04288         }
<a name="l04289"></a>04289 }
<a name="l04290"></a>04290 
<a name="l04291"></a>04291 + (void)removeCredentialsForProxy:(<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)host port:(<span class="keywordtype">int</span>)port realm:(<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)realm
<a name="l04292"></a>04292 {
<a name="l04293"></a>04293         NSURLProtectionSpace *protectionSpace = [[[NSURLProtectionSpace alloc] initWithProxyHost:host port:port type:NSURLProtectionSpaceHTTPProxy realm:realm authenticationMethod:NSURLAuthenticationMethodDefault] autorelease];
<a name="l04294"></a>04294         NSURLCredential *credential = [[NSURLCredentialStorage sharedCredentialStorage] defaultCredentialForProtectionSpace:protectionSpace];
<a name="l04295"></a>04295         <span class="keywordflow">if</span> (credential) {
<a name="l04296"></a>04296                 [[NSURLCredentialStorage sharedCredentialStorage] removeCredential:credential forProtectionSpace:protectionSpace];
<a name="l04297"></a>04297         }
<a name="l04298"></a>04298 }
<a name="l04299"></a>04299 
<a name="l04300"></a>04300 + (NSMutableArray *)sessionCookies
<a name="l04301"></a>04301 {
<a name="l04302"></a>04302         [sessionCookiesLock lock];
<a name="l04303"></a>04303         <span class="keywordflow">if</span> (!sessionCookies) {
<a name="l04304"></a>04304                 [ASIHTTPRequest setSessionCookies:[NSMutableArray array]];
<a name="l04305"></a>04305         }
<a name="l04306"></a>04306         NSMutableArray *cookies = [[sessionCookies retain] autorelease];
<a name="l04307"></a>04307         [sessionCookiesLock unlock];
<a name="l04308"></a>04308         <span class="keywordflow">return</span> cookies;
<a name="l04309"></a>04309 }
<a name="l04310"></a>04310 
<a name="l04311"></a>04311 + (void)setSessionCookies:(NSMutableArray *)newSessionCookies
<a name="l04312"></a>04312 {
<a name="l04313"></a>04313         [sessionCookiesLock lock];
<a name="l04314"></a>04314         <span class="comment">// Remove existing cookies from the persistent store</span>
<a name="l04315"></a>04315         <span class="keywordflow">for</span> (NSHTTPCookie *cookie in sessionCookies) {
<a name="l04316"></a>04316                 [[NSHTTPCookieStorage sharedHTTPCookieStorage] deleteCookie:cookie];
<a name="l04317"></a>04317         }
<a name="l04318"></a>04318         [sessionCookies release];
<a name="l04319"></a>04319         sessionCookies = [newSessionCookies retain];
<a name="l04320"></a>04320         [sessionCookiesLock unlock];
<a name="l04321"></a>04321 }
<a name="l04322"></a>04322 
<a name="l04323"></a>04323 + (void)addSessionCookie:(NSHTTPCookie *)newCookie
<a name="l04324"></a>04324 {
<a name="l04325"></a>04325         [sessionCookiesLock lock];
<a name="l04326"></a>04326         NSHTTPCookie *cookie;
<a name="l04327"></a>04327         NSUInteger i;
<a name="l04328"></a>04328         NSUInteger max = [[ASIHTTPRequest sessionCookies] count];
<a name="l04329"></a>04329         <span class="keywordflow">for</span> (i=0; i&lt;max; i++) {
<a name="l04330"></a>04330                 cookie = [[ASIHTTPRequest sessionCookies] objectAtIndex:i];
<a name="l04331"></a>04331                 <span class="keywordflow">if</span> ([[cookie domain] isEqualToString:[newCookie domain]] &amp;&amp; [[cookie path] isEqualToString:[newCookie path]] &amp;&amp; [[cookie name] isEqualToString:[newCookie name]]) {
<a name="l04332"></a>04332                         [[ASIHTTPRequest sessionCookies] removeObjectAtIndex:i];
<a name="l04333"></a>04333                         <span class="keywordflow">break</span>;
<a name="l04334"></a>04334                 }
<a name="l04335"></a>04335         }
<a name="l04336"></a>04336         [[ASIHTTPRequest sessionCookies] addObject:newCookie];
<a name="l04337"></a>04337         [sessionCookiesLock unlock];
<a name="l04338"></a>04338 }
<a name="l04339"></a>04339 
<a name="l04340"></a>04340 <span class="comment">// Dump all session data (authentication and cookies)</span>
<a name="l04341"></a>04341 + (void)clearSession
<a name="l04342"></a>04342 {
<a name="l04343"></a>04343         [sessionCredentialsLock lock];
<a name="l04344"></a>04344         [[[<span class="keyword">self</span> class] sessionCredentialsStore] removeAllObjects];
<a name="l04345"></a>04345         [sessionCredentialsLock unlock];
<a name="l04346"></a>04346         [[<span class="keyword">self</span> class] setSessionCookies:nil];
<a name="l04347"></a>04347         [[[<span class="keyword">self</span> class] defaultCache] clearCachedResponsesForStoragePolicy:ASICacheForSessionDurationCacheStoragePolicy];
<a name="l04348"></a>04348 }
<a name="l04349"></a>04349 
<a name="l04350"></a>04350 <span class="preprocessor">#pragma mark get user agent</span>
<a name="l04351"></a>04351 <span class="preprocessor"></span>
<a name="l04352"></a>04352 + (<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)defaultUserAgentString
<a name="l04353"></a>04353 {
<a name="l04354"></a>04354         @<span class="keyword">synchronized</span> (<span class="keyword">self</span>) {
<a name="l04355"></a>04355 
<a name="l04356"></a>04356                 <span class="keywordflow">if</span> (!defaultUserAgent) {
<a name="l04357"></a>04357 
<a name="l04358"></a>04358                         NSBundle *bundle = [NSBundle bundleForClass:[<span class="keyword">self</span> class]];
<a name="l04359"></a>04359 
<a name="l04360"></a>04360                         <span class="comment">// Attempt to find a name for this application</span>
<a name="l04361"></a>04361                         <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *appName = [bundle objectForInfoDictionaryKey:@&quot;CFBundleDisplayName&quot;];
<a name="l04362"></a>04362                         <span class="keywordflow">if</span> (!appName) {
<a name="l04363"></a>04363                                 appName = [bundle objectForInfoDictionaryKey:@&quot;CFBundleName&quot;];
<a name="l04364"></a>04364                         }
<a name="l04365"></a>04365 
<a name="l04366"></a>04366                         <a class="code" href="class_n_s_data.html" title="For hashing raw data.">NSData</a> *latin1Data = [appName dataUsingEncoding:NSUTF8StringEncoding];
<a name="l04367"></a>04367                         appName = [[[<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> alloc] initWithData:latin1Data encoding:NSISOLatin1StringEncoding] autorelease];
<a name="l04368"></a>04368 
<a name="l04369"></a>04369                         <span class="comment">// If we couldn&#39;t find one, we&#39;ll give up (and ASIHTTPRequest will use the standard CFNetwork user agent)</span>
<a name="l04370"></a>04370                         <span class="keywordflow">if</span> (!appName) {
<a name="l04371"></a>04371                                 <span class="keywordflow">return</span> nil;
<a name="l04372"></a>04372                         }
<a name="l04373"></a>04373 
<a name="l04374"></a>04374                         <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *appVersion = nil;
<a name="l04375"></a>04375                         <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *marketingVersionNumber = [bundle objectForInfoDictionaryKey:@&quot;CFBundleShortVersionString&quot;];
<a name="l04376"></a>04376                         <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *developmentVersionNumber = [bundle objectForInfoDictionaryKey:@&quot;CFBundleVersion&quot;];
<a name="l04377"></a>04377                         <span class="keywordflow">if</span> (marketingVersionNumber &amp;&amp; developmentVersionNumber) {
<a name="l04378"></a>04378                                 <span class="keywordflow">if</span> ([marketingVersionNumber isEqualToString:developmentVersionNumber]) {
<a name="l04379"></a>04379                                         appVersion = marketingVersionNumber;
<a name="l04380"></a>04380                                 } <span class="keywordflow">else</span> {
<a name="l04381"></a>04381                                         appVersion = [<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> stringWithFormat:@&quot;%@ rv:%@&quot;,marketingVersionNumber,developmentVersionNumber];
<a name="l04382"></a>04382                                 }
<a name="l04383"></a>04383                         } <span class="keywordflow">else</span> {
<a name="l04384"></a>04384                                 appVersion = (marketingVersionNumber ? marketingVersionNumber : developmentVersionNumber);
<a name="l04385"></a>04385                         }
<a name="l04386"></a>04386 
<a name="l04387"></a>04387                         <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *deviceName;
<a name="l04388"></a>04388                         <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *OSName;
<a name="l04389"></a>04389                         <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *OSVersion;
<a name="l04390"></a>04390                         <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *locale = [[NSLocale currentLocale] localeIdentifier];
<a name="l04391"></a>04391 
<a name="l04392"></a>04392 <span class="preprocessor">                        #if TARGET_OS_IPHONE</span>
<a name="l04393"></a>04393 <span class="preprocessor"></span>                                UIDevice *device = [UIDevice currentDevice];
<a name="l04394"></a>04394                                 deviceName = [device model];
<a name="l04395"></a>04395                                 OSName = [device systemName];
<a name="l04396"></a>04396                                 OSVersion = [device systemVersion];
<a name="l04397"></a>04397 
<a name="l04398"></a>04398 <span class="preprocessor">                        #else</span>
<a name="l04399"></a>04399 <span class="preprocessor"></span>                                deviceName = <span class="stringliteral">@&quot;Macintosh&quot;</span>;
<a name="l04400"></a>04400                                 OSName = <span class="stringliteral">@&quot;Mac OS X&quot;</span>;
<a name="l04401"></a>04401 
<a name="l04402"></a>04402                                 <span class="comment">// From http://www.cocoadev.com/index.pl?DeterminingOSVersion</span>
<a name="l04403"></a>04403                                 <span class="comment">// We won&#39;t bother to check for systems prior to 10.4, since ASIHTTPRequest only works on 10.5+</span>
<a name="l04404"></a>04404                                 OSErr err;
<a name="l04405"></a>04405                                 SInt32 versionMajor, versionMinor, versionBugFix;
<a name="l04406"></a>04406                                 err = Gestalt(gestaltSystemVersionMajor, &amp;versionMajor);
<a name="l04407"></a>04407                                 <span class="keywordflow">if</span> (err != noErr) <span class="keywordflow">return</span> nil;
<a name="l04408"></a>04408                                 err = Gestalt(gestaltSystemVersionMinor, &amp;versionMinor);
<a name="l04409"></a>04409                                 <span class="keywordflow">if</span> (err != noErr) <span class="keywordflow">return</span> nil;
<a name="l04410"></a>04410                                 err = Gestalt(gestaltSystemVersionBugFix, &amp;versionBugFix);
<a name="l04411"></a>04411                                 <span class="keywordflow">if</span> (err != noErr) <span class="keywordflow">return</span> nil;
<a name="l04412"></a>04412                                 OSVersion = [<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> stringWithFormat:@&quot;%u.%u.%u&quot;, versionMajor, versionMinor, versionBugFix];
<a name="l04413"></a>04413 <span class="preprocessor">                        #endif</span>
<a name="l04414"></a>04414 <span class="preprocessor"></span>
<a name="l04415"></a>04415                         <span class="comment">// Takes the form &quot;My Application 1.0 (Macintosh; Mac OS X 10.5.7; en_GB)&quot;</span>
<a name="l04416"></a>04416                         [<span class="keyword">self</span> setDefaultUserAgentString:[<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> stringWithFormat:@&quot;%@ %@ (%@; %@ %@; %@)&quot;, appName, appVersion, deviceName, OSName, OSVersion, locale]];      
<a name="l04417"></a>04417                 }
<a name="l04418"></a>04418                 <span class="keywordflow">return</span> [[defaultUserAgent retain] autorelease];
<a name="l04419"></a>04419         }
<a name="l04420"></a>04420 }
<a name="l04421"></a>04421 
<a name="l04422"></a>04422 + (void)setDefaultUserAgentString:(<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)agent
<a name="l04423"></a>04423 {
<a name="l04424"></a>04424         @<span class="keyword">synchronized</span> (<span class="keyword">self</span>) {
<a name="l04425"></a>04425                 <span class="keywordflow">if</span> (defaultUserAgent == agent) {
<a name="l04426"></a>04426                         <span class="keywordflow">return</span>;
<a name="l04427"></a>04427                 }
<a name="l04428"></a>04428                 [defaultUserAgent release];
<a name="l04429"></a>04429                 defaultUserAgent = [agent copy];
<a name="l04430"></a>04430         }
<a name="l04431"></a>04431 }
<a name="l04432"></a>04432 
<a name="l04433"></a>04433 
<a name="l04434"></a>04434 <span class="preprocessor">#pragma mark mime-type detection</span>
<a name="l04435"></a>04435 <span class="preprocessor"></span>
<a name="l04436"></a>04436 + (<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)mimeTypeForFileAtPath:(<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)path
<a name="l04437"></a>04437 {
<a name="l04438"></a>04438         <span class="keywordflow">if</span> (![[[[NSFileManager alloc] init] autorelease] fileExistsAtPath:path]) {
<a name="l04439"></a>04439                 <span class="keywordflow">return</span> nil;
<a name="l04440"></a>04440         }
<a name="l04441"></a>04441         <span class="comment">// Borrowed from http://stackoverflow.com/questions/2439020/wheres-the-iphone-mime-type-database</span>
<a name="l04442"></a>04442         CFStringRef UTI = UTTypeCreatePreferredIdentifierForTag(kUTTagClassFilenameExtension, (CFStringRef)[path pathExtension], NULL);
<a name="l04443"></a>04443     CFStringRef MIMEType = UTTypeCopyPreferredTagWithClass (UTI, kUTTagClassMIMEType);
<a name="l04444"></a>04444     CFRelease(UTI);
<a name="l04445"></a>04445         <span class="keywordflow">if</span> (!MIMEType) {
<a name="l04446"></a>04446                 <span class="keywordflow">return</span> <span class="stringliteral">@&quot;application/octet-stream&quot;</span>;
<a name="l04447"></a>04447         }
<a name="l04448"></a>04448     <span class="keywordflow">return</span> NSMakeCollectable([(<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)MIMEType autorelease]);
<a name="l04449"></a>04449 }
<a name="l04450"></a>04450 
<a name="l04451"></a>04451 <span class="preprocessor">#pragma mark bandwidth measurement / throttling</span>
<a name="l04452"></a>04452 <span class="preprocessor"></span>
<a name="l04453"></a>04453 - (void)performThrottling
<a name="l04454"></a>04454 {
<a name="l04455"></a>04455         <span class="keywordflow">if</span> (![<span class="keyword">self</span> readStream]) {
<a name="l04456"></a>04456                 <span class="keywordflow">return</span>;
<a name="l04457"></a>04457         }
<a name="l04458"></a>04458         [ASIHTTPRequest measureBandwidthUsage];
<a name="l04459"></a>04459         <span class="keywordflow">if</span> ([ASIHTTPRequest isBandwidthThrottled]) {
<a name="l04460"></a>04460                 [bandwidthThrottlingLock lock];
<a name="l04461"></a>04461                 <span class="comment">// Handle throttling</span>
<a name="l04462"></a>04462                 <span class="keywordflow">if</span> (throttleWakeUpTime) {
<a name="l04463"></a>04463                         <span class="keywordflow">if</span> ([throttleWakeUpTime timeIntervalSinceDate:[NSDate date]] &gt; 0) {
<a name="l04464"></a>04464                                 <span class="keywordflow">if</span> ([<span class="keyword">self</span> readStreamIsScheduled]) {
<a name="l04465"></a>04465                                         [<span class="keyword">self</span> unscheduleReadStream];
<a name="l04466"></a>04466 <span class="preprocessor">                                        #if DEBUG_THROTTLING</span>
<a name="l04467"></a>04467 <span class="preprocessor"></span>                                        NSLog(<span class="stringliteral">@&quot;[THROTTLING] Sleeping request %@ until after %@&quot;</span>,<span class="keyword">self</span>,throttleWakeUpTime);
<a name="l04468"></a>04468 <span class="preprocessor">                                        #endif</span>
<a name="l04469"></a>04469 <span class="preprocessor"></span>                                }
<a name="l04470"></a>04470                         } <span class="keywordflow">else</span> {
<a name="l04471"></a>04471                                 <span class="keywordflow">if</span> (![<span class="keyword">self</span> readStreamIsScheduled]) {
<a name="l04472"></a>04472                                         [<span class="keyword">self</span> scheduleReadStream];
<a name="l04473"></a>04473 <span class="preprocessor">                                        #if DEBUG_THROTTLING</span>
<a name="l04474"></a>04474 <span class="preprocessor"></span>                                        NSLog(<span class="stringliteral">@&quot;[THROTTLING] Waking up request %@&quot;</span>,<span class="keyword">self</span>);
<a name="l04475"></a>04475 <span class="preprocessor">                                        #endif</span>
<a name="l04476"></a>04476 <span class="preprocessor"></span>                                }
<a name="l04477"></a>04477                         }
<a name="l04478"></a>04478                 } 
<a name="l04479"></a>04479                 [bandwidthThrottlingLock unlock];
<a name="l04480"></a>04480                 
<a name="l04481"></a>04481         <span class="comment">// Bandwidth throttling must have been turned off since we last looked, let&#39;s re-schedule the stream</span>
<a name="l04482"></a>04482         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (![<span class="keyword">self</span> readStreamIsScheduled]) {
<a name="l04483"></a>04483                 [<span class="keyword">self</span> scheduleReadStream];                      
<a name="l04484"></a>04484         }
<a name="l04485"></a>04485 }
<a name="l04486"></a>04486 
<a name="l04487"></a>04487 + (BOOL)isBandwidthThrottled
<a name="l04488"></a>04488 {
<a name="l04489"></a>04489 <span class="preprocessor">#if TARGET_OS_IPHONE</span>
<a name="l04490"></a>04490 <span class="preprocessor"></span>        [bandwidthThrottlingLock lock];
<a name="l04491"></a>04491 
<a name="l04492"></a>04492         BOOL throttle = isBandwidthThrottled || (!shouldThrottleBandwithForWWANOnly &amp;&amp; (maxBandwidthPerSecond &gt; 0));
<a name="l04493"></a>04493         [bandwidthThrottlingLock unlock];
<a name="l04494"></a>04494         <span class="keywordflow">return</span> throttle;
<a name="l04495"></a>04495 <span class="preprocessor">#else</span>
<a name="l04496"></a>04496 <span class="preprocessor"></span>        [bandwidthThrottlingLock lock];
<a name="l04497"></a>04497         BOOL throttle = (maxBandwidthPerSecond &gt; 0);
<a name="l04498"></a>04498         [bandwidthThrottlingLock unlock];
<a name="l04499"></a>04499         <span class="keywordflow">return</span> throttle;
<a name="l04500"></a>04500 <span class="preprocessor">#endif</span>
<a name="l04501"></a>04501 <span class="preprocessor"></span>}
<a name="l04502"></a>04502 
<a name="l04503"></a>04503 + (<span class="keywordtype">unsigned</span> long)maxBandwidthPerSecond
<a name="l04504"></a>04504 {
<a name="l04505"></a>04505         [bandwidthThrottlingLock lock];
<a name="l04506"></a>04506         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> amount = maxBandwidthPerSecond;
<a name="l04507"></a>04507         [bandwidthThrottlingLock unlock];
<a name="l04508"></a>04508         <span class="keywordflow">return</span> amount;
<a name="l04509"></a>04509 }
<a name="l04510"></a>04510 
<a name="l04511"></a>04511 + (void)setMaxBandwidthPerSecond:(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)bytes
<a name="l04512"></a>04512 {
<a name="l04513"></a>04513         [bandwidthThrottlingLock lock];
<a name="l04514"></a>04514         maxBandwidthPerSecond = bytes;
<a name="l04515"></a>04515         [bandwidthThrottlingLock unlock];
<a name="l04516"></a>04516 }
<a name="l04517"></a>04517 
<a name="l04518"></a>04518 + (void)incrementBandwidthUsedInLastSecond:(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)bytes
<a name="l04519"></a>04519 {
<a name="l04520"></a>04520         [bandwidthThrottlingLock lock];
<a name="l04521"></a>04521         bandwidthUsedInLastSecond += bytes;
<a name="l04522"></a>04522         [bandwidthThrottlingLock unlock];
<a name="l04523"></a>04523 }
<a name="l04524"></a>04524 
<a name="l04525"></a>04525 + (void)recordBandwidthUsage
<a name="l04526"></a>04526 {
<a name="l04527"></a>04527         <span class="keywordflow">if</span> (bandwidthUsedInLastSecond == 0) {
<a name="l04528"></a>04528                 [bandwidthUsageTracker removeAllObjects];
<a name="l04529"></a>04529         } <span class="keywordflow">else</span> {
<a name="l04530"></a>04530                 NSTimeInterval interval = [bandwidthMeasurementDate timeIntervalSinceNow];
<a name="l04531"></a>04531                 <span class="keywordflow">while</span> ((interval &lt; 0 || [bandwidthUsageTracker count] &gt; 5) &amp;&amp; [bandwidthUsageTracker count] &gt; 0) {
<a name="l04532"></a>04532                         [bandwidthUsageTracker removeObjectAtIndex:0];
<a name="l04533"></a>04533                         interval++;
<a name="l04534"></a>04534                 }
<a name="l04535"></a>04535         }
<a name="l04536"></a>04536 <span class="preprocessor">        #if DEBUG_THROTTLING</span>
<a name="l04537"></a>04537 <span class="preprocessor"></span>        NSLog(<span class="stringliteral">@&quot;[THROTTLING] ===Used: %u bytes of bandwidth in last measurement period===&quot;</span>,bandwidthUsedInLastSecond);
<a name="l04538"></a>04538 <span class="preprocessor">        #endif</span>
<a name="l04539"></a>04539 <span class="preprocessor"></span>        [bandwidthUsageTracker addObject:[NSNumber numberWithUnsignedLong:bandwidthUsedInLastSecond]];
<a name="l04540"></a>04540         [bandwidthMeasurementDate release];
<a name="l04541"></a>04541         bandwidthMeasurementDate = [[NSDate dateWithTimeIntervalSinceNow:1] retain];
<a name="l04542"></a>04542         bandwidthUsedInLastSecond = 0;
<a name="l04543"></a>04543         
<a name="l04544"></a>04544         NSUInteger measurements = [bandwidthUsageTracker count];
<a name="l04545"></a>04545         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> totalBytes = 0;
<a name="l04546"></a>04546         <span class="keywordflow">for</span> (NSNumber *bytes in bandwidthUsageTracker) {
<a name="l04547"></a>04547                 totalBytes += [bytes unsignedLongValue];
<a name="l04548"></a>04548         }
<a name="l04549"></a>04549         averageBandwidthUsedPerSecond = totalBytes/measurements;                
<a name="l04550"></a>04550 }
<a name="l04551"></a>04551 
<a name="l04552"></a>04552 + (<span class="keywordtype">unsigned</span> long)averageBandwidthUsedPerSecond
<a name="l04553"></a>04553 {
<a name="l04554"></a>04554         [bandwidthThrottlingLock lock];
<a name="l04555"></a>04555         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> amount =  averageBandwidthUsedPerSecond;
<a name="l04556"></a>04556         [bandwidthThrottlingLock unlock];
<a name="l04557"></a>04557         <span class="keywordflow">return</span> amount;
<a name="l04558"></a>04558 }
<a name="l04559"></a>04559 
<a name="l04560"></a>04560 + (void)measureBandwidthUsage
<a name="l04561"></a>04561 {
<a name="l04562"></a>04562         <span class="comment">// Other requests may have to wait for this lock if we&#39;re sleeping, but this is fine, since in that case we already know they shouldn&#39;t be sending or receiving data</span>
<a name="l04563"></a>04563         [bandwidthThrottlingLock lock];
<a name="l04564"></a>04564 
<a name="l04565"></a>04565         <span class="keywordflow">if</span> (!bandwidthMeasurementDate || [bandwidthMeasurementDate timeIntervalSinceNow] &lt; -0) {
<a name="l04566"></a>04566                 [ASIHTTPRequest recordBandwidthUsage];
<a name="l04567"></a>04567         }
<a name="l04568"></a>04568         
<a name="l04569"></a>04569         <span class="comment">// Are we performing bandwidth throttling?</span>
<a name="l04570"></a>04570         <span class="keywordflow">if</span> (
<a name="l04571"></a>04571         #<span class="keywordflow">if</span> TARGET_OS_IPHONE
<a name="l04572"></a>04572         isBandwidthThrottled || (!shouldThrottleBandwithForWWANOnly &amp;&amp; (maxBandwidthPerSecond))
<a name="l04573"></a>04573         #<span class="keywordflow">else</span>
<a name="l04574"></a>04574         maxBandwidthPerSecond
<a name="l04575"></a>04575         #endif
<a name="l04576"></a>04576         ) {
<a name="l04577"></a>04577                 <span class="comment">// How much data can we still send or receive this second?</span>
<a name="l04578"></a>04578                 <span class="keywordtype">long</span> <span class="keywordtype">long</span> bytesRemaining = (<span class="keywordtype">long</span> long)maxBandwidthPerSecond - (<span class="keywordtype">long</span> <span class="keywordtype">long</span>)bandwidthUsedInLastSecond;
<a name="l04579"></a>04579                         
<a name="l04580"></a>04580                 <span class="comment">// Have we used up our allowance?</span>
<a name="l04581"></a>04581                 <span class="keywordflow">if</span> (bytesRemaining &lt; 0) {
<a name="l04582"></a>04582                         
<a name="l04583"></a>04583                         <span class="comment">// Yes, put this request to sleep until a second is up, with extra added punishment sleeping time for being very naughty (we have used more bandwidth than we were allowed)</span>
<a name="l04584"></a>04584                         <span class="keywordtype">double</span> extraSleepyTime = (-bytesRemaining/(maxBandwidthPerSecond*1.0));
<a name="l04585"></a>04585                         [throttleWakeUpTime release];
<a name="l04586"></a>04586                         throttleWakeUpTime = [[NSDate alloc] initWithTimeInterval:extraSleepyTime sinceDate:bandwidthMeasurementDate];
<a name="l04587"></a>04587                 }
<a name="l04588"></a>04588         }
<a name="l04589"></a>04589         [bandwidthThrottlingLock unlock];
<a name="l04590"></a>04590 }
<a name="l04591"></a>04591         
<a name="l04592"></a>04592 + (<span class="keywordtype">unsigned</span> long)maxUploadReadLength
<a name="l04593"></a>04593 {
<a name="l04594"></a>04594         [bandwidthThrottlingLock lock];
<a name="l04595"></a>04595         
<a name="l04596"></a>04596         <span class="comment">// We&#39;ll split our bandwidth allowance into 4 (which is the default for an ASINetworkQueue&#39;s max concurrent operations count) to give all running requests a fighting chance of reading data this cycle</span>
<a name="l04597"></a>04597         <span class="keywordtype">long</span> <span class="keywordtype">long</span> toRead = maxBandwidthPerSecond/4;
<a name="l04598"></a>04598         <span class="keywordflow">if</span> (maxBandwidthPerSecond &gt; 0 &amp;&amp; (bandwidthUsedInLastSecond + toRead &gt; maxBandwidthPerSecond)) {
<a name="l04599"></a>04599                 toRead = (<span class="keywordtype">long</span> long)maxBandwidthPerSecond-(<span class="keywordtype">long</span> <span class="keywordtype">long</span>)bandwidthUsedInLastSecond;
<a name="l04600"></a>04600                 <span class="keywordflow">if</span> (toRead &lt; 0) {
<a name="l04601"></a>04601                         toRead = 0;
<a name="l04602"></a>04602                 }
<a name="l04603"></a>04603         }
<a name="l04604"></a>04604         
<a name="l04605"></a>04605         <span class="keywordflow">if</span> (toRead == 0 || !bandwidthMeasurementDate || [bandwidthMeasurementDate timeIntervalSinceNow] &lt; -0) {
<a name="l04606"></a>04606                 [throttleWakeUpTime release];
<a name="l04607"></a>04607                 throttleWakeUpTime = [bandwidthMeasurementDate retain];
<a name="l04608"></a>04608         }
<a name="l04609"></a>04609         [bandwidthThrottlingLock unlock];       
<a name="l04610"></a>04610         <span class="keywordflow">return</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)toRead;
<a name="l04611"></a>04611 }
<a name="l04612"></a>04612         
<a name="l04613"></a>04613 
<a name="l04614"></a>04614 <span class="preprocessor">#if TARGET_OS_IPHONE</span>
<a name="l04615"></a>04615 <span class="preprocessor"></span>+ (void)setShouldThrottleBandwidthForWWAN:(BOOL)throttle
<a name="l04616"></a>04616 {
<a name="l04617"></a>04617         <span class="keywordflow">if</span> (throttle) {
<a name="l04618"></a>04618                 [ASIHTTPRequest throttleBandwidthForWWANUsingLimit:ASIWWANBandwidthThrottleAmount];
<a name="l04619"></a>04619         } <span class="keywordflow">else</span> {
<a name="l04620"></a>04620                 [ASIHTTPRequest unsubscribeFromNetworkReachabilityNotifications];
<a name="l04621"></a>04621                 [ASIHTTPRequest setMaxBandwidthPerSecond:0];
<a name="l04622"></a>04622                 [bandwidthThrottlingLock lock];
<a name="l04623"></a>04623                 isBandwidthThrottled = NO;
<a name="l04624"></a>04624                 shouldThrottleBandwithForWWANOnly = NO;
<a name="l04625"></a>04625                 [bandwidthThrottlingLock unlock];
<a name="l04626"></a>04626         }
<a name="l04627"></a>04627 }
<a name="l04628"></a>04628 
<a name="l04629"></a>04629 + (void)throttleBandwidthForWWANUsingLimit:(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)limit
<a name="l04630"></a>04630 {       
<a name="l04631"></a>04631         [bandwidthThrottlingLock lock];
<a name="l04632"></a>04632         shouldThrottleBandwithForWWANOnly = YES;
<a name="l04633"></a>04633         maxBandwidthPerSecond = limit;
<a name="l04634"></a>04634         [ASIHTTPRequest registerForNetworkReachabilityNotifications];   
<a name="l04635"></a>04635         [bandwidthThrottlingLock unlock];
<a name="l04636"></a>04636         [ASIHTTPRequest reachabilityChanged:nil];
<a name="l04637"></a>04637 }
<a name="l04638"></a>04638 
<a name="l04639"></a>04639 <span class="preprocessor">#pragma mark reachability</span>
<a name="l04640"></a>04640 <span class="preprocessor"></span>
<a name="l04641"></a>04641 + (void)registerForNetworkReachabilityNotifications
<a name="l04642"></a>04642 {
<a name="l04643"></a>04643         [[Reachability reachabilityForInternetConnection] startNotifier];
<a name="l04644"></a>04644         [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(reachabilityChanged:) name:kReachabilityChangedNotification object:nil];
<a name="l04645"></a>04645 }
<a name="l04646"></a>04646 
<a name="l04647"></a>04647 
<a name="l04648"></a>04648 + (void)unsubscribeFromNetworkReachabilityNotifications
<a name="l04649"></a>04649 {
<a name="l04650"></a>04650         [[NSNotificationCenter defaultCenter] removeObserver:self name:kReachabilityChangedNotification object:nil];
<a name="l04651"></a>04651 }
<a name="l04652"></a>04652 
<a name="l04653"></a>04653 + (BOOL)isNetworkReachableViaWWAN
<a name="l04654"></a>04654 {
<a name="l04655"></a>04655         <span class="keywordflow">return</span> ([[Reachability reachabilityForInternetConnection] currentReachabilityStatus] == ReachableViaWWAN);      
<a name="l04656"></a>04656 }
<a name="l04657"></a>04657 
<a name="l04658"></a>04658 + (void)reachabilityChanged:(NSNotification *)note
<a name="l04659"></a>04659 {
<a name="l04660"></a>04660         [bandwidthThrottlingLock lock];
<a name="l04661"></a>04661         isBandwidthThrottled = [ASIHTTPRequest isNetworkReachableViaWWAN];
<a name="l04662"></a>04662         [bandwidthThrottlingLock unlock];
<a name="l04663"></a>04663 }
<a name="l04664"></a>04664 <span class="preprocessor">#endif</span>
<a name="l04665"></a>04665 <span class="preprocessor"></span>
<a name="l04666"></a>04666 <span class="preprocessor">#pragma mark queue</span>
<a name="l04667"></a>04667 <span class="preprocessor"></span>
<a name="l04668"></a>04668 <span class="comment">// Returns the shared queue</span>
<a name="l04669"></a>04669 + (NSOperationQueue *)sharedQueue
<a name="l04670"></a>04670 {
<a name="l04671"></a>04671     <span class="keywordflow">return</span> [[sharedQueue retain] autorelease];
<a name="l04672"></a>04672 }
<a name="l04673"></a>04673 
<a name="l04674"></a>04674 <span class="preprocessor">#pragma mark cache</span>
<a name="l04675"></a>04675 <span class="preprocessor"></span>
<a name="l04676"></a>04676 + (void)setDefaultCache:(<span class="keywordtype">id</span> &lt;ASICacheDelegate&gt;)cache
<a name="l04677"></a>04677 {
<a name="l04678"></a>04678         @<span class="keyword">synchronized</span> (<span class="keyword">self</span>) {
<a name="l04679"></a>04679                 [cache retain];
<a name="l04680"></a>04680                 [defaultCache release];
<a name="l04681"></a>04681                 defaultCache = cache;
<a name="l04682"></a>04682         }
<a name="l04683"></a>04683 }
<a name="l04684"></a>04684 
<a name="l04685"></a>04685 + (<span class="keywordtype">id</span> &lt;ASICacheDelegate&gt;)defaultCache
<a name="l04686"></a>04686 {
<a name="l04687"></a>04687     @<span class="keyword">synchronized</span>(<span class="keyword">self</span>) {
<a name="l04688"></a>04688         <span class="keywordflow">return</span> [[defaultCache retain] autorelease];
<a name="l04689"></a>04689     }
<a name="l04690"></a>04690 }
<a name="l04691"></a>04691 
<a name="l04692"></a>04692 
<a name="l04693"></a>04693 <span class="preprocessor">#pragma mark network activity</span>
<a name="l04694"></a>04694 <span class="preprocessor"></span>
<a name="l04695"></a>04695 + (BOOL)isNetworkInUse
<a name="l04696"></a>04696 {
<a name="l04697"></a>04697         [connectionsLock lock];
<a name="l04698"></a>04698         BOOL inUse = (runningRequestCount &gt; 0);
<a name="l04699"></a>04699         [connectionsLock unlock];
<a name="l04700"></a>04700         <span class="keywordflow">return</span> inUse;
<a name="l04701"></a>04701 }
<a name="l04702"></a>04702 
<a name="l04703"></a>04703 + (void)setShouldUpdateNetworkActivityIndicator:(BOOL)shouldUpdate
<a name="l04704"></a>04704 {
<a name="l04705"></a>04705         [connectionsLock lock];
<a name="l04706"></a>04706         shouldUpdateNetworkActivityIndicator = shouldUpdate;
<a name="l04707"></a>04707         [connectionsLock unlock];
<a name="l04708"></a>04708 }
<a name="l04709"></a>04709 
<a name="l04710"></a>04710 + (void)showNetworkActivityIndicator
<a name="l04711"></a>04711 {
<a name="l04712"></a>04712 <span class="preprocessor">#if TARGET_OS_IPHONE</span>
<a name="l04713"></a>04713 <span class="preprocessor"></span>        [[UIApplication sharedApplication] setNetworkActivityIndicatorVisible:YES];
<a name="l04714"></a>04714 <span class="preprocessor">#endif</span>
<a name="l04715"></a>04715 <span class="preprocessor"></span>}
<a name="l04716"></a>04716 
<a name="l04717"></a>04717 + (void)hideNetworkActivityIndicator
<a name="l04718"></a>04718 {
<a name="l04719"></a>04719 <span class="preprocessor">#if TARGET_OS_IPHONE</span>
<a name="l04720"></a>04720 <span class="preprocessor"></span>        [[UIApplication sharedApplication] setNetworkActivityIndicatorVisible:NO];      
<a name="l04721"></a>04721 <span class="preprocessor">#endif</span>
<a name="l04722"></a>04722 <span class="preprocessor"></span>}
<a name="l04723"></a>04723 
<a name="l04724"></a>04724 
<a name="l04725"></a>04725 <span class="comment">/* Always called on main thread */</span>
<a name="l04726"></a>04726 + (void)hideNetworkActivityIndicatorAfterDelay
<a name="l04727"></a>04727 {
<a name="l04728"></a>04728         [<span class="keyword">self</span> performSelector:@selector(hideNetworkActivityIndicatorIfNeeeded) withObject:nil afterDelay:0.5];
<a name="l04729"></a>04729 }
<a name="l04730"></a>04730 
<a name="l04731"></a>04731 + (void)hideNetworkActivityIndicatorIfNeeeded
<a name="l04732"></a>04732 {
<a name="l04733"></a>04733         [connectionsLock lock];
<a name="l04734"></a>04734         <span class="keywordflow">if</span> (runningRequestCount == 0) {
<a name="l04735"></a>04735                 [<span class="keyword">self</span> hideNetworkActivityIndicator];
<a name="l04736"></a>04736         }
<a name="l04737"></a>04737         [connectionsLock unlock];
<a name="l04738"></a>04738 }
<a name="l04739"></a>04739 
<a name="l04740"></a>04740 
<a name="l04741"></a>04741 <span class="preprocessor">#pragma mark threading behaviour</span>
<a name="l04742"></a>04742 <span class="preprocessor"></span>
<a name="l04743"></a>04743 <span class="comment">// In the default implementation, all requests run in a single background thread</span>
<a name="l04744"></a>04744 <span class="comment">// Advanced users only: Override this method in a subclass for a different threading behaviour</span>
<a name="l04745"></a>04745 <span class="comment">// Eg: return [NSThread mainThread] to run all requests in the main thread</span>
<a name="l04746"></a>04746 <span class="comment">// Alternatively, you can create a thread on demand, or manage a pool of threads</span>
<a name="l04747"></a>04747 <span class="comment">// Threads returned by this method will need to run the runloop in default mode (eg CFRunLoopRun())</span>
<a name="l04748"></a>04748 <span class="comment">// Requests will stop the runloop when they complete</span>
<a name="l04749"></a>04749 <span class="comment">// If you have multiple requests sharing the thread or you want to re-use the thread, you&#39;ll need to restart the runloop</span>
<a name="l04750"></a>04750 + (NSThread *)threadForRequest:(ASIHTTPRequest *)request
<a name="l04751"></a>04751 {
<a name="l04752"></a>04752         <span class="keywordflow">if</span> (networkThread == nil) {
<a name="l04753"></a>04753                 @<span class="keyword">synchronized</span>(<span class="keyword">self</span>) {
<a name="l04754"></a>04754                         <span class="keywordflow">if</span> (networkThread == nil) {
<a name="l04755"></a>04755                                 networkThread = [[NSThread alloc] initWithTarget:self selector:@selector(runRequests) object:nil];
<a name="l04756"></a>04756                                 [networkThread start];
<a name="l04757"></a>04757                         }
<a name="l04758"></a>04758                 }
<a name="l04759"></a>04759         }
<a name="l04760"></a>04760         <span class="keywordflow">return</span> networkThread;
<a name="l04761"></a>04761 }
<a name="l04762"></a>04762 
<a name="l04763"></a>04763 + (void)runRequests
<a name="l04764"></a>04764 {
<a name="l04765"></a>04765         <span class="comment">// Should keep the runloop from exiting</span>
<a name="l04766"></a>04766         CFRunLoopSourceContext context = {0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
<a name="l04767"></a>04767         CFRunLoopSourceRef source = CFRunLoopSourceCreate(kCFAllocatorDefault, 0, &amp;context);
<a name="l04768"></a>04768         CFRunLoopAddSource(CFRunLoopGetCurrent(), source, kCFRunLoopDefaultMode);
<a name="l04769"></a>04769 
<a name="l04770"></a>04770     BOOL runAlways = YES; <span class="comment">// Introduced to cheat Static Analyzer</span>
<a name="l04771"></a>04771         <span class="keywordflow">while</span> (runAlways) {
<a name="l04772"></a>04772                 NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
<a name="l04773"></a>04773                 CFRunLoopRun();
<a name="l04774"></a>04774                 [pool release];
<a name="l04775"></a>04775         }
<a name="l04776"></a>04776 
<a name="l04777"></a>04777         <span class="comment">// Should never be called, but anyway</span>
<a name="l04778"></a>04778         CFRunLoopRemoveSource(CFRunLoopGetCurrent(), source, kCFRunLoopDefaultMode);
<a name="l04779"></a>04779         CFRelease(source);
<a name="l04780"></a>04780 }
<a name="l04781"></a>04781 
<a name="l04782"></a>04782 <span class="preprocessor">#pragma mark miscellany </span>
<a name="l04783"></a>04783 <span class="preprocessor"></span>
<a name="l04784"></a>04784 <span class="preprocessor">#if TARGET_OS_IPHONE</span>
<a name="l04785"></a>04785 <span class="preprocessor"></span>+ (BOOL)isMultitaskingSupported
<a name="l04786"></a>04786 {
<a name="l04787"></a>04787         BOOL multiTaskingSupported = NO;
<a name="l04788"></a>04788         <span class="keywordflow">if</span> ([[UIDevice currentDevice] respondsToSelector:<span class="keyword">@selector</span>(isMultitaskingSupported)]) {
<a name="l04789"></a>04789                 multiTaskingSupported = [(id)[UIDevice currentDevice] isMultitaskingSupported];
<a name="l04790"></a>04790         }
<a name="l04791"></a>04791         <span class="keywordflow">return</span> multiTaskingSupported;
<a name="l04792"></a>04792 }
<a name="l04793"></a>04793 <span class="preprocessor">#endif</span>
<a name="l04794"></a>04794 <span class="preprocessor"></span>
<a name="l04795"></a>04795 <span class="comment">// From: http://www.cocoadev.com/index.pl?BaseSixtyFour</span>
<a name="l04796"></a>04796 
<a name="l04797"></a>04797 + (<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a>*)base64forData:(<a class="code" href="class_n_s_data.html" title="For hashing raw data.">NSData</a>*)theData {
<a name="l04798"></a>04798         
<a name="l04799"></a>04799         <span class="keyword">const</span> uint8_t* input = (<span class="keyword">const</span> uint8_t*)[theData bytes];
<a name="l04800"></a>04800         NSInteger length = [theData length];
<a name="l04801"></a>04801         
<a name="l04802"></a>04802     <span class="keyword">static</span> <span class="keywordtype">char</span> table[] = <span class="stringliteral">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&quot;</span>;
<a name="l04803"></a>04803         
<a name="l04804"></a>04804     NSMutableData* data = [NSMutableData dataWithLength:((length + 2) / 3) * 4];
<a name="l04805"></a>04805     uint8_t* output = (uint8_t*)data.mutableBytes;
<a name="l04806"></a>04806         
<a name="l04807"></a>04807         NSInteger i,i2;
<a name="l04808"></a>04808     for (i=0; i &lt; length; i += 3) {
<a name="l04809"></a>04809         NSInteger value = 0;
<a name="l04810"></a>04810                 <span class="keywordflow">for</span> (i2=0; i2&lt;3; i2++) {
<a name="l04811"></a>04811             value &lt;&lt;= 8;
<a name="l04812"></a>04812             <span class="keywordflow">if</span> (i+i2 &lt; length) {
<a name="l04813"></a>04813                 value |= (0xFF &amp; input[i+i2]);
<a name="l04814"></a>04814             }
<a name="l04815"></a>04815         }
<a name="l04816"></a>04816                 
<a name="l04817"></a>04817         NSInteger theIndex = (i / 3) * 4;
<a name="l04818"></a>04818         output[theIndex + 0] =                    table[(value &gt;&gt; 18) &amp; 0x3F];
<a name="l04819"></a>04819         output[theIndex + 1] =                    table[(value &gt;&gt; 12) &amp; 0x3F];
<a name="l04820"></a>04820         output[theIndex + 2] = (i + 1) &lt; length ? table[(value &gt;&gt; 6)  &amp; 0x3F] : &#39;=&#39;;
<a name="l04821"></a>04821         output[theIndex + 3] = (i + 2) &lt; length ? table[(value &gt;&gt; 0)  &amp; 0x3F] : &#39;=&#39;;
<a name="l04822"></a>04822     }
<a name="l04823"></a>04823         
<a name="l04824"></a>04824     <span class="keywordflow">return</span> [[[<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> alloc] initWithData:data encoding:NSASCIIStringEncoding] autorelease];
<a name="l04825"></a>04825 }
<a name="l04826"></a>04826 
<a name="l04827"></a>04827 + (NSDate *)expiryDateForRequest:(ASIHTTPRequest *)request maxAge:(NSTimeInterval)maxAge
<a name="l04828"></a>04828 {
<a name="l04829"></a>04829         NSDictionary *responseHeaders = [request responseHeaders];
<a name="l04830"></a>04830   
<a name="l04831"></a>04831         <span class="comment">// If we weren&#39;t given a custom max-age, lets look for one in the response headers</span>
<a name="l04832"></a>04832         <span class="keywordflow">if</span> (!maxAge) {
<a name="l04833"></a>04833                 <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *cacheControl = [[responseHeaders objectForKey:@&quot;Cache-Control&quot;] lowercaseString];
<a name="l04834"></a>04834                 <span class="keywordflow">if</span> (cacheControl) {
<a name="l04835"></a>04835                         NSScanner *scanner = [NSScanner scannerWithString:cacheControl];
<a name="l04836"></a>04836                         [scanner scanUpToString:@&quot;max-age&quot; intoString:NULL];
<a name="l04837"></a>04837                         <span class="keywordflow">if</span> ([scanner scanString:<span class="stringliteral">@&quot;max-age&quot;</span> intoString:NULL]) {
<a name="l04838"></a>04838                                 [scanner scanString:@&quot;=&quot; intoString:NULL];
<a name="l04839"></a>04839                                 [scanner scanDouble:&amp;maxAge];
<a name="l04840"></a>04840                         }
<a name="l04841"></a>04841                 }
<a name="l04842"></a>04842         }
<a name="l04843"></a>04843   
<a name="l04844"></a>04844         <span class="comment">// RFC 2612 says max-age must override any Expires header</span>
<a name="l04845"></a>04845         <span class="keywordflow">if</span> (maxAge) {
<a name="l04846"></a>04846                 <span class="keywordflow">return</span> [[NSDate date] addTimeInterval:maxAge];
<a name="l04847"></a>04847         } <span class="keywordflow">else</span> {
<a name="l04848"></a>04848                 <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *expires = [responseHeaders objectForKey:@&quot;Expires&quot;];
<a name="l04849"></a>04849                 <span class="keywordflow">if</span> (expires) {
<a name="l04850"></a>04850                         <span class="keywordflow">return</span> [ASIHTTPRequest dateFromRFC1123String:expires];
<a name="l04851"></a>04851                 }
<a name="l04852"></a>04852         }
<a name="l04853"></a>04853         <span class="keywordflow">return</span> nil;
<a name="l04854"></a>04854 }
<a name="l04855"></a>04855 
<a name="l04856"></a>04856 <span class="comment">// Based on hints from http://stackoverflow.com/questions/1850824/parsing-a-rfc-822-date-with-nsdateformatter</span>
<a name="l04857"></a>04857 + (NSDate *)dateFromRFC1123String:(<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)string
<a name="l04858"></a>04858 {
<a name="l04859"></a>04859         NSDateFormatter *formatter = [[[NSDateFormatter alloc] init] autorelease];
<a name="l04860"></a>04860         [formatter setLocale:[[[NSLocale alloc] initWithLocaleIdentifier:@&quot;en_US_POSIX&quot;] autorelease]];
<a name="l04861"></a>04861         <span class="comment">// Does the string include a week day?</span>
<a name="l04862"></a>04862         <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *day = <span class="stringliteral">@&quot;&quot;</span>;
<a name="l04863"></a>04863         <span class="keywordflow">if</span> ([<span class="keywordtype">string</span> rangeOfString:<span class="stringliteral">@&quot;,&quot;</span>].location != NSNotFound) {
<a name="l04864"></a>04864                 day = <span class="stringliteral">@&quot;EEE, &quot;</span>;
<a name="l04865"></a>04865         }
<a name="l04866"></a>04866         <span class="comment">// Does the string include seconds?</span>
<a name="l04867"></a>04867         <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *seconds = <span class="stringliteral">@&quot;&quot;</span>;
<a name="l04868"></a>04868         <span class="keywordflow">if</span> ([[<span class="keywordtype">string</span> componentsSeparatedByString:<span class="stringliteral">@&quot;:&quot;</span>] count] == 3) {
<a name="l04869"></a>04869                 seconds = <span class="stringliteral">@&quot;:ss&quot;</span>;
<a name="l04870"></a>04870         }
<a name="l04871"></a>04871         [formatter setDateFormat:[<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> stringWithFormat:@&quot;%@dd MMM yyyy HH:mm%@ z&quot;,day,seconds]];
<a name="l04872"></a>04872         <span class="keywordflow">return</span> [formatter dateFromString:string];
<a name="l04873"></a>04873 }
<a name="l04874"></a>04874 
<a name="l04875"></a>04875 + (void)parseMimeType:(<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> **)mimeType andResponseEncoding:(NSStringEncoding *)stringEncoding fromContentType:(<a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *)contentType
<a name="l04876"></a>04876 {
<a name="l04877"></a>04877         <span class="keywordflow">if</span> (!contentType) {
<a name="l04878"></a>04878                 <span class="keywordflow">return</span>;
<a name="l04879"></a>04879         }
<a name="l04880"></a>04880         NSScanner *charsetScanner = [NSScanner scannerWithString: contentType];
<a name="l04881"></a>04881         <span class="keywordflow">if</span> (![charsetScanner scanUpToString:<span class="stringliteral">@&quot;;&quot;</span> intoString:mimeType] || [charsetScanner scanLocation] == [contentType length]) {
<a name="l04882"></a>04882                 *mimeType = [contentType stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];
<a name="l04883"></a>04883                 <span class="keywordflow">return</span>;
<a name="l04884"></a>04884         }
<a name="l04885"></a>04885         *mimeType = [*mimeType stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];
<a name="l04886"></a>04886         <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *charsetSeparator = <span class="stringliteral">@&quot;charset=&quot;</span>;
<a name="l04887"></a>04887         <a class="code" href="class_n_s_string.html" title="For manipulating NSStrings.">NSString</a> *IANAEncoding = nil;
<a name="l04888"></a>04888 
<a name="l04889"></a>04889         <span class="keywordflow">if</span> ([charsetScanner scanUpToString: charsetSeparator intoString: NULL] &amp;&amp; [charsetScanner scanLocation] &lt; [contentType length]) {
<a name="l04890"></a>04890                 [charsetScanner setScanLocation: [charsetScanner scanLocation] + [charsetSeparator length]];
<a name="l04891"></a>04891                 [charsetScanner scanUpToString: @&quot;;&quot; intoString: &amp;IANAEncoding];
<a name="l04892"></a>04892         }
<a name="l04893"></a>04893 
<a name="l04894"></a>04894         <span class="keywordflow">if</span> (IANAEncoding) {
<a name="l04895"></a>04895                 CFStringEncoding cfEncoding = CFStringConvertIANACharSetNameToEncoding((CFStringRef)IANAEncoding);
<a name="l04896"></a>04896                 <span class="keywordflow">if</span> (cfEncoding != kCFStringEncodingInvalidId) {
<a name="l04897"></a>04897                         *stringEncoding = CFStringConvertEncodingToNSStringEncoding(cfEncoding);
<a name="l04898"></a>04898                 }
<a name="l04899"></a>04899         }
<a name="l04900"></a>04900 }
<a name="l04901"></a>04901 
<a name="l04902"></a>04902 <span class="preprocessor">#pragma mark -</span>
<a name="l04903"></a>04903 <span class="preprocessor"></span><span class="preprocessor">#pragma mark blocks</span>
<a name="l04904"></a>04904 <span class="preprocessor"></span><span class="preprocessor">#if NS_BLOCKS_AVAILABLE</span>
<a name="l04905"></a>04905 <span class="preprocessor"></span>- (void)setStartedBlock:(ASIBasicBlock)aStartedBlock
<a name="l04906"></a>04906 {
<a name="l04907"></a>04907         [startedBlock release];
<a name="l04908"></a>04908         startedBlock = [aStartedBlock copy];
<a name="l04909"></a>04909 }
<a name="l04910"></a>04910 
<a name="l04911"></a>04911 - (void)setHeadersReceivedBlock:(ASIHeadersBlock)aReceivedBlock
<a name="l04912"></a>04912 {
<a name="l04913"></a>04913         [headersReceivedBlock release];
<a name="l04914"></a>04914         headersReceivedBlock = [aReceivedBlock copy];
<a name="l04915"></a>04915 }
<a name="l04916"></a>04916 
<a name="l04917"></a>04917 - (void)setCompletionBlock:(ASIBasicBlock)aCompletionBlock
<a name="l04918"></a>04918 {
<a name="l04919"></a>04919         [completionBlock release];
<a name="l04920"></a>04920         completionBlock = [aCompletionBlock copy];
<a name="l04921"></a>04921 }
<a name="l04922"></a>04922 
<a name="l04923"></a>04923 - (void)setFailedBlock:(ASIBasicBlock)aFailedBlock
<a name="l04924"></a>04924 {
<a name="l04925"></a>04925         [failureBlock release];
<a name="l04926"></a>04926         failureBlock = [aFailedBlock copy];
<a name="l04927"></a>04927 }
<a name="l04928"></a>04928 
<a name="l04929"></a>04929 - (void)setBytesReceivedBlock:(ASIProgressBlock)aBytesReceivedBlock
<a name="l04930"></a>04930 {
<a name="l04931"></a>04931         [bytesReceivedBlock release];
<a name="l04932"></a>04932         bytesReceivedBlock = [aBytesReceivedBlock copy];
<a name="l04933"></a>04933 }
<a name="l04934"></a>04934 
<a name="l04935"></a>04935 - (void)setBytesSentBlock:(ASIProgressBlock)aBytesSentBlock
<a name="l04936"></a>04936 {
<a name="l04937"></a>04937         [bytesSentBlock release];
<a name="l04938"></a>04938         bytesSentBlock = [aBytesSentBlock copy];
<a name="l04939"></a>04939 }
<a name="l04940"></a>04940 
<a name="l04941"></a>04941 - (void)setDownloadSizeIncrementedBlock:(ASISizeBlock)aDownloadSizeIncrementedBlock{
<a name="l04942"></a>04942         [downloadSizeIncrementedBlock release];
<a name="l04943"></a>04943         downloadSizeIncrementedBlock = [aDownloadSizeIncrementedBlock copy];
<a name="l04944"></a>04944 }
<a name="l04945"></a>04945 
<a name="l04946"></a>04946 - (void)setUploadSizeIncrementedBlock:(ASISizeBlock)anUploadSizeIncrementedBlock
<a name="l04947"></a>04947 {
<a name="l04948"></a>04948         [uploadSizeIncrementedBlock release];
<a name="l04949"></a>04949         uploadSizeIncrementedBlock = [anUploadSizeIncrementedBlock copy];
<a name="l04950"></a>04950 }
<a name="l04951"></a>04951 
<a name="l04952"></a>04952 - (void)setDataReceivedBlock:(ASIDataBlock)aReceivedBlock
<a name="l04953"></a>04953 {
<a name="l04954"></a>04954         [dataReceivedBlock release];
<a name="l04955"></a>04955         dataReceivedBlock = [aReceivedBlock copy];
<a name="l04956"></a>04956 }
<a name="l04957"></a>04957 
<a name="l04958"></a>04958 - (void)setAuthenticationNeededBlock:(ASIBasicBlock)anAuthenticationBlock
<a name="l04959"></a>04959 {
<a name="l04960"></a>04960         [authenticationNeededBlock release];
<a name="l04961"></a>04961         authenticationNeededBlock = [anAuthenticationBlock copy];
<a name="l04962"></a>04962 }
<a name="l04963"></a>04963 - (void)setProxyAuthenticationNeededBlock:(ASIBasicBlock)aProxyAuthenticationBlock
<a name="l04964"></a>04964 {
<a name="l04965"></a>04965         [proxyAuthenticationNeededBlock release];
<a name="l04966"></a>04966         proxyAuthenticationNeededBlock = [aProxyAuthenticationBlock copy];
<a name="l04967"></a>04967 }
<a name="l04968"></a>04968 - (void)setRequestRedirectedBlock:(ASIBasicBlock)aRedirectBlock
<a name="l04969"></a>04969 {
<a name="l04970"></a>04970         [requestRedirectedBlock release];
<a name="l04971"></a>04971         requestRedirectedBlock = [aRedirectBlock copy];
<a name="l04972"></a>04972 }
<a name="l04973"></a>04973 <span class="preprocessor">#endif</span>
<a name="l04974"></a>04974 <span class="preprocessor"></span>
<a name="l04975"></a>04975 <span class="preprocessor">#pragma mark ===</span>
<a name="l04976"></a>04976 <span class="preprocessor"></span>
<a name="l04977"></a>04977 <span class="keyword">@synthesize</span> username;
<a name="l04978"></a>04978 <span class="keyword">@synthesize</span> password;
<a name="l04979"></a>04979 <span class="keyword">@synthesize</span> userAgent;
<a name="l04980"></a>04980 <span class="keyword">@synthesize</span> domain;
<a name="l04981"></a>04981 <span class="keyword">@synthesize</span> proxyUsername;
<a name="l04982"></a>04982 <span class="keyword">@synthesize</span> proxyPassword;
<a name="l04983"></a>04983 <span class="keyword">@synthesize</span> proxyDomain;
<a name="l04984"></a>04984 <span class="keyword">@synthesize</span> url;
<a name="l04985"></a>04985 <span class="keyword">@synthesize</span> originalURL;
<a name="l04986"></a>04986 <span class="keyword">@synthesize</span> delegate;
<a name="l04987"></a>04987 <span class="keyword">@synthesize</span> queue;
<a name="l04988"></a>04988 <span class="keyword">@synthesize</span> uploadProgressDelegate;
<a name="l04989"></a>04989 <span class="keyword">@synthesize</span> downloadProgressDelegate;
<a name="l04990"></a>04990 <span class="keyword">@synthesize</span> useKeychainPersistence;
<a name="l04991"></a>04991 <span class="keyword">@synthesize</span> useSessionPersistence;
<a name="l04992"></a>04992 <span class="keyword">@synthesize</span> useCookiePersistence;
<a name="l04993"></a>04993 <span class="keyword">@synthesize</span> downloadDestinationPath;
<a name="l04994"></a>04994 <span class="keyword">@synthesize</span> temporaryFileDownloadPath;
<a name="l04995"></a>04995 <span class="keyword">@synthesize</span> temporaryUncompressedDataDownloadPath;
<a name="l04996"></a>04996 <span class="keyword">@synthesize</span> didStartSelector;
<a name="l04997"></a>04997 <span class="keyword">@synthesize</span> didReceiveResponseHeadersSelector;
<a name="l04998"></a>04998 <span class="keyword">@synthesize</span> willRedirectSelector;
<a name="l04999"></a>04999 <span class="keyword">@synthesize</span> didFinishSelector;
<a name="l05000"></a>05000 <span class="keyword">@synthesize</span> didFailSelector;
<a name="l05001"></a>05001 <span class="keyword">@synthesize</span> didReceiveDataSelector;
<a name="l05002"></a>05002 <span class="keyword">@synthesize</span> authenticationRealm;
<a name="l05003"></a>05003 <span class="keyword">@synthesize</span> proxyAuthenticationRealm;
<a name="l05004"></a>05004 <span class="keyword">@synthesize</span> error;
<a name="l05005"></a>05005 <span class="keyword">@synthesize</span> complete;
<a name="l05006"></a>05006 <span class="keyword">@synthesize</span> requestHeaders;
<a name="l05007"></a>05007 <span class="keyword">@synthesize</span> responseHeaders;
<a name="l05008"></a>05008 <span class="keyword">@synthesize</span> responseCookies;
<a name="l05009"></a>05009 <span class="keyword">@synthesize</span> requestCookies;
<a name="l05010"></a>05010 <span class="keyword">@synthesize</span> requestCredentials;
<a name="l05011"></a>05011 <span class="keyword">@synthesize</span> responseStatusCode;
<a name="l05012"></a>05012 <span class="keyword">@synthesize</span> rawResponseData;
<a name="l05013"></a>05013 <span class="keyword">@synthesize</span> lastActivityTime;
<a name="l05014"></a>05014 <span class="keyword">@synthesize</span> timeOutSeconds;
<a name="l05015"></a>05015 <span class="keyword">@synthesize</span> requestMethod;
<a name="l05016"></a>05016 <span class="keyword">@synthesize</span> postBody;
<a name="l05017"></a>05017 <span class="keyword">@synthesize</span> compressedPostBody;
<a name="l05018"></a>05018 <span class="keyword">@synthesize</span> contentLength;
<a name="l05019"></a>05019 <span class="keyword">@synthesize</span> partialDownloadSize;
<a name="l05020"></a>05020 <span class="keyword">@synthesize</span> postLength;
<a name="l05021"></a>05021 <span class="keyword">@synthesize</span> shouldResetDownloadProgress;
<a name="l05022"></a>05022 <span class="keyword">@synthesize</span> shouldResetUploadProgress;
<a name="l05023"></a>05023 <span class="keyword">@synthesize</span> mainRequest;
<a name="l05024"></a>05024 <span class="keyword">@synthesize</span> totalBytesRead;
<a name="l05025"></a>05025 <span class="keyword">@synthesize</span> totalBytesSent;
<a name="l05026"></a>05026 <span class="keyword">@synthesize</span> showAccurateProgress;
<a name="l05027"></a>05027 <span class="keyword">@synthesize</span> uploadBufferSize;
<a name="l05028"></a>05028 <span class="keyword">@synthesize</span> defaultResponseEncoding;
<a name="l05029"></a>05029 <span class="keyword">@synthesize</span> responseEncoding;
<a name="l05030"></a>05030 <span class="keyword">@synthesize</span> allowCompressedResponse;
<a name="l05031"></a>05031 <span class="keyword">@synthesize</span> allowResumeForFileDownloads;
<a name="l05032"></a>05032 <span class="keyword">@synthesize</span> userInfo;
<a name="l05033"></a>05033 <span class="keyword">@synthesize</span> tag;
<a name="l05034"></a>05034 <span class="keyword">@synthesize</span> postBodyFilePath;
<a name="l05035"></a>05035 <span class="keyword">@synthesize</span> compressedPostBodyFilePath;
<a name="l05036"></a>05036 <span class="keyword">@synthesize</span> postBodyWriteStream;
<a name="l05037"></a>05037 <span class="keyword">@synthesize</span> postBodyReadStream;
<a name="l05038"></a>05038 <span class="keyword">@synthesize</span> shouldStreamPostDataFromDisk;
<a name="l05039"></a>05039 <span class="keyword">@synthesize</span> didCreateTemporaryPostDataFile;
<a name="l05040"></a>05040 <span class="keyword">@synthesize</span> useHTTPVersionOne;
<a name="l05041"></a>05041 <span class="keyword">@synthesize</span> lastBytesRead;
<a name="l05042"></a>05042 <span class="keyword">@synthesize</span> lastBytesSent;
<a name="l05043"></a>05043 <span class="keyword">@synthesize</span> cancelledLock;
<a name="l05044"></a>05044 <span class="keyword">@synthesize</span> haveBuiltPostBody;
<a name="l05045"></a>05045 <span class="keyword">@synthesize</span> fileDownloadOutputStream;
<a name="l05046"></a>05046 <span class="keyword">@synthesize</span> inflatedFileDownloadOutputStream;
<a name="l05047"></a>05047 <span class="keyword">@synthesize</span> authenticationRetryCount;
<a name="l05048"></a>05048 <span class="keyword">@synthesize</span> proxyAuthenticationRetryCount;
<a name="l05049"></a>05049 <span class="keyword">@synthesize</span> updatedProgress;
<a name="l05050"></a>05050 <span class="keyword">@synthesize</span> shouldRedirect;
<a name="l05051"></a>05051 <span class="keyword">@synthesize</span> validatesSecureCertificate;
<a name="l05052"></a>05052 <span class="keyword">@synthesize</span> needsRedirect;
<a name="l05053"></a>05053 <span class="keyword">@synthesize</span> redirectCount;
<a name="l05054"></a>05054 <span class="keyword">@synthesize</span> shouldCompressRequestBody;
<a name="l05055"></a>05055 <span class="keyword">@synthesize</span> proxyCredentials;
<a name="l05056"></a>05056 <span class="keyword">@synthesize</span> proxyHost;
<a name="l05057"></a>05057 <span class="keyword">@synthesize</span> proxyPort;
<a name="l05058"></a>05058 <span class="keyword">@synthesize</span> proxyType;
<a name="l05059"></a>05059 <span class="keyword">@synthesize</span> PACurl;
<a name="l05060"></a>05060 <span class="keyword">@synthesize</span> authenticationScheme;
<a name="l05061"></a>05061 <span class="keyword">@synthesize</span> proxyAuthenticationScheme;
<a name="l05062"></a>05062 <span class="keyword">@synthesize</span> shouldPresentAuthenticationDialog;
<a name="l05063"></a>05063 <span class="keyword">@synthesize</span> shouldPresentProxyAuthenticationDialog;
<a name="l05064"></a>05064 <span class="keyword">@synthesize</span> authenticationNeeded;
<a name="l05065"></a>05065 <span class="keyword">@synthesize</span> responseStatusMessage;
<a name="l05066"></a>05066 <span class="keyword">@synthesize</span> shouldPresentCredentialsBeforeChallenge;
<a name="l05067"></a>05067 <span class="keyword">@synthesize</span> haveBuiltRequestHeaders;
<a name="l05068"></a>05068 <span class="keyword">@synthesize</span> inProgress;
<a name="l05069"></a>05069 <span class="keyword">@synthesize</span> numberOfTimesToRetryOnTimeout;
<a name="l05070"></a>05070 <span class="keyword">@synthesize</span> retryCount;
<a name="l05071"></a>05071 <span class="keyword">@synthesize</span> willRetryRequest;
<a name="l05072"></a>05072 <span class="keyword">@synthesize</span> shouldAttemptPersistentConnection;
<a name="l05073"></a>05073 <span class="keyword">@synthesize</span> persistentConnectionTimeoutSeconds;
<a name="l05074"></a>05074 <span class="keyword">@synthesize</span> connectionCanBeReused;
<a name="l05075"></a>05075 <span class="keyword">@synthesize</span> connectionInfo;
<a name="l05076"></a>05076 <span class="keyword">@synthesize</span> readStream;
<a name="l05077"></a>05077 <span class="keyword">@synthesize</span> readStreamIsScheduled;
<a name="l05078"></a>05078 <span class="keyword">@synthesize</span> shouldUseRFC2616RedirectBehaviour;
<a name="l05079"></a>05079 <span class="keyword">@synthesize</span> downloadComplete;
<a name="l05080"></a>05080 <span class="keyword">@synthesize</span> requestID;
<a name="l05081"></a>05081 <span class="keyword">@synthesize</span> runLoopMode;
<a name="l05082"></a>05082 <span class="keyword">@synthesize</span> statusTimer;
<a name="l05083"></a>05083 <span class="keyword">@synthesize</span> downloadCache;
<a name="l05084"></a>05084 <span class="keyword">@synthesize</span> cachePolicy;
<a name="l05085"></a>05085 <span class="keyword">@synthesize</span> cacheStoragePolicy;
<a name="l05086"></a>05086 <span class="keyword">@synthesize</span> didUseCachedResponse;
<a name="l05087"></a>05087 <span class="keyword">@synthesize</span> secondsToCache;
<a name="l05088"></a>05088 <span class="keyword">@synthesize</span> clientCertificates;
<a name="l05089"></a>05089 <span class="keyword">@synthesize</span> redirectURL;
<a name="l05090"></a>05090 <span class="preprocessor">#if TARGET_OS_IPHONE &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_4_0</span>
<a name="l05091"></a>05091 <span class="preprocessor"></span><span class="keyword">@synthesize</span> shouldContinueWhenAppEntersBackground;
<a name="l05092"></a>05092 <span class="preprocessor">#endif</span>
<a name="l05093"></a>05093 <span class="preprocessor"></span><span class="keyword">@synthesize</span> dataDecompressor;
<a name="l05094"></a>05094 <span class="keyword">@synthesize</span> shouldWaitToInflateCompressedResponses;
<a name="l05095"></a>05095 
<a name="l05096"></a>05096 <span class="keyword">@synthesize</span> isPACFileRequest;
<a name="l05097"></a>05097 <span class="keyword">@synthesize</span> PACFileRequest;
<a name="l05098"></a>05098 <span class="keyword">@synthesize</span> PACFileReadStream;
<a name="l05099"></a>05099 <span class="keyword">@synthesize</span> PACFileData;
<a name="l05100"></a>05100 
<a name="l05101"></a>05101 <span class="keyword">@synthesize</span> isSynchronous;
<a name="l05102"></a>05102 <span class="keyword">@end</span>
</pre></div></div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><b>ASIHTTPRequest.m</b>      </li>
</div><!-- .fixedwidth -->


    <span class="footer">Generated for Nimbus by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4-20110629 </span>
   </ul>
 </div>


</div> <!-- page -->
</body>
</html>
