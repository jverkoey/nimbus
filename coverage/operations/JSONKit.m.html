<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Strict//EN'
   'http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd'>
  <html xmlns='http://www.w3.org/1999/xhtml'>
    <head>
      <meta http-equiv='content-type' content='text/html; charset=utf-8' />
      <meta name='generator' content='CoverStory' />
      <link rel=StyleSheet href='coverstory.css' type='text/css'>
      <script src='coverstory.js' language='javascript' type='text/javascript'></script>
      <title>JSONKit.m</title>
    </head>
    <body id='coverstory' onload='coverstory_load()' onunload='coverstory_unload()'>
      <div id='maincontainer'>
        <h1 id='sourcename'>JSONKit.m</h1>
        <h2 id='sourcepath'>/Users/featherless/workbench/ios/nimbus/thirdparty/JSONKit/JSONKit.m</h2>
        <div id='filelistcontainer'>
          <div id='filesummary'>1.0% of 1437 lines</div>
          <table id='filetable'>
            <tr id='filelistheader'>
              <th id='filelistheadersource'>Source</th>
              <th id='filelistheaderpercent'>%</th>
            </tr>
            <tr class='fileline'>
<td class='filename'><a href='NINetworkJSONRequest.m.html'>NINetworkJSONRequest.m</a></td>
<td class='filepercent'><span class='filelessthan25percent'>0.00</span></td>
</tr>
<tr class='fileline'>
<td class='filename'><a href='JSONKit.m.html'>JSONKit.m</a></td>
<td class='filepercent'><span class='filelessthan25percent'>0.98</span></td>
</tr>

          </table>
        </div>
        <div id='sourcecontainer'>
          <div id='sourcesummary'>Executed 1.0% of 1431 lines (14 executed, 1431 executable, 3059 total lines)</div>
          <table id='sourcetable'>
          <tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>//</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>//  JSONKit.m</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>//  http://github.com/johnezang/JSONKit</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>//  Dual licensed under either the terms of the BSD License, or alternatively</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>//  under the terms of the Apache License, Version 2.0, as specified below.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>//</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>/*</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> Copyright (c) 2011, John Engelhart</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> All rights reserved.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> Redistribution and use in source and binary forms, with or without</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> modification, are permitted provided that the following conditions are met:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> * Redistributions of source code must retain the above copyright</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> notice, this list of conditions and the following disclaimer.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> * Redistributions in binary form must reproduce the above copyright</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> notice, this list of conditions and the following disclaimer in the</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> documentation and/or other materials provided with the distribution.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> * Neither the name of the Zang Industries nor the names of its</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> contributors may be used to endorse or promote products derived from</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> this software without specific prior written permission.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>*/</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>/*</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> Copyright 2011 John Engelhart</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> you may not use this file except in compliance with the License.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> You may obtain a copy of the License at</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> http://www.apache.org/licenses/LICENSE-2.0</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> Unless required by applicable law or agreed to in writing, software</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> See the License for the specific language governing permissions and</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> limitations under the License.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>*/</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>/*</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  Acknowledgments:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  The bulk of the UTF8 / UTF32 conversion and verification comes</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  from ConvertUTF.[hc].  It has been modified from the original sources.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  The original sources were obtained from http://www.unicode.org/.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  However, the web site no longer seems to host the files.  Instead,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  the Unicode FAQ http://www.unicode.org/faq//utf_bom.html#gen4</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  points to International Components for Unicode (ICU)</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  http://site.icu-project.org/ as an example of how to write a UTF</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  converter.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  The decision to use the ConvertUTF.[ch] code was made to leverage</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  &quot;proven&quot; code.  Hopefully the local modifications are bug free.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  The code in isValidCodePoint() is derived from the ICU code in</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  utf.h for the macros U_IS_UNICODE_NONCHAR and U_IS_UNICODE_CHAR.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  From the original ConvertUTF.[ch]:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> * Copyright 2001-2004 Unicode, Inc.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> * </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> * Disclaimer</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> * </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> * This source code is provided as is by Unicode, Inc. No claims are</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> * made as to fitness for any particular purpose. No warranties of any</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> * kind are expressed or implied. The recipient agrees to determine</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> * applicability of information provided. If this file has been</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> * purchased on magnetic or optical media from Unicode, Inc., the</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> * sole remedy for any claim will be exchange of defective media</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> * within 90 days of receipt.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> * </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> * Limitations on Rights to Redistribute This Code</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> * </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> * Unicode, Inc. hereby grants the right to freely use the information</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> * supplied in this file in the creation of products supporting the</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> * Unicode Standard, and to make copies of this file in any form</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> * for internal or external distribution as long as this notice</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> * remains attached.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>*/</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#include &lt;stdio.h&gt;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#include &lt;stdlib.h&gt;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#include &lt;stdint.h&gt;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#include &lt;string.h&gt;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#include &lt;assert.h&gt;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#include &lt;sys/errno.h&gt;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#include &lt;math.h&gt;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#include &lt;limits.h&gt;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#include &lt;objc/runtime.h&gt;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#import &quot;JSONKit.h&quot;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>//#include &lt;CoreFoundation/CoreFoundation.h&gt;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#include &lt;CoreFoundation/CFString.h&gt;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#include &lt;CoreFoundation/CFArray.h&gt;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#include &lt;CoreFoundation/CFDictionary.h&gt;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#include &lt;CoreFoundation/CFNumber.h&gt;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>//#import &lt;Foundation/Foundation.h&gt;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#import &lt;Foundation/NSArray.h&gt;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#import &lt;Foundation/NSAutoreleasePool.h&gt;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#import &lt;Foundation/NSData.h&gt;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#import &lt;Foundation/NSDictionary.h&gt;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#import &lt;Foundation/NSException.h&gt;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#import &lt;Foundation/NSNull.h&gt;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#import &lt;Foundation/NSObjCRuntime.h&gt;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#ifndef __has_feature</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#define __has_feature(x) 0</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#endif</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#ifdef JK_ENABLE_CF_TRANSFER_OWNERSHIP_CALLBACKS</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#warning As of JSONKit v1.4, JK_ENABLE_CF_TRANSFER_OWNERSHIP_CALLBACKS is no longer required.  It is no longer a valid option.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#endif</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#ifdef __OBJC_GC__</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#error JSONKit does not support Objective-C Garbage Collection</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#endif</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#if __has_feature(objc_arc)</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#error JSONKit does not support Objective-C Automatic Reference Counting (ARC)</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#endif</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>// The following checks are really nothing more than sanity checks.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>// JSONKit technically has a few problems from a &quot;strictly C99 conforming&quot; standpoint, though they are of the pedantic nitpicking variety.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>// In practice, though, for the compilers and architectures we can reasonably expect this code to be compiled for, these pedantic nitpicks aren&apos;t really a problem.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>// Since we&apos;re limited as to what we can do with pre-processor #if checks, these checks are not nearly as through as they should be.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#if (UINT_MAX != 0xffffffffU) || (INT_MIN != (-0x7fffffff-1)) || (ULLONG_MAX != 0xffffffffffffffffULL) || (LLONG_MIN != (-0x7fffffffffffffffLL-1LL))</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#error JSONKit requires the C &apos;int&apos; and &apos;long long&apos; types to be 32 and 64 bits respectively.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#endif</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#if !defined(__LP64__) &amp;&amp; ((UINT_MAX != ULONG_MAX) || (INT_MAX != LONG_MAX) || (INT_MIN != LONG_MIN) || (WORD_BIT != LONG_BIT))</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#error JSONKit requires the C &apos;int&apos; and &apos;long&apos; types to be the same on 32-bit architectures.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#endif</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>// Cocoa / Foundation uses NS*Integer as the type for a lot of arguments.  We make sure that NS*Integer is something we are expecting and is reasonably compatible with size_t / ssize_t</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#if (NSUIntegerMax != ULONG_MAX) || (NSIntegerMax != LONG_MAX) || (NSIntegerMin != LONG_MIN)</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#error JSONKit requires NSInteger and NSUInteger to be the same size as the C &apos;long&apos; type.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#endif</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#if (NSUIntegerMax != SIZE_MAX) || (NSIntegerMax != SSIZE_MAX)</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#error JSONKit requires NSInteger and NSUInteger to be the same size as the C &apos;size_t&apos; type.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#endif</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>// For DJB hash.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#define JK_HASH_INIT           (1402737925UL)</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>// Use __builtin_clz() instead of trailingBytesForUTF8[] table lookup.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#define JK_FAST_TRAILING_BYTES</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>// JK_CACHE_SLOTS must be a power of 2.  Default size is 1024 slots.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#define JK_CACHE_SLOTS_BITS    (10)</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#define JK_CACHE_SLOTS         (1UL &lt;&lt; JK_CACHE_SLOTS_BITS)</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>// JK_CACHE_PROBES is the number of probe attempts.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#define JK_CACHE_PROBES        (4UL)</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>// JK_INIT_CACHE_AGE must be (1 &lt;&lt; AGE) - 1</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#define JK_INIT_CACHE_AGE      (0)</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>// JK_TOKENBUFFER_SIZE is the default stack size for the temporary buffer used to hold &quot;non-simple&quot; strings (i.e., contains \ escapes)</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#define JK_TOKENBUFFER_SIZE    (1024UL * 2UL)</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>// JK_STACK_OBJS is the default number of spaces reserved on the stack for temporarily storing pointers to Obj-C objects before they can be transferred to a NSArray / NSDictionary.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#define JK_STACK_OBJS          (1024UL * 1UL)</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#define JK_JSONBUFFER_SIZE     (1024UL * 4UL)</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#define JK_UTF8BUFFER_SIZE     (1024UL * 16UL)</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#define JK_ENCODE_CACHE_SLOTS  (1024UL)</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#if       defined (__GNUC__) &amp;&amp; (__GNUC__ &gt;= 4)</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#define JK_ATTRIBUTES(attr, ...)        __attribute__((attr, ##__VA_ARGS__))</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#define JK_EXPECTED(cond, expect)       __builtin_expect((long)(cond), (expect))</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#define JK_EXPECT_T(cond)               JK_EXPECTED(cond, 1U)</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#define JK_EXPECT_F(cond)               JK_EXPECTED(cond, 0U)</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#define JK_PREFETCH(ptr)                __builtin_prefetch(ptr)</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#else  // defined (__GNUC__) &amp;&amp; (__GNUC__ &gt;= 4) </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#define JK_ATTRIBUTES(attr, ...)</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#define JK_EXPECTED(cond, expect)       (cond)</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#define JK_EXPECT_T(cond)               (cond)</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#define JK_EXPECT_F(cond)               (cond)</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#define JK_PREFETCH(ptr)</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#endif // defined (__GNUC__) &amp;&amp; (__GNUC__ &gt;= 4) </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#define JK_STATIC_INLINE                         static __inline__ JK_ATTRIBUTES(always_inline)</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#define JK_ALIGNED(arg)                                            JK_ATTRIBUTES(aligned(arg))</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#define JK_UNUSED_ARG                                              JK_ATTRIBUTES(unused)</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#define JK_WARN_UNUSED                                             JK_ATTRIBUTES(warn_unused_result)</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#define JK_WARN_UNUSED_CONST                                       JK_ATTRIBUTES(warn_unused_result, const)</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#define JK_WARN_UNUSED_PURE                                        JK_ATTRIBUTES(warn_unused_result, pure)</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#define JK_WARN_UNUSED_SENTINEL                                    JK_ATTRIBUTES(warn_unused_result, sentinel)</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#define JK_NONNULL_ARGS(arg, ...)                                  JK_ATTRIBUTES(nonnull(arg, ##__VA_ARGS__))</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#define JK_WARN_UNUSED_NONNULL_ARGS(arg, ...)                      JK_ATTRIBUTES(warn_unused_result, nonnull(arg, ##__VA_ARGS__))</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#define JK_WARN_UNUSED_CONST_NONNULL_ARGS(arg, ...)                JK_ATTRIBUTES(warn_unused_result, const, nonnull(arg, ##__VA_ARGS__))</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#define JK_WARN_UNUSED_PURE_NONNULL_ARGS(arg, ...)                 JK_ATTRIBUTES(warn_unused_result, pure, nonnull(arg, ##__VA_ARGS__))</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#if       defined (__GNUC__) &amp;&amp; (__GNUC__ &gt;= 4) &amp;&amp; (__GNUC_MINOR__ &gt;= 3)</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#define JK_ALLOC_SIZE_NON_NULL_ARGS_WARN_UNUSED(as, nn, ...) JK_ATTRIBUTES(warn_unused_result, nonnull(nn, ##__VA_ARGS__), alloc_size(as))</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#else  // defined (__GNUC__) &amp;&amp; (__GNUC__ &gt;= 4) &amp;&amp; (__GNUC_MINOR__ &gt;= 3)</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#define JK_ALLOC_SIZE_NON_NULL_ARGS_WARN_UNUSED(as, nn, ...) JK_ATTRIBUTES(warn_unused_result, nonnull(nn, ##__VA_ARGS__))</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#endif // defined (__GNUC__) &amp;&amp; (__GNUC__ &gt;= 4) &amp;&amp; (__GNUC_MINOR__ &gt;= 3)</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>@class JKArray, JKDictionaryEnumerator, JKDictionary;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>enum {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JSONNumberStateStart                 = 0,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JSONNumberStateFinished              = 1,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JSONNumberStateError                 = 2,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JSONNumberStateWholeNumberStart      = 3,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JSONNumberStateWholeNumberMinus      = 4,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JSONNumberStateWholeNumberZero       = 5,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JSONNumberStateWholeNumber           = 6,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JSONNumberStatePeriod                = 7,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JSONNumberStateFractionalNumberStart = 8,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JSONNumberStateFractionalNumber      = 9,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JSONNumberStateExponentStart         = 10,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JSONNumberStateExponentPlusMinus     = 11,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JSONNumberStateExponent              = 12,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>};</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>enum {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JSONStringStateStart                           = 0,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JSONStringStateParsing                         = 1,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JSONStringStateFinished                        = 2,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JSONStringStateError                           = 3,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JSONStringStateEscape                          = 4,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JSONStringStateEscapedUnicode1                 = 5,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JSONStringStateEscapedUnicode2                 = 6,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JSONStringStateEscapedUnicode3                 = 7,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JSONStringStateEscapedUnicode4                 = 8,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JSONStringStateEscapedUnicodeSurrogate1        = 9,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JSONStringStateEscapedUnicodeSurrogate2        = 10,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JSONStringStateEscapedUnicodeSurrogate3        = 11,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JSONStringStateEscapedUnicodeSurrogate4        = 12,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JSONStringStateEscapedNeedEscapeForSurrogate   = 13,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JSONStringStateEscapedNeedEscapedUForSurrogate = 14,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>};</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>enum {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKParseAcceptValue      = (1 &lt;&lt; 0),</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKParseAcceptComma      = (1 &lt;&lt; 1),</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKParseAcceptEnd        = (1 &lt;&lt; 2),</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKParseAcceptValueOrEnd = (JKParseAcceptValue | JKParseAcceptEnd),</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKParseAcceptCommaOrEnd = (JKParseAcceptComma | JKParseAcceptEnd),</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>};</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>enum {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKClassUnknown    = 0,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKClassString     = 1,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKClassNumber     = 2,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKClassArray      = 3,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKClassDictionary = 4,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKClassNull       = 5,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>};</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>enum {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKManagedBufferOnStack        = 1,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKManagedBufferOnHeap         = 2,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKManagedBufferLocationMask   = (0x3),</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKManagedBufferLocationShift  = (0),</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKManagedBufferMustFree       = (1 &lt;&lt; 2),</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>};</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>typedef JKFlags JKManagedBufferFlags;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>enum {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKObjectStackOnStack        = 1,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKObjectStackOnHeap         = 2,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKObjectStackLocationMask   = (0x3),</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKObjectStackLocationShift  = (0),</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKObjectStackMustFree       = (1 &lt;&lt; 2),</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>};</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>typedef JKFlags JKObjectStackFlags;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>enum {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKTokenTypeInvalid     = 0,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKTokenTypeNumber      = 1,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKTokenTypeString      = 2,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKTokenTypeObjectBegin = 3,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKTokenTypeObjectEnd   = 4,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKTokenTypeArrayBegin  = 5,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKTokenTypeArrayEnd    = 6,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKTokenTypeSeparator   = 7,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKTokenTypeComma       = 8,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKTokenTypeTrue        = 9,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKTokenTypeFalse       = 10,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKTokenTypeNull        = 11,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKTokenTypeWhiteSpace  = 12,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>};</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>typedef NSUInteger JKTokenType;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>// These are prime numbers to assist with hash slot probing.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>enum {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKValueTypeNone             = 0,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKValueTypeString           = 5,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKValueTypeLongLong         = 7,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKValueTypeUnsignedLongLong = 11,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKValueTypeDouble           = 13,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>};</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>typedef NSUInteger JKValueType;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>enum {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKEncodeOptionAsData              = 1,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKEncodeOptionAsString            = 2,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKEncodeOptionAsTypeMask          = 0x7,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKEncodeOptionCollectionObj       = (1 &lt;&lt; 3),</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKEncodeOptionStringObj           = (1 &lt;&lt; 4),</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKEncodeOptionStringObjTrimQuotes = (1 &lt;&lt; 5),</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>};</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>typedef NSUInteger JKEncodeOptionType;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>typedef NSUInteger JKHash;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>typedef struct JKTokenCacheItem  JKTokenCacheItem;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>typedef struct JKTokenCache      JKTokenCache;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>typedef struct JKTokenValue      JKTokenValue;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>typedef struct JKParseToken      JKParseToken;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>typedef struct JKPtrRange        JKPtrRange;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>typedef struct JKObjectStack     JKObjectStack;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>typedef struct JKBuffer          JKBuffer;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>typedef struct JKConstBuffer     JKConstBuffer;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>typedef struct JKConstPtrRange   JKConstPtrRange;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>typedef struct JKRange           JKRange;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>typedef struct JKManagedBuffer   JKManagedBuffer;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>typedef struct JKFastClassLookup JKFastClassLookup;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>typedef struct JKEncodeCache     JKEncodeCache;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>typedef struct JKEncodeState     JKEncodeState;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>typedef struct JKObjCImpCache    JKObjCImpCache;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>typedef struct JKHashTableEntry  JKHashTableEntry;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>typedef id (*NSNumberAllocImp)(id receiver, SEL selector);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>typedef id (*NSNumberInitWithUnsignedLongLongImp)(id receiver, SEL selector, unsigned long long value);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>typedef id (*JKClassFormatterIMP)(id receiver, SEL selector, id object);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#ifdef __BLOCKS__</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>typedef id (^JKClassFormatterBlock)(id formatObject);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#endif</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>struct JKPtrRange {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  unsigned char *ptr;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  size_t         length;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>};</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>struct JKConstPtrRange {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  const unsigned char *ptr;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  size_t               length;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>};</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>struct JKRange {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  size_t location, length;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>};</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>struct JKManagedBuffer {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKPtrRange           bytes;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKManagedBufferFlags flags;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  size_t               roundSizeUpToMultipleOf;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>};</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>struct JKObjectStack {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  void               **objects, **keys;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  CFHashCode          *cfHashes;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  size_t               count, index, roundSizeUpToMultipleOf;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKObjectStackFlags   flags;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>};</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>struct JKBuffer {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKPtrRange bytes;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>};</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>struct JKConstBuffer {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKConstPtrRange bytes;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>};</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>struct JKTokenValue {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKConstPtrRange   ptrRange;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKValueType       type;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKHash            hash;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  union {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>    long long          longLongValue;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>    unsigned long long unsignedLongLongValue;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>    double             doubleValue;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  } number;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKTokenCacheItem *cacheItem;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>};</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>struct JKParseToken {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKConstPtrRange tokenPtrRange;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKTokenType     type;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKTokenValue    value;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKManagedBuffer tokenBuffer;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>};</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>struct JKTokenCacheItem {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  void          *object;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKHash         hash;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  CFHashCode     cfHash;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  size_t         size;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  unsigned char *bytes;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKValueType    type;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>};</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>struct JKTokenCache {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKTokenCacheItem *items;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  size_t            count;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  unsigned int      prng_lfsr;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  unsigned char     age[JK_CACHE_SLOTS];</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>};</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>struct JKObjCImpCache {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  Class                               NSNumberClass;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  NSNumberAllocImp                    NSNumberAlloc;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  NSNumberInitWithUnsignedLongLongImp NSNumberInitWithUnsignedLongLong;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>};</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>struct JKParseState {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKParseOptionFlags  parseOptionFlags;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKConstBuffer       stringBuffer;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  size_t              atIndex, lineNumber, lineStartIndex;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  size_t              prev_atIndex, prev_lineNumber, prev_lineStartIndex;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKParseToken        token;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKObjectStack       objectStack;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKTokenCache        cache;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKObjCImpCache      objCImpCache;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  NSError            *error;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  int                 errorIsPrev;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  BOOL                mutableCollections;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>};</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>struct JKFastClassLookup {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  void *stringClass;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  void *numberClass;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  void *arrayClass;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  void *dictionaryClass;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  void *nullClass;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>};</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>struct JKEncodeCache {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  id object;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  size_t offset;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  size_t length;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>};</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>struct JKEncodeState {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKManagedBuffer         utf8ConversionBuffer;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKManagedBuffer         stringBuffer;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  size_t                  atIndex;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKFastClassLookup       fastClassLookup;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKEncodeCache           cache[JK_ENCODE_CACHE_SLOTS];</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKSerializeOptionFlags  serializeOptionFlags;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKEncodeOptionType      encodeOption;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  size_t                  depth;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  NSError                *error;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  id                      classFormatterDelegate;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  SEL                     classFormatterSelector;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKClassFormatterIMP     classFormatterIMP;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#ifdef __BLOCKS__</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKClassFormatterBlock   classFormatterBlock;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#endif</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>};</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>// This is a JSONKit private class.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>@interface JKSerializer : NSObject {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKEncodeState *encodeState;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#ifdef __BLOCKS__</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#define JKSERIALIZER_BLOCKS_PROTO id(^)(id object)</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#else</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#define JKSERIALIZER_BLOCKS_PROTO id</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#endif</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>+ (id)serializeObject:(id)object options:(JKSerializeOptionFlags)optionFlags encodeOption:(JKEncodeOptionType)encodeOption block:(JKSERIALIZER_BLOCKS_PROTO)block delegate:(id)delegate selector:(SEL)selector error:(NSError **)error;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>- (id)serializeObject:(id)object options:(JKSerializeOptionFlags)optionFlags encodeOption:(JKEncodeOptionType)encodeOption block:(JKSERIALIZER_BLOCKS_PROTO)block delegate:(id)delegate selector:(SEL)selector error:(NSError **)error;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>- (void)releaseState;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>@end</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>struct JKHashTableEntry {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  NSUInteger keyHash;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  id key, object;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>};</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>typedef uint32_t UTF32; /* at least 32 bits */</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>typedef uint16_t UTF16; /* at least 16 bits */</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>typedef uint8_t  UTF8;  /* typically 8 bits */</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>typedef enum {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  conversionOK,           /* conversion successful */</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  sourceExhausted,        /* partial character in source, but hit end */</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  targetExhausted,        /* insuff. room in target for conversion */</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  sourceIllegal           /* source sequence is illegal/malformed */</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>} ConversionResult;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#define UNI_REPLACEMENT_CHAR (UTF32)0x0000FFFD</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#define UNI_MAX_BMP          (UTF32)0x0000FFFF</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#define UNI_MAX_UTF16        (UTF32)0x0010FFFF</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#define UNI_MAX_UTF32        (UTF32)0x7FFFFFFF</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#define UNI_MAX_LEGAL_UTF32  (UTF32)0x0010FFFF</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#define UNI_SUR_HIGH_START   (UTF32)0xD800</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#define UNI_SUR_HIGH_END     (UTF32)0xDBFF</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#define UNI_SUR_LOW_START    (UTF32)0xDC00</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#define UNI_SUR_LOW_END      (UTF32)0xDFFF</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#if !defined(JK_FAST_TRAILING_BYTES)</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>static const char trailingBytesForUTF8[256] = {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>    2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, 3,3,3,3,3,3,3,3,4,4,4,4,5,5,5,5</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>};</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#endif</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>static const UTF32 offsetsFromUTF8[6] = { 0x00000000UL, 0x00003080UL, 0x000E2080UL, 0x03C82080UL, 0xFA082080UL, 0x82082080UL };</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>static const UTF8  firstByteMark[7]   = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#define JK_AT_STRING_PTR(x)  (&amp;((x)-&gt;stringBuffer.bytes.ptr[(x)-&gt;atIndex]))</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#define JK_END_STRING_PTR(x) (&amp;((x)-&gt;stringBuffer.bytes.ptr[(x)-&gt;stringBuffer.bytes.length]))</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>static JKArray          *_JKArrayCreate(id *objects, NSUInteger count, BOOL mutableCollection);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>static void              _JKArrayInsertObjectAtIndex(JKArray *array, id newObject, NSUInteger objectIndex);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>static void              _JKArrayReplaceObjectAtIndexWithObject(JKArray *array, NSUInteger objectIndex, id newObject);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>static void              _JKArrayRemoveObjectAtIndex(JKArray *array, NSUInteger objectIndex);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>static NSUInteger        _JKDictionaryCapacityForCount(NSUInteger count);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>static JKDictionary     *_JKDictionaryCreate(id *keys, NSUInteger *keyHashes, id *objects, NSUInteger count, BOOL mutableCollection);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>static JKHashTableEntry *_JKDictionaryHashEntry(JKDictionary *dictionary);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>static NSUInteger        _JKDictionaryCapacity(JKDictionary *dictionary);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>static void              _JKDictionaryResizeIfNeccessary(JKDictionary *dictionary);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>static void              _JKDictionaryRemoveObjectWithEntry(JKDictionary *dictionary, JKHashTableEntry *entry);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>static void              _JKDictionaryAddObject(JKDictionary *dictionary, NSUInteger keyHash, id key, id object);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>static JKHashTableEntry *_JKDictionaryHashTableEntryForKey(JKDictionary *dictionary, id aKey);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>static void _JSONDecoderCleanup(JSONDecoder *decoder);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>static id _NSStringObjectFromJSONString(NSString *jsonString, JKParseOptionFlags parseOptionFlags, NSError **error, BOOL mutableCollection);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>static void jk_managedBuffer_release(JKManagedBuffer *managedBuffer);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>static void jk_managedBuffer_setToStackBuffer(JKManagedBuffer *managedBuffer, unsigned char *ptr, size_t length);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>static unsigned char *jk_managedBuffer_resize(JKManagedBuffer *managedBuffer, size_t newSize);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>static void jk_objectStack_release(JKObjectStack *objectStack);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>static void jk_objectStack_setToStackBuffer(JKObjectStack *objectStack, void **objects, void **keys, CFHashCode *cfHashes, size_t count);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>static int  jk_objectStack_resize(JKObjectStack *objectStack, size_t newCount);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>static void   jk_error(JKParseState *parseState, NSString *format, ...);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>static int    jk_parse_string(JKParseState *parseState);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>static int    jk_parse_number(JKParseState *parseState);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>static size_t jk_parse_is_newline(JKParseState *parseState, const unsigned char *atCharacterPtr);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>JK_STATIC_INLINE int jk_parse_skip_newline(JKParseState *parseState);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>JK_STATIC_INLINE void jk_parse_skip_whitespace(JKParseState *parseState);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>static int    jk_parse_next_token(JKParseState *parseState);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>static void   jk_error_parse_accept_or3(JKParseState *parseState, int state, NSString *or1String, NSString *or2String, NSString *or3String);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>static void  *jk_create_dictionary(JKParseState *parseState, size_t startingObjectIndex);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>static void  *jk_parse_dictionary(JKParseState *parseState);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>static void  *jk_parse_array(JKParseState *parseState);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>static void  *jk_object_for_token(JKParseState *parseState);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>static void  *jk_cachedObjects(JKParseState *parseState);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>JK_STATIC_INLINE void jk_cache_age(JKParseState *parseState);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>JK_STATIC_INLINE void jk_set_parsed_token(JKParseState *parseState, const unsigned char *ptr, size_t length, JKTokenType type, size_t advanceBy);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>static void jk_encode_error(JKEncodeState *encodeState, NSString *format, ...);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>static int jk_encode_printf(JKEncodeState *encodeState, JKEncodeCache *cacheSlot, size_t startingAtIndex, id object, const char *format, ...);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>static int jk_encode_write(JKEncodeState *encodeState, JKEncodeCache *cacheSlot, size_t startingAtIndex, id object, const char *format);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>static int jk_encode_writePrettyPrintWhiteSpace(JKEncodeState *encodeState);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>static int jk_encode_write1slow(JKEncodeState *encodeState, ssize_t depthChange, const char *format);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>static int jk_encode_write1fast(JKEncodeState *encodeState, ssize_t depthChange JK_UNUSED_ARG, const char *format);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>static int jk_encode_writen(JKEncodeState *encodeState, JKEncodeCache *cacheSlot, size_t startingAtIndex, id object, const char *format, size_t length);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>JK_STATIC_INLINE JKHash jk_encode_object_hash(void *objectPtr);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>JK_STATIC_INLINE void jk_encode_updateCache(JKEncodeState *encodeState, JKEncodeCache *cacheSlot, size_t startingAtIndex, id object);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>static int jk_encode_add_atom_to_buffer(JKEncodeState *encodeState, void *objectPtr);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#define jk_encode_write1(es, dc, f)  (JK_EXPECT_F(_jk_encode_prettyPrint) ? jk_encode_write1slow(es, dc, f) : jk_encode_write1fast(es, dc, f))</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>JK_STATIC_INLINE size_t jk_min(size_t a, size_t b);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>JK_STATIC_INLINE size_t jk_max(size_t a, size_t b);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>JK_STATIC_INLINE JKHash calculateHash(JKHash currentHash, unsigned char c);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>// JSONKit v1.4 used both a JKArray : NSArray and JKMutableArray : NSMutableArray, and the same for the dictionary collection type.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>// However, Louis Gerbarg (via cocoa-dev) pointed out that Cocoa / Core Foundation actually implements only a single class that inherits from the </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>// mutable version, and keeps an ivar bit for whether or not that instance is mutable.  This means that the immutable versions of the collection</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>// classes receive the mutating methods, but this is handled by having those methods throw an exception when the ivar bit is set to immutable.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>// We adopt the same strategy here.  It&apos;s both cleaner and gets rid of the method swizzling hackery used in JSONKit v1.4.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>// This is a workaround for issue #23 https://github.com/johnezang/JSONKit/pull/23</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>// Basically, there seem to be a problem with using +load in static libraries on iOS.  However, __attribute__ ((constructor)) does work correctly.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>// Since we do not require anything &quot;special&quot; that +load provides, and we can accomplish the same thing using __attribute__ ((constructor)), the +load logic was moved here.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>static Class                               _JKArrayClass                           = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>static size_t                              _JKArrayInstanceSize                    = 0UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>static Class                               _JKDictionaryClass                      = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>static size_t                              _JKDictionaryInstanceSize               = 0UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>// For JSONDecoder...</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>static Class                               _jk_NSNumberClass                       = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>static NSNumberAllocImp                    _jk_NSNumberAllocImp                    = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>static NSNumberInitWithUnsignedLongLongImp _jk_NSNumberInitWithUnsignedLongLongImp = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>extern void jk_collectionClassLoadTimeInitialization(void) __attribute__ ((constructor));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>void jk_collectionClassLoadTimeInitialization(void) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>1</td>
<td class='sourcelinehit'>  NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init]; // Though technically not required, the run time environment at load time initialization may be less than ideal.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>1</td>
<td class='sourcelinehit'>  _JKArrayClass             = objc_getClass(&quot;JKArray&quot;);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>1</td>
<td class='sourcelinehit'>  _JKArrayInstanceSize      = jk_max(16UL, class_getInstanceSize(_JKArrayClass));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>1</td>
<td class='sourcelinehit'>  _JKDictionaryClass        = objc_getClass(&quot;JKDictionary&quot;);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>1</td>
<td class='sourcelinehit'>  _JKDictionaryInstanceSize = jk_max(16UL, class_getInstanceSize(_JKDictionaryClass));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  // For JSONDecoder...</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>1</td>
<td class='sourcelinehit'>  _jk_NSNumberClass = [NSNumber class];</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>1</td>
<td class='sourcelinehit'>  _jk_NSNumberAllocImp = (NSNumberAllocImp)[NSNumber methodForSelector:@selector(alloc)];</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  // Hacktacular.  Need to do it this way due to the nature of class clusters.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>1</td>
<td class='sourcelinehit'>  id temp_NSNumber = [NSNumber alloc];</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>1</td>
<td class='sourcelinehit'>  _jk_NSNumberInitWithUnsignedLongLongImp = (NSNumberInitWithUnsignedLongLongImp)[temp_NSNumber methodForSelector:@selector(initWithUnsignedLongLong:)];</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>1</td>
<td class='sourcelinehit'>  [[temp_NSNumber init] release];</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>1</td>
<td class='sourcelinehit'>  temp_NSNumber = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>1</td>
<td class='sourcelinehit'>  [pool release]; pool = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>1</td>
<td class='sourcelinehit'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#pragma mark -</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>@interface JKArray : NSMutableArray &lt;NSCopying, NSMutableCopying, NSFastEnumeration&gt; {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  id         *objects;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  NSUInteger  count, capacity, mutations;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>@end</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>@implementation JKArray</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>+ (id)allocWithZone:(NSZone *)zone</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#pragma unused(zone)</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  [NSException raise:NSInvalidArgumentException format:@&quot;*** - [%@ %@]: The %@ class is private to JSONKit and should not be used in this fashion.&quot;, NSStringFromClass([self class]), NSStringFromSelector(_cmd), NSStringFromClass([self class])];</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return(NULL);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>static JKArray *_JKArrayCreate(id *objects, NSUInteger count, BOOL mutableCollection) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSCParameterAssert((objects != NULL) &amp;&amp; (_JKArrayClass != NULL) &amp;&amp; (_JKArrayInstanceSize &gt; 0UL));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  JKArray *array = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(JK_EXPECT_T((array = (JKArray *)calloc(1UL, _JKArrayInstanceSize)) != NULL)) { // Directly allocate the JKArray instance via calloc.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    array-&gt;isa      = _JKArrayClass;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if((array = [array init]) == NULL) { return(NULL); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    array-&gt;capacity = count;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    array-&gt;count    = count;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if(JK_EXPECT_F((array-&gt;objects = (id *)malloc(sizeof(id) * array-&gt;capacity)) == NULL)) { [array autorelease]; return(NULL); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    memcpy(array-&gt;objects, objects, array-&gt;capacity * sizeof(id));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    array-&gt;mutations = (mutableCollection == NO) ? 0UL : 1UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return(array);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>// Note: The caller is responsible for -retaining the object that is to be added.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>static void _JKArrayInsertObjectAtIndex(JKArray *array, id newObject, NSUInteger objectIndex) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSCParameterAssert((array != NULL) &amp;&amp; (array-&gt;objects != NULL) &amp;&amp; (array-&gt;count &lt;= array-&gt;capacity) &amp;&amp; (objectIndex &lt;= array-&gt;count) &amp;&amp; (newObject != NULL));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(!((array != NULL) &amp;&amp; (array-&gt;objects != NULL) &amp;&amp; (objectIndex &lt;= array-&gt;count) &amp;&amp; (newObject != NULL))) { [newObject autorelease]; return; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if((array-&gt;count + 1UL) &gt;= array-&gt;capacity) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    id *newObjects = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if((newObjects = (id *)realloc(array-&gt;objects, sizeof(id) * (array-&gt;capacity + 16UL))) == NULL) { [NSException raise:NSMallocException format:@&quot;Unable to resize objects array.&quot;]; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    array-&gt;objects = newObjects;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    array-&gt;capacity += 16UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    memset(&amp;array-&gt;objects[array-&gt;count], 0, sizeof(id) * (array-&gt;capacity - array-&gt;count));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  array-&gt;count++;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if((objectIndex + 1UL) &lt; array-&gt;count) { memmove(&amp;array-&gt;objects[objectIndex + 1UL], &amp;array-&gt;objects[objectIndex], sizeof(id) * ((array-&gt;count - 1UL) - objectIndex)); array-&gt;objects[objectIndex] = NULL; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  array-&gt;objects[objectIndex] = newObject;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>// Note: The caller is responsible for -retaining the object that is to be added.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>static void _JKArrayReplaceObjectAtIndexWithObject(JKArray *array, NSUInteger objectIndex, id newObject) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSCParameterAssert((array != NULL) &amp;&amp; (array-&gt;objects != NULL) &amp;&amp; (array-&gt;count &lt;= array-&gt;capacity) &amp;&amp; (objectIndex &lt; array-&gt;count) &amp;&amp; (array-&gt;objects[objectIndex] != NULL) &amp;&amp; (newObject != NULL));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(!((array != NULL) &amp;&amp; (array-&gt;objects != NULL) &amp;&amp; (objectIndex &lt; array-&gt;count) &amp;&amp; (array-&gt;objects[objectIndex] != NULL) &amp;&amp; (newObject != NULL))) { [newObject autorelease]; return; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  CFRelease(array-&gt;objects[objectIndex]);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  array-&gt;objects[objectIndex] = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  array-&gt;objects[objectIndex] = newObject;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>static void _JKArrayRemoveObjectAtIndex(JKArray *array, NSUInteger objectIndex) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSCParameterAssert((array != NULL) &amp;&amp; (array-&gt;objects != NULL) &amp;&amp; (array-&gt;count &gt; 0UL) &amp;&amp; (array-&gt;count &lt;= array-&gt;capacity) &amp;&amp; (objectIndex &lt; array-&gt;count) &amp;&amp; (array-&gt;objects[objectIndex] != NULL));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(!((array != NULL) &amp;&amp; (array-&gt;objects != NULL) &amp;&amp; (array-&gt;count &gt; 0UL) &amp;&amp; (array-&gt;count &lt;= array-&gt;capacity) &amp;&amp; (objectIndex &lt; array-&gt;count) &amp;&amp; (array-&gt;objects[objectIndex] != NULL))) { return; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  CFRelease(array-&gt;objects[objectIndex]);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  array-&gt;objects[objectIndex] = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if((objectIndex + 1UL) &lt; array-&gt;count) { memmove(&amp;array-&gt;objects[objectIndex], &amp;array-&gt;objects[objectIndex + 1UL], sizeof(id) * ((array-&gt;count - 1UL) - objectIndex)); array-&gt;objects[array-&gt;count - 1UL] = NULL; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  array-&gt;count--;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (void)dealloc</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(JK_EXPECT_T(objects != NULL)) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    NSUInteger atObject = 0UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    for(atObject = 0UL; atObject &lt; count; atObject++) { if(JK_EXPECT_T(objects[atObject] != NULL)) { CFRelease(objects[atObject]); objects[atObject] = NULL; } }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    free(objects); objects = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  [super dealloc];</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (NSUInteger)count</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSParameterAssert((objects != NULL) &amp;&amp; (count &lt;= capacity));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return(count);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (void)getObjects:(id *)objectsPtr range:(NSRange)range</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSParameterAssert((objects != NULL) &amp;&amp; (count &lt;= capacity));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if((objectsPtr     == NULL)  &amp;&amp; (NSMaxRange(range) &gt; 0UL))   { [NSException raise:NSRangeException format:@&quot;*** -[%@ %@]: pointer to objects array is NULL but range length is %lu&quot;, NSStringFromClass([self class]), NSStringFromSelector(_cmd), NSMaxRange(range)];        }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if((range.location &gt;  count) || (NSMaxRange(range) &gt; count)) { [NSException raise:NSRangeException format:@&quot;*** -[%@ %@]: index (%lu) beyond bounds (%lu)&quot;,                          NSStringFromClass([self class]), NSStringFromSelector(_cmd), NSMaxRange(range), count]; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  memcpy(objectsPtr, objects + range.location, range.length * sizeof(id));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (id)objectAtIndex:(NSUInteger)objectIndex</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(objectIndex &gt;= count) { [NSException raise:NSRangeException format:@&quot;*** -[%@ %@]: index (%lu) beyond bounds (%lu)&quot;, NSStringFromClass([self class]), NSStringFromSelector(_cmd), objectIndex, count]; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSParameterAssert((objects != NULL) &amp;&amp; (count &lt;= capacity) &amp;&amp; (objects[objectIndex] != NULL));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return(objects[objectIndex]);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state objects:(id *)stackbuf count:(NSUInteger)len</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSParameterAssert((state != NULL) &amp;&amp; (stackbuf != NULL) &amp;&amp; (len &gt; 0UL) &amp;&amp; (objects != NULL) &amp;&amp; (count &lt;= capacity));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(JK_EXPECT_F(state-&gt;state == 0UL))   { state-&gt;mutationsPtr = (unsigned long *)&amp;mutations; state-&gt;itemsPtr = stackbuf; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(JK_EXPECT_F(state-&gt;state &gt;= count)) { return(0UL); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSUInteger enumeratedCount  = 0UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  while(JK_EXPECT_T(enumeratedCount &lt; len) &amp;&amp; JK_EXPECT_T(state-&gt;state &lt; count)) { NSParameterAssert(objects[state-&gt;state] != NULL); stackbuf[enumeratedCount++] = objects[state-&gt;state++]; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return(enumeratedCount);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (void)insertObject:(id)anObject atIndex:(NSUInteger)objectIndex</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(mutations   == 0UL)   { [NSException raise:NSInternalInconsistencyException format:@&quot;*** -[%@ %@]: mutating method sent to immutable object&quot;, NSStringFromClass([self class]), NSStringFromSelector(_cmd)]; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(anObject    == NULL)  { [NSException raise:NSInvalidArgumentException       format:@&quot;*** -[%@ %@]: attempt to insert nil&quot;,                    NSStringFromClass([self class]), NSStringFromSelector(_cmd)]; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(objectIndex &gt;  count) { [NSException raise:NSRangeException                 format:@&quot;*** -[%@ %@]: index (%lu) beyond bounds (%lu)&quot;,          NSStringFromClass([self class]), NSStringFromSelector(_cmd), objectIndex, count + 1UL]; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#ifdef __clang_analyzer__</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  [anObject retain]; // Stupid clang analyzer...  Issue #19.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#else</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  anObject = [anObject retain];</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#endif</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  _JKArrayInsertObjectAtIndex(self, anObject, objectIndex);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  mutations = (mutations == NSUIntegerMax) ? 1UL : mutations + 1UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (void)removeObjectAtIndex:(NSUInteger)objectIndex</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(mutations   == 0UL)   { [NSException raise:NSInternalInconsistencyException format:@&quot;*** -[%@ %@]: mutating method sent to immutable object&quot;, NSStringFromClass([self class]), NSStringFromSelector(_cmd)]; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(objectIndex &gt;= count) { [NSException raise:NSRangeException                 format:@&quot;*** -[%@ %@]: index (%lu) beyond bounds (%lu)&quot;,          NSStringFromClass([self class]), NSStringFromSelector(_cmd), objectIndex, count]; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  _JKArrayRemoveObjectAtIndex(self, objectIndex);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  mutations = (mutations == NSUIntegerMax) ? 1UL : mutations + 1UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (void)replaceObjectAtIndex:(NSUInteger)objectIndex withObject:(id)anObject</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(mutations   == 0UL)   { [NSException raise:NSInternalInconsistencyException format:@&quot;*** -[%@ %@]: mutating method sent to immutable object&quot;, NSStringFromClass([self class]), NSStringFromSelector(_cmd)]; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(anObject    == NULL)  { [NSException raise:NSInvalidArgumentException       format:@&quot;*** -[%@ %@]: attempt to insert nil&quot;,                    NSStringFromClass([self class]), NSStringFromSelector(_cmd)]; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(objectIndex &gt;= count) { [NSException raise:NSRangeException                 format:@&quot;*** -[%@ %@]: index (%lu) beyond bounds (%lu)&quot;,          NSStringFromClass([self class]), NSStringFromSelector(_cmd), objectIndex, count]; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#ifdef __clang_analyzer__</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  [anObject retain]; // Stupid clang analyzer...  Issue #19.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#else</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  anObject = [anObject retain];</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#endif</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  _JKArrayReplaceObjectAtIndexWithObject(self, objectIndex, anObject);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  mutations = (mutations == NSUIntegerMax) ? 1UL : mutations + 1UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (id)copyWithZone:(NSZone *)zone</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSParameterAssert((objects != NULL) &amp;&amp; (count &lt;= capacity));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return((mutations == 0UL) ? [self retain] : [(NSArray *)[NSArray allocWithZone:zone] initWithObjects:objects count:count]);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (id)mutableCopyWithZone:(NSZone *)zone</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSParameterAssert((objects != NULL) &amp;&amp; (count &lt;= capacity));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return([(NSMutableArray *)[NSMutableArray allocWithZone:zone] initWithObjects:objects count:count]);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>@end</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#pragma mark -</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>@interface JKDictionaryEnumerator : NSEnumerator {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  id         collection;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  NSUInteger nextObject;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>- (id)initWithJKDictionary:(JKDictionary *)initDictionary;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>- (NSArray *)allObjects;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>- (id)nextObject;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>@end</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>@implementation JKDictionaryEnumerator</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (id)initWithJKDictionary:(JKDictionary *)initDictionary</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSParameterAssert(initDictionary != NULL);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if((self = [super init]) == NULL) { return(NULL); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if((collection = (id)CFRetain(initDictionary)) == NULL) { [self autorelease]; return(NULL); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return(self);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (void)dealloc</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(collection != NULL) { CFRelease(collection); collection = NULL; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  [super dealloc];</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (NSArray *)allObjects</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSParameterAssert(collection != NULL);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSUInteger count = [(NSDictionary *)collection count], atObject = 0UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  id         objects[count];</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  while((objects[atObject] = [self nextObject]) != NULL) { NSParameterAssert(atObject &lt; count); atObject++; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return([NSArray arrayWithObjects:objects count:atObject]);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (id)nextObject</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSParameterAssert((collection != NULL) &amp;&amp; (_JKDictionaryHashEntry(collection) != NULL));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  JKHashTableEntry *entry        = _JKDictionaryHashEntry(collection);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSUInteger        capacity     = _JKDictionaryCapacity(collection);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  id                returnObject = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(entry != NULL) { while((nextObject &lt; capacity) &amp;&amp; ((returnObject = entry[nextObject++].key) == NULL)) { /* ... */ } }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return(returnObject);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>@end</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#pragma mark -</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>@interface JKDictionary : NSMutableDictionary &lt;NSCopying, NSMutableCopying, NSFastEnumeration&gt; {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  NSUInteger count, capacity, mutations;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  JKHashTableEntry *entry;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>@end</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>@implementation JKDictionary</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>+ (id)allocWithZone:(NSZone *)zone</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#pragma unused(zone)</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  [NSException raise:NSInvalidArgumentException format:@&quot;*** - [%@ %@]: The %@ class is private to JSONKit and should not be used in this fashion.&quot;, NSStringFromClass([self class]), NSStringFromSelector(_cmd), NSStringFromClass([self class])];</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return(NULL);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>// These values are taken from Core Foundation CF-550 CFBasicHash.m.  As a bonus, they align very well with our JKHashTableEntry struct too.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>static const NSUInteger jk_dictionaryCapacities[] = {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  0UL, 3UL, 7UL, 13UL, 23UL, 41UL, 71UL, 127UL, 191UL, 251UL, 383UL, 631UL, 1087UL, 1723UL,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  2803UL, 4523UL, 7351UL, 11959UL, 19447UL, 31231UL, 50683UL, 81919UL, 132607UL,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  214519UL, 346607UL, 561109UL, 907759UL, 1468927UL, 2376191UL, 3845119UL,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  6221311UL, 10066421UL, 16287743UL, 26354171UL, 42641881UL, 68996069UL,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  111638519UL, 180634607UL, 292272623UL, 472907251UL</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>};</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>static NSUInteger _JKDictionaryCapacityForCount(NSUInteger count) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSUInteger bottom = 0UL, top = sizeof(jk_dictionaryCapacities) / sizeof(NSUInteger), mid = 0UL, tableSize = lround(floor((count) * 1.33));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  while(top &gt; bottom) { mid = (top + bottom) / 2UL; if(jk_dictionaryCapacities[mid] &lt; tableSize) { bottom = mid + 1UL; } else { top = mid; } }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return(jk_dictionaryCapacities[bottom]);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>static void _JKDictionaryResizeIfNeccessary(JKDictionary *dictionary) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSCParameterAssert((dictionary != NULL) &amp;&amp; (dictionary-&gt;entry != NULL) &amp;&amp; (dictionary-&gt;count &lt;= dictionary-&gt;capacity));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSUInteger capacityForCount = 0UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(dictionary-&gt;capacity &lt; (capacityForCount = _JKDictionaryCapacityForCount(dictionary-&gt;count + 1UL))) { // resize</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    NSUInteger        oldCapacity = dictionary-&gt;capacity;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#ifndef NS_BLOCK_ASSERTIONS</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    NSUInteger oldCount = dictionary-&gt;count;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#endif</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    JKHashTableEntry *oldEntry    = dictionary-&gt;entry;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if(JK_EXPECT_F((dictionary-&gt;entry = (JKHashTableEntry *)calloc(1UL, sizeof(JKHashTableEntry) * capacityForCount)) == NULL)) { [NSException raise:NSMallocException format:@&quot;Unable to allocate memory for hash table.&quot;]; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    dictionary-&gt;capacity = capacityForCount;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    dictionary-&gt;count    = 0UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>    </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    NSUInteger idx = 0UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    for(idx = 0UL; idx &lt; oldCapacity; idx++) { if(oldEntry[idx].key != NULL) { _JKDictionaryAddObject(dictionary, oldEntry[idx].keyHash, oldEntry[idx].key, oldEntry[idx].object); oldEntry[idx].keyHash = 0UL; oldEntry[idx].key = NULL; oldEntry[idx].object = NULL; } }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    NSCParameterAssert((oldCount == dictionary-&gt;count));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    free(oldEntry); oldEntry = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>static JKDictionary *_JKDictionaryCreate(id *keys, NSUInteger *keyHashes, id *objects, NSUInteger count, BOOL mutableCollection) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSCParameterAssert((keys != NULL) &amp;&amp; (keyHashes != NULL) &amp;&amp; (objects != NULL) &amp;&amp; (_JKDictionaryClass != NULL) &amp;&amp; (_JKDictionaryInstanceSize &gt; 0UL));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  JKDictionary *dictionary = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(JK_EXPECT_T((dictionary = (JKDictionary *)calloc(1UL, _JKDictionaryInstanceSize)) != NULL)) { // Directly allocate the JKDictionary instance via calloc.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    dictionary-&gt;isa      = _JKDictionaryClass;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if((dictionary = [dictionary init]) == NULL) { return(NULL); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    dictionary-&gt;capacity = _JKDictionaryCapacityForCount(count);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    dictionary-&gt;count    = 0UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>    </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if(JK_EXPECT_F((dictionary-&gt;entry = (JKHashTableEntry *)calloc(1UL, sizeof(JKHashTableEntry) * dictionary-&gt;capacity)) == NULL)) { [dictionary autorelease]; return(NULL); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    NSUInteger idx = 0UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    for(idx = 0UL; idx &lt; count; idx++) { _JKDictionaryAddObject(dictionary, keyHashes[idx], keys[idx], objects[idx]); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    dictionary-&gt;mutations = (mutableCollection == NO) ? 0UL : 1UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return(dictionary);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (void)dealloc</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(JK_EXPECT_T(entry != NULL)) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    NSUInteger atEntry = 0UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    for(atEntry = 0UL; atEntry &lt; capacity; atEntry++) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      if(JK_EXPECT_T(entry[atEntry].key    != NULL)) { CFRelease(entry[atEntry].key);    entry[atEntry].key    = NULL; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      if(JK_EXPECT_T(entry[atEntry].object != NULL)) { CFRelease(entry[atEntry].object); entry[atEntry].object = NULL; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    free(entry); entry = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  [super dealloc];</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>static JKHashTableEntry *_JKDictionaryHashEntry(JKDictionary *dictionary) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSCParameterAssert(dictionary != NULL);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return(dictionary-&gt;entry);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>static NSUInteger _JKDictionaryCapacity(JKDictionary *dictionary) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSCParameterAssert(dictionary != NULL);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return(dictionary-&gt;capacity);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>static void _JKDictionaryRemoveObjectWithEntry(JKDictionary *dictionary, JKHashTableEntry *entry) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSCParameterAssert((dictionary != NULL) &amp;&amp; (entry != NULL) &amp;&amp; (entry-&gt;key != NULL) &amp;&amp; (entry-&gt;object != NULL) &amp;&amp; (dictionary-&gt;count &gt; 0UL) &amp;&amp; (dictionary-&gt;count &lt;= dictionary-&gt;capacity));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  CFRelease(entry-&gt;key);    entry-&gt;key    = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  CFRelease(entry-&gt;object); entry-&gt;object = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  entry-&gt;keyHash = 0UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  dictionary-&gt;count--;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  // In order for certain invariants that are used to speed up the search for a particular key, we need to &quot;re-add&quot; all the entries in the hash table following this entry until we hit a NULL entry.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSUInteger removeIdx = entry - dictionary-&gt;entry, idx = 0UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSCParameterAssert((removeIdx &lt; dictionary-&gt;capacity));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  for(idx = 0UL; idx &lt; dictionary-&gt;capacity; idx++) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    NSUInteger entryIdx = (removeIdx + idx + 1UL) % dictionary-&gt;capacity;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    JKHashTableEntry *atEntry = &amp;dictionary-&gt;entry[entryIdx];</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if(atEntry-&gt;key == NULL) { break; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    NSUInteger keyHash = atEntry-&gt;keyHash;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    id key = atEntry-&gt;key, object = atEntry-&gt;object;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    NSCParameterAssert(object != NULL);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    atEntry-&gt;keyHash = 0UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    atEntry-&gt;key     = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    atEntry-&gt;object  = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    NSUInteger addKeyEntry = keyHash % dictionary-&gt;capacity, addIdx = 0UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    for(addIdx = 0UL; addIdx &lt; dictionary-&gt;capacity; addIdx++) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      JKHashTableEntry *atAddEntry = &amp;dictionary-&gt;entry[((addKeyEntry + addIdx) % dictionary-&gt;capacity)];</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      if(JK_EXPECT_T(atAddEntry-&gt;key == NULL)) { NSCParameterAssert((atAddEntry-&gt;keyHash == 0UL) &amp;&amp; (atAddEntry-&gt;object == NULL)); atAddEntry-&gt;key = key; atAddEntry-&gt;object = object; atAddEntry-&gt;keyHash = keyHash; break; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>static void _JKDictionaryAddObject(JKDictionary *dictionary, NSUInteger keyHash, id key, id object) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSCParameterAssert((dictionary != NULL) &amp;&amp; (key != NULL) &amp;&amp; (object != NULL) &amp;&amp; (dictionary-&gt;count &lt; dictionary-&gt;capacity) &amp;&amp; (dictionary-&gt;entry != NULL));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSUInteger keyEntry = keyHash % dictionary-&gt;capacity, idx = 0UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  for(idx = 0UL; idx &lt; dictionary-&gt;capacity; idx++) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    NSUInteger entryIdx = (keyEntry + idx) % dictionary-&gt;capacity;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    JKHashTableEntry *atEntry = &amp;dictionary-&gt;entry[entryIdx];</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if(JK_EXPECT_F(atEntry-&gt;keyHash == keyHash) &amp;&amp; JK_EXPECT_T(atEntry-&gt;key != NULL) &amp;&amp; (JK_EXPECT_F(key == atEntry-&gt;key) || JK_EXPECT_F(CFEqual(atEntry-&gt;key, key)))) { _JKDictionaryRemoveObjectWithEntry(dictionary, atEntry); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if(JK_EXPECT_T(atEntry-&gt;key == NULL)) { NSCParameterAssert((atEntry-&gt;keyHash == 0UL) &amp;&amp; (atEntry-&gt;object == NULL)); atEntry-&gt;key = key; atEntry-&gt;object = object; atEntry-&gt;keyHash = keyHash; dictionary-&gt;count++; return; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  // We should never get here.  If we do, we -release the key / object because it&apos;s our responsibility.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  CFRelease(key);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  CFRelease(object);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (NSUInteger)count</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return(count);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>static JKHashTableEntry *_JKDictionaryHashTableEntryForKey(JKDictionary *dictionary, id aKey) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSCParameterAssert((dictionary != NULL) &amp;&amp; (dictionary-&gt;entry != NULL) &amp;&amp; (dictionary-&gt;count &lt;= dictionary-&gt;capacity));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if((aKey == NULL) || (dictionary-&gt;capacity == 0UL)) { return(NULL); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSUInteger        keyHash = CFHash(aKey), keyEntry = (keyHash % dictionary-&gt;capacity), idx = 0UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  JKHashTableEntry *atEntry = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  for(idx = 0UL; idx &lt; dictionary-&gt;capacity; idx++) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    atEntry = &amp;dictionary-&gt;entry[(keyEntry + idx) % dictionary-&gt;capacity];</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if(JK_EXPECT_T(atEntry-&gt;keyHash == keyHash) &amp;&amp; JK_EXPECT_T(atEntry-&gt;key != NULL) &amp;&amp; ((atEntry-&gt;key == aKey) || CFEqual(atEntry-&gt;key, aKey))) { NSCParameterAssert(atEntry-&gt;object != NULL); return(atEntry); break; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if(JK_EXPECT_F(atEntry-&gt;key == NULL)) { NSCParameterAssert(atEntry-&gt;object == NULL); return(NULL); break; } // If the key was in the table, we would have found it by now.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return(NULL);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (id)objectForKey:(id)aKey</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSParameterAssert((entry != NULL) &amp;&amp; (count &lt;= capacity));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  JKHashTableEntry *entryForKey = _JKDictionaryHashTableEntryForKey(self, aKey);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return((entryForKey != NULL) ? entryForKey-&gt;object : NULL);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (void)getObjects:(id *)objects andKeys:(id *)keys</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSParameterAssert((entry != NULL) &amp;&amp; (count &lt;= capacity));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSUInteger atEntry = 0UL; NSUInteger arrayIdx = 0UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  for(atEntry = 0UL; atEntry &lt; capacity; atEntry++) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if(JK_EXPECT_T(entry[atEntry].key != NULL)) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      NSCParameterAssert((entry[atEntry].object != NULL) &amp;&amp; (arrayIdx &lt; count));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      if(JK_EXPECT_T(keys    != NULL)) { keys[arrayIdx]    = entry[atEntry].key;    }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      if(JK_EXPECT_T(objects != NULL)) { objects[arrayIdx] = entry[atEntry].object; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      arrayIdx++;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state objects:(id *)stackbuf count:(NSUInteger)len</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSParameterAssert((state != NULL) &amp;&amp; (stackbuf != NULL) &amp;&amp; (len &gt; 0UL) &amp;&amp; (entry != NULL) &amp;&amp; (count &lt;= capacity));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(JK_EXPECT_F(state-&gt;state == 0UL))      { state-&gt;mutationsPtr = (unsigned long *)&amp;mutations; state-&gt;itemsPtr = stackbuf; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(JK_EXPECT_F(state-&gt;state &gt;= capacity)) { return(0UL); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSUInteger enumeratedCount  = 0UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  while(JK_EXPECT_T(enumeratedCount &lt; len) &amp;&amp; JK_EXPECT_T(state-&gt;state &lt; capacity)) { if(JK_EXPECT_T(entry[state-&gt;state].key != NULL)) { stackbuf[enumeratedCount++] = entry[state-&gt;state].key; } state-&gt;state++; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>    </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return(enumeratedCount);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (NSEnumerator *)keyEnumerator</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return([[[JKDictionaryEnumerator alloc] initWithJKDictionary:self] autorelease]);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (void)setObject:(id)anObject forKey:(id)aKey</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(mutations == 0UL)  { [NSException raise:NSInternalInconsistencyException format:@&quot;*** -[%@ %@]: mutating method sent to immutable object&quot;, NSStringFromClass([self class]), NSStringFromSelector(_cmd)];       }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(aKey      == NULL) { [NSException raise:NSInvalidArgumentException       format:@&quot;*** -[%@ %@]: attempt to insert nil key&quot;,                NSStringFromClass([self class]), NSStringFromSelector(_cmd)];       }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(anObject  == NULL) { [NSException raise:NSInvalidArgumentException       format:@&quot;*** -[%@ %@]: attempt to insert nil value (key: %@)&quot;,    NSStringFromClass([self class]), NSStringFromSelector(_cmd), aKey]; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  _JKDictionaryResizeIfNeccessary(self);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#ifndef __clang_analyzer__</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  aKey     = [aKey     copy];   // Why on earth would clang complain that this -copy &quot;might leak&quot;, </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  anObject = [anObject retain]; // but this -retain doesn&apos;t!?</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#endif // __clang_analyzer__</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  _JKDictionaryAddObject(self, CFHash(aKey), aKey, anObject);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  mutations = (mutations == NSUIntegerMax) ? 1UL : mutations + 1UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (void)removeObjectForKey:(id)aKey</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(mutations == 0UL)  { [NSException raise:NSInternalInconsistencyException format:@&quot;*** -[%@ %@]: mutating method sent to immutable object&quot;, NSStringFromClass([self class]), NSStringFromSelector(_cmd)]; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(aKey      == NULL) { [NSException raise:NSInvalidArgumentException       format:@&quot;*** -[%@ %@]: attempt to remove nil key&quot;,                NSStringFromClass([self class]), NSStringFromSelector(_cmd)]; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  JKHashTableEntry *entryForKey = _JKDictionaryHashTableEntryForKey(self, aKey);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(entryForKey != NULL) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    _JKDictionaryRemoveObjectWithEntry(self, entryForKey);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    mutations = (mutations == NSUIntegerMax) ? 1UL : mutations + 1UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (id)copyWithZone:(NSZone *)zone</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSParameterAssert((entry != NULL) &amp;&amp; (count &lt;= capacity));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return((mutations == 0UL) ? [self retain] : [[NSDictionary allocWithZone:zone] initWithDictionary:self]);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (id)mutableCopyWithZone:(NSZone *)zone</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSParameterAssert((entry != NULL) &amp;&amp; (count &lt;= capacity));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return([[NSMutableDictionary allocWithZone:zone] initWithDictionary:self]);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>@end</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#pragma mark -</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>JK_STATIC_INLINE size_t jk_min(size_t a, size_t b) { return((a &lt; b) ? a : b); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>6</td>
<td class='sourcelinehit'>JK_STATIC_INLINE size_t jk_max(size_t a, size_t b) { return((a &gt; b) ? a : b); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>JK_STATIC_INLINE JKHash calculateHash(JKHash currentHash, unsigned char c) { return(((currentHash &lt;&lt; 5) + currentHash) + c); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>static void jk_error(JKParseState *parseState, NSString *format, ...) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSCParameterAssert((parseState != NULL) &amp;&amp; (format != NULL));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  va_list varArgsList;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  va_start(varArgsList, format);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSString *formatString = [[[NSString alloc] initWithFormat:format arguments:varArgsList] autorelease];</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  va_end(varArgsList);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#if 0</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  const unsigned char *lineStart      = parseState-&gt;stringBuffer.bytes.ptr + parseState-&gt;lineStartIndex;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  const unsigned char *lineEnd        = lineStart;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  const unsigned char *atCharacterPtr = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  for(atCharacterPtr = lineStart; atCharacterPtr &lt; JK_END_STRING_PTR(parseState); atCharacterPtr++) { lineEnd = atCharacterPtr; if(jk_parse_is_newline(parseState, atCharacterPtr)) { break; } }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  NSString *lineString = @&quot;&quot;, *carretString = @&quot;&quot;;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  if(lineStart &lt; JK_END_STRING_PTR(parseState)) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>    lineString   = [[[NSString alloc] initWithBytes:lineStart length:(lineEnd - lineStart) encoding:NSUTF8StringEncoding] autorelease];</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>    carretString = [NSString stringWithFormat:@&quot;%*.*s^&quot;, (int)(parseState-&gt;atIndex - parseState-&gt;lineStartIndex), (int)(parseState-&gt;atIndex - parseState-&gt;lineStartIndex), &quot; &quot;];</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#endif</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(parseState-&gt;error == NULL) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    parseState-&gt;error = [NSError errorWithDomain:@&quot;JKErrorDomain&quot; code:-1L userInfo:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>                                   [NSDictionary dictionaryWithObjectsAndKeys:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>                                                                              formatString,                                             NSLocalizedDescriptionKey,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>                                                                              [NSNumber numberWithUnsignedLong:parseState-&gt;atIndex],    @&quot;JKAtIndexKey&quot;,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>                                                                              [NSNumber numberWithUnsignedLong:parseState-&gt;lineNumber], @&quot;JKLineNumberKey&quot;,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>                                                 //lineString,   @&quot;JKErrorLine0Key&quot;,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>                                                 //carretString, @&quot;JKErrorLine1Key&quot;,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>                                                                              NULL]];</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#pragma mark -</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#pragma mark Buffer and Object Stack management functions</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>static void jk_managedBuffer_release(JKManagedBuffer *managedBuffer) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if((managedBuffer-&gt;flags &amp; JKManagedBufferMustFree)) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if(managedBuffer-&gt;bytes.ptr != NULL) { free(managedBuffer-&gt;bytes.ptr); managedBuffer-&gt;bytes.ptr = NULL; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    managedBuffer-&gt;flags &amp;= ~JKManagedBufferMustFree;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  managedBuffer-&gt;bytes.ptr     = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  managedBuffer-&gt;bytes.length  = 0UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  managedBuffer-&gt;flags        &amp;= ~JKManagedBufferLocationMask;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>static void jk_managedBuffer_setToStackBuffer(JKManagedBuffer *managedBuffer, unsigned char *ptr, size_t length) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  jk_managedBuffer_release(managedBuffer);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  managedBuffer-&gt;bytes.ptr     = ptr;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  managedBuffer-&gt;bytes.length  = length;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  managedBuffer-&gt;flags         = (managedBuffer-&gt;flags &amp; ~JKManagedBufferLocationMask) | JKManagedBufferOnStack;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>static unsigned char *jk_managedBuffer_resize(JKManagedBuffer *managedBuffer, size_t newSize) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  size_t roundedUpNewSize = newSize;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(managedBuffer-&gt;roundSizeUpToMultipleOf &gt; 0UL) { roundedUpNewSize = newSize + ((managedBuffer-&gt;roundSizeUpToMultipleOf - (newSize % managedBuffer-&gt;roundSizeUpToMultipleOf)) % managedBuffer-&gt;roundSizeUpToMultipleOf); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if((roundedUpNewSize != managedBuffer-&gt;bytes.length) &amp;&amp; (roundedUpNewSize &gt; managedBuffer-&gt;bytes.length)) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if((managedBuffer-&gt;flags &amp; JKManagedBufferLocationMask) == JKManagedBufferOnStack) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      NSCParameterAssert((managedBuffer-&gt;flags &amp; JKManagedBufferMustFree) == 0);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      unsigned char *newBuffer = NULL, *oldBuffer = managedBuffer-&gt;bytes.ptr;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>      </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      if((newBuffer = (unsigned char *)malloc(roundedUpNewSize)) == NULL) { return(NULL); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      memcpy(newBuffer, oldBuffer, jk_min(managedBuffer-&gt;bytes.length, roundedUpNewSize));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      managedBuffer-&gt;flags        = (managedBuffer-&gt;flags &amp; ~JKManagedBufferLocationMask) | (JKManagedBufferOnHeap | JKManagedBufferMustFree);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      managedBuffer-&gt;bytes.ptr    = newBuffer;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      managedBuffer-&gt;bytes.length = roundedUpNewSize;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    } else {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      NSCParameterAssert(((managedBuffer-&gt;flags &amp; JKManagedBufferMustFree) != 0) &amp;&amp; ((managedBuffer-&gt;flags &amp; JKManagedBufferLocationMask) == JKManagedBufferOnHeap));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      if((managedBuffer-&gt;bytes.ptr = (unsigned char *)reallocf(managedBuffer-&gt;bytes.ptr, roundedUpNewSize)) == NULL) { return(NULL); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      managedBuffer-&gt;bytes.length = roundedUpNewSize;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>    }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return(managedBuffer-&gt;bytes.ptr);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>static void jk_objectStack_release(JKObjectStack *objectStack) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSCParameterAssert(objectStack != NULL);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSCParameterAssert(objectStack-&gt;index &lt;= objectStack-&gt;count);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  size_t atIndex = 0UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  for(atIndex = 0UL; atIndex &lt; objectStack-&gt;index; atIndex++) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if(objectStack-&gt;objects[atIndex] != NULL) { CFRelease(objectStack-&gt;objects[atIndex]); objectStack-&gt;objects[atIndex] = NULL; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if(objectStack-&gt;keys[atIndex]    != NULL) { CFRelease(objectStack-&gt;keys[atIndex]);    objectStack-&gt;keys[atIndex]    = NULL; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  objectStack-&gt;index = 0UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(objectStack-&gt;flags &amp; JKObjectStackMustFree) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    NSCParameterAssert((objectStack-&gt;flags &amp; JKObjectStackLocationMask) == JKObjectStackOnHeap);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if(objectStack-&gt;objects  != NULL) { free(objectStack-&gt;objects);  objectStack-&gt;objects  = NULL; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if(objectStack-&gt;keys     != NULL) { free(objectStack-&gt;keys);     objectStack-&gt;keys     = NULL; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if(objectStack-&gt;cfHashes != NULL) { free(objectStack-&gt;cfHashes); objectStack-&gt;cfHashes = NULL; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    objectStack-&gt;flags &amp;= ~JKObjectStackMustFree;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  objectStack-&gt;objects  = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  objectStack-&gt;keys     = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  objectStack-&gt;cfHashes = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  objectStack-&gt;count    = 0UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  objectStack-&gt;flags   &amp;= ~JKObjectStackLocationMask;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>static void jk_objectStack_setToStackBuffer(JKObjectStack *objectStack, void **objects, void **keys, CFHashCode *cfHashes, size_t count) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSCParameterAssert((objectStack != NULL) &amp;&amp; (objects != NULL) &amp;&amp; (keys != NULL) &amp;&amp; (cfHashes != NULL) &amp;&amp; (count &gt; 0UL));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  jk_objectStack_release(objectStack);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  objectStack-&gt;objects  = objects;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  objectStack-&gt;keys     = keys;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  objectStack-&gt;cfHashes = cfHashes;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  objectStack-&gt;count    = count;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  objectStack-&gt;flags    = (objectStack-&gt;flags &amp; ~JKObjectStackLocationMask) | JKObjectStackOnStack;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#ifndef NS_BLOCK_ASSERTIONS</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  size_t idx;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  for(idx = 0UL; idx &lt; objectStack-&gt;count; idx++) { objectStack-&gt;objects[idx] = NULL; objectStack-&gt;keys[idx] = NULL; objectStack-&gt;cfHashes[idx] = 0UL; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#endif</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>static int jk_objectStack_resize(JKObjectStack *objectStack, size_t newCount) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  size_t roundedUpNewCount = newCount;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  int    returnCode = 0;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  void       **newObjects  = NULL, **newKeys = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  CFHashCode  *newCFHashes = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(objectStack-&gt;roundSizeUpToMultipleOf &gt; 0UL) { roundedUpNewCount = newCount + ((objectStack-&gt;roundSizeUpToMultipleOf - (newCount % objectStack-&gt;roundSizeUpToMultipleOf)) % objectStack-&gt;roundSizeUpToMultipleOf); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if((roundedUpNewCount != objectStack-&gt;count) &amp;&amp; (roundedUpNewCount &gt; objectStack-&gt;count)) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if((objectStack-&gt;flags &amp; JKObjectStackLocationMask) == JKObjectStackOnStack) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      NSCParameterAssert((objectStack-&gt;flags &amp; JKObjectStackMustFree) == 0);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      if((newObjects  = (void **     )calloc(1UL, roundedUpNewCount * sizeof(void *    ))) == NULL) { returnCode = 1; goto errorExit; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      memcpy(newObjects, objectStack-&gt;objects,   jk_min(objectStack-&gt;count, roundedUpNewCount) * sizeof(void *));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      if((newKeys     = (void **     )calloc(1UL, roundedUpNewCount * sizeof(void *    ))) == NULL) { returnCode = 1; goto errorExit; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      memcpy(newKeys,     objectStack-&gt;keys,     jk_min(objectStack-&gt;count, roundedUpNewCount) * sizeof(void *));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      if((newCFHashes = (CFHashCode *)calloc(1UL, roundedUpNewCount * sizeof(CFHashCode))) == NULL) { returnCode = 1; goto errorExit; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      memcpy(newCFHashes, objectStack-&gt;cfHashes, jk_min(objectStack-&gt;count, roundedUpNewCount) * sizeof(CFHashCode));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      objectStack-&gt;flags    = (objectStack-&gt;flags &amp; ~JKObjectStackLocationMask) | (JKObjectStackOnHeap | JKObjectStackMustFree);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      objectStack-&gt;objects  = newObjects;  newObjects  = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      objectStack-&gt;keys     = newKeys;     newKeys     = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      objectStack-&gt;cfHashes = newCFHashes; newCFHashes = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      objectStack-&gt;count    = roundedUpNewCount;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    } else {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      NSCParameterAssert(((objectStack-&gt;flags &amp; JKObjectStackMustFree) != 0) &amp;&amp; ((objectStack-&gt;flags &amp; JKObjectStackLocationMask) == JKObjectStackOnHeap));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      if((newObjects  = (void  **    )realloc(objectStack-&gt;objects,  roundedUpNewCount * sizeof(void *    ))) != NULL) { objectStack-&gt;objects  = newObjects;  newObjects  = NULL; } else { returnCode = 1; goto errorExit; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      if((newKeys     = (void  **    )realloc(objectStack-&gt;keys,     roundedUpNewCount * sizeof(void *    ))) != NULL) { objectStack-&gt;keys     = newKeys;     newKeys     = NULL; } else { returnCode = 1; goto errorExit; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      if((newCFHashes = (CFHashCode *)realloc(objectStack-&gt;cfHashes, roundedUpNewCount * sizeof(CFHashCode))) != NULL) { objectStack-&gt;cfHashes = newCFHashes; newCFHashes = NULL; } else { returnCode = 1; goto errorExit; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#ifndef NS_BLOCK_ASSERTIONS</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      size_t idx;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      for(idx = objectStack-&gt;count; idx &lt; roundedUpNewCount; idx++) { objectStack-&gt;objects[idx] = NULL; objectStack-&gt;keys[idx] = NULL; objectStack-&gt;cfHashes[idx] = 0UL; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#endif</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      objectStack-&gt;count = roundedUpNewCount;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>    }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> errorExit:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(newObjects  != NULL) { free(newObjects);  newObjects  = NULL; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(newKeys     != NULL) { free(newKeys);     newKeys     = NULL; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(newCFHashes != NULL) { free(newCFHashes); newCFHashes = NULL; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return(returnCode);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>////////////</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#pragma mark -</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#pragma mark Unicode related functions</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>JK_STATIC_INLINE ConversionResult isValidCodePoint(UTF32 *u32CodePoint) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  ConversionResult result = conversionOK;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  UTF32            ch     = *u32CodePoint;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(JK_EXPECT_F(ch &gt;= UNI_SUR_HIGH_START) &amp;&amp; (JK_EXPECT_T(ch &lt;= UNI_SUR_LOW_END)))                                                        { result = sourceIllegal; ch = UNI_REPLACEMENT_CHAR; goto finished; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(JK_EXPECT_F(ch &gt;= 0xFDD0U) &amp;&amp; (JK_EXPECT_F(ch &lt;= 0xFDEFU) || JK_EXPECT_F((ch &amp; 0xFFFEU) == 0xFFFEU)) &amp;&amp; JK_EXPECT_T(ch &lt;= 0x10FFFFU)) { result = sourceIllegal; ch = UNI_REPLACEMENT_CHAR; goto finished; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(JK_EXPECT_F(ch == 0U))                                                                                                                { result = sourceIllegal; ch = UNI_REPLACEMENT_CHAR; goto finished; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> finished:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  *u32CodePoint = ch;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return(result);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>static int isLegalUTF8(const UTF8 *source, size_t length) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  const UTF8 *srcptr = source + length;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  UTF8 a;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  switch(length) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    default: return(0); // Everything else falls through when &quot;true&quot;...</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    case 4: if(JK_EXPECT_F(((a = (*--srcptr)) &lt; 0x80) || (a &gt; 0xBF))) { return(0); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    case 3: if(JK_EXPECT_F(((a = (*--srcptr)) &lt; 0x80) || (a &gt; 0xBF))) { return(0); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    case 2: if(JK_EXPECT_F( (a = (*--srcptr)) &gt; 0xBF               )) { return(0); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>      </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      switch(*source) { // no fall-through in this inner switch</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        case 0xE0: if(JK_EXPECT_F(a &lt; 0xA0)) { return(0); } break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        case 0xED: if(JK_EXPECT_F(a &gt; 0x9F)) { return(0); } break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        case 0xF0: if(JK_EXPECT_F(a &lt; 0x90)) { return(0); } break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        case 0xF4: if(JK_EXPECT_F(a &gt; 0x8F)) { return(0); } break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        default:   if(JK_EXPECT_F(a &lt; 0x80)) { return(0); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>      </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    case 1: if(JK_EXPECT_F((JK_EXPECT_T(*source &lt; 0xC2)) &amp;&amp; JK_EXPECT_F(*source &gt;= 0x80))) { return(0); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(JK_EXPECT_F(*source &gt; 0xF4)) { return(0); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return(1);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>static ConversionResult ConvertSingleCodePointInUTF8(const UTF8 *sourceStart, const UTF8 *sourceEnd, UTF8 const **nextUTF8, UTF32 *convertedUTF32) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  ConversionResult result = conversionOK;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  const UTF8 *source = sourceStart;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  UTF32 ch = 0UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#if !defined(JK_FAST_TRAILING_BYTES)</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  unsigned short extraBytesToRead = trailingBytesForUTF8[*source];</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#else</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  unsigned short extraBytesToRead = __builtin_clz(((*source)^0xff) &lt;&lt; 25);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#endif</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(JK_EXPECT_F((source + extraBytesToRead + 1) &gt; sourceEnd) || JK_EXPECT_F(!isLegalUTF8(source, extraBytesToRead + 1))) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    source++;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    while((source &lt; sourceEnd) &amp;&amp; (((*source) &amp; 0xc0) == 0x80) &amp;&amp; ((source - sourceStart) &lt; (extraBytesToRead + 1))) { source++; } </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    NSCParameterAssert(source &lt;= sourceEnd);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    result = ((source &lt; sourceEnd) &amp;&amp; (((*source) &amp; 0xc0) != 0x80)) ? sourceIllegal : ((sourceStart + extraBytesToRead + 1) &gt; sourceEnd) ? sourceExhausted : sourceIllegal;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    ch = UNI_REPLACEMENT_CHAR;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    goto finished;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  switch(extraBytesToRead) { // The cases all fall through.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    case 5: ch += *source++; ch &lt;&lt;= 6;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    case 4: ch += *source++; ch &lt;&lt;= 6;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    case 3: ch += *source++; ch &lt;&lt;= 6;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    case 2: ch += *source++; ch &lt;&lt;= 6;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    case 1: ch += *source++; ch &lt;&lt;= 6;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    case 0: ch += *source++;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  ch -= offsetsFromUTF8[extraBytesToRead];</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  result = isValidCodePoint(&amp;ch);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> finished:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  *nextUTF8       = source;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  *convertedUTF32 = ch;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return(result);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>static ConversionResult ConvertUTF32toUTF8 (UTF32 u32CodePoint, UTF8 **targetStart, UTF8 *targetEnd) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  const UTF32       byteMask     = 0xBF, byteMark = 0x80;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  ConversionResult  result       = conversionOK;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  UTF8             *target       = *targetStart;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  UTF32             ch           = u32CodePoint;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  unsigned short    bytesToWrite = 0;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  result = isValidCodePoint(&amp;ch);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  // Figure out how many bytes the result will require. Turn any illegally large UTF32 things (&gt; Plane 17) into replacement chars.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>       if(ch &lt; (UTF32)0x80)          { bytesToWrite = 1; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  else if(ch &lt; (UTF32)0x800)         { bytesToWrite = 2; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  else if(ch &lt; (UTF32)0x10000)       { bytesToWrite = 3; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  else if(ch &lt;= UNI_MAX_LEGAL_UTF32) { bytesToWrite = 4; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  else {                               bytesToWrite = 3; ch = UNI_REPLACEMENT_CHAR; result = sourceIllegal; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>        </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  target += bytesToWrite;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if (target &gt; targetEnd) { target -= bytesToWrite; result = targetExhausted; goto finished; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  switch (bytesToWrite) { // note: everything falls through.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    case 4: *--target = (UTF8)((ch | byteMark) &amp; byteMask); ch &gt;&gt;= 6;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    case 3: *--target = (UTF8)((ch | byteMark) &amp; byteMask); ch &gt;&gt;= 6;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    case 2: *--target = (UTF8)((ch | byteMark) &amp; byteMask); ch &gt;&gt;= 6;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    case 1: *--target = (UTF8) (ch | firstByteMark[bytesToWrite]);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  target += bytesToWrite;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> finished:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  *targetStart = target;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return(result);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>JK_STATIC_INLINE int jk_string_add_unicodeCodePoint(JKParseState *parseState, uint32_t unicodeCodePoint, size_t *tokenBufferIdx, JKHash *stringHash) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  UTF8             *u8s = &amp;parseState-&gt;token.tokenBuffer.bytes.ptr[*tokenBufferIdx];</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  ConversionResult  result;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if((result = ConvertUTF32toUTF8(unicodeCodePoint, &amp;u8s, (parseState-&gt;token.tokenBuffer.bytes.ptr + parseState-&gt;token.tokenBuffer.bytes.length))) != conversionOK) { if(result == targetExhausted) { return(1); } }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  size_t utf8len = u8s - &amp;parseState-&gt;token.tokenBuffer.bytes.ptr[*tokenBufferIdx], nextIdx = (*tokenBufferIdx) + utf8len;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  while(*tokenBufferIdx &lt; nextIdx) { *stringHash = calculateHash(*stringHash, parseState-&gt;token.tokenBuffer.bytes.ptr[(*tokenBufferIdx)++]); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return(0);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>////////////</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#pragma mark -</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#pragma mark Decoding / parsing / deserializing functions</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>static int jk_parse_string(JKParseState *parseState) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSCParameterAssert((parseState != NULL) &amp;&amp; (JK_AT_STRING_PTR(parseState) &lt;= JK_END_STRING_PTR(parseState)));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  const unsigned char *stringStart       = JK_AT_STRING_PTR(parseState) + 1;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  const unsigned char *endOfBuffer       = JK_END_STRING_PTR(parseState);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  const unsigned char *atStringCharacter = stringStart;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  unsigned char       *tokenBuffer       = parseState-&gt;token.tokenBuffer.bytes.ptr;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  size_t               tokenStartIndex   = parseState-&gt;atIndex;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  size_t               tokenBufferIdx    = 0UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  int      onlySimpleString        = 1,  stringState     = JSONStringStateStart;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  uint16_t escapedUnicode1         = 0U, escapedUnicode2 = 0U;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  uint32_t escapedUnicodeCodePoint = 0U;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  JKHash   stringHash              = JK_HASH_INIT;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>    </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  while(1) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    unsigned long currentChar;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if(JK_EXPECT_F(atStringCharacter == endOfBuffer)) { /* XXX Add error message */ stringState = JSONStringStateError; goto finishedParsing; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>    </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if(JK_EXPECT_F((currentChar = *atStringCharacter++) &gt;= 0x80UL)) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      const unsigned char *nextValidCharacter = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      UTF32                u32ch              = 0U;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      ConversionResult     result;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      if(JK_EXPECT_F((result = ConvertSingleCodePointInUTF8(atStringCharacter - 1, endOfBuffer, (UTF8 const **)&amp;nextValidCharacter, &amp;u32ch)) != conversionOK)) { goto switchToSlowPath; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      stringHash = calculateHash(stringHash, currentChar);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      while(atStringCharacter &lt; nextValidCharacter) { NSCParameterAssert(JK_AT_STRING_PTR(parseState) &lt;= JK_END_STRING_PTR(parseState)); stringHash = calculateHash(stringHash, *atStringCharacter++); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      continue;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>    } else {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      if(JK_EXPECT_F(currentChar == (unsigned long)&apos;&quot;&apos;)) { stringState = JSONStringStateFinished; goto finishedParsing; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      if(JK_EXPECT_F(currentChar == (unsigned long)&apos;\\&apos;)) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>      switchToSlowPath:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        onlySimpleString = 0;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        stringState      = JSONStringStateParsing;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        tokenBufferIdx   = (atStringCharacter - stringStart) - 1L;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        if(JK_EXPECT_F((tokenBufferIdx + 16UL) &gt; parseState-&gt;token.tokenBuffer.bytes.length)) { if((tokenBuffer = jk_managedBuffer_resize(&amp;parseState-&gt;token.tokenBuffer, tokenBufferIdx + 1024UL)) == NULL) { jk_error(parseState, @&quot;Internal error: Unable to resize temporary buffer. %@ line #%ld&quot;, [NSString stringWithUTF8String:__FILE__], (long)__LINE__); stringState = JSONStringStateError; goto finishedParsing; } }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        memcpy(tokenBuffer, stringStart, tokenBufferIdx);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        goto slowMatch;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>      }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      if(JK_EXPECT_F(currentChar &lt; 0x20UL)) { jk_error(parseState, @&quot;Invalid character &lt; 0x20 found in string: 0x%2.2x.&quot;, currentChar); stringState = JSONStringStateError; goto finishedParsing; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      stringHash = calculateHash(stringHash, currentChar);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>    }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> slowMatch:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  for(atStringCharacter = (stringStart + ((atStringCharacter - stringStart) - 1L)); (atStringCharacter &lt; endOfBuffer) &amp;&amp; (tokenBufferIdx &lt; parseState-&gt;token.tokenBuffer.bytes.length); atStringCharacter++) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if((tokenBufferIdx + 16UL) &gt; parseState-&gt;token.tokenBuffer.bytes.length) { if((tokenBuffer = jk_managedBuffer_resize(&amp;parseState-&gt;token.tokenBuffer, tokenBufferIdx + 1024UL)) == NULL) { jk_error(parseState, @&quot;Internal error: Unable to resize temporary buffer. %@ line #%ld&quot;, [NSString stringWithUTF8String:__FILE__], (long)__LINE__); stringState = JSONStringStateError; goto finishedParsing; } }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    NSCParameterAssert(tokenBufferIdx &lt; parseState-&gt;token.tokenBuffer.bytes.length);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    unsigned long currentChar = (*atStringCharacter), escapedChar;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if(JK_EXPECT_T(stringState == JSONStringStateParsing)) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      if(JK_EXPECT_T(currentChar &gt;= 0x20UL)) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        if(JK_EXPECT_T(currentChar &lt; (unsigned long)0x80)) { // Not a UTF8 sequence</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          if(JK_EXPECT_F(currentChar == (unsigned long)&apos;&quot;&apos;))  { stringState = JSONStringStateFinished; atStringCharacter++; goto finishedParsing; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          if(JK_EXPECT_F(currentChar == (unsigned long)&apos;\\&apos;)) { stringState = JSONStringStateEscape; continue; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          stringHash = calculateHash(stringHash, currentChar);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          tokenBuffer[tokenBufferIdx++] = currentChar;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          continue;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>        } else { // UTF8 sequence</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          const unsigned char *nextValidCharacter = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          UTF32                u32ch              = 0U;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          ConversionResult     result;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>          </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          if(JK_EXPECT_F((result = ConvertSingleCodePointInUTF8(atStringCharacter, endOfBuffer, (UTF8 const **)&amp;nextValidCharacter, &amp;u32ch)) != conversionOK)) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            if((result == sourceIllegal) &amp;&amp; ((parseState-&gt;parseOptionFlags &amp; JKParseOptionLooseUnicode) == 0)) { jk_error(parseState, @&quot;Illegal UTF8 sequence found in \&quot;\&quot; string.&quot;);              stringState = JSONStringStateError; goto finishedParsing; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            if(result == sourceExhausted)                                                                      { jk_error(parseState, @&quot;End of buffer reached while parsing UTF8 in \&quot;\&quot; string.&quot;); stringState = JSONStringStateError; goto finishedParsing; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            if(jk_string_add_unicodeCodePoint(parseState, u32ch, &amp;tokenBufferIdx, &amp;stringHash))                { jk_error(parseState, @&quot;Internal error: Unable to add UTF8 sequence to internal string buffer. %@ line #%ld&quot;, [NSString stringWithUTF8String:__FILE__], (long)__LINE__); stringState = JSONStringStateError; goto finishedParsing; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            atStringCharacter = nextValidCharacter - 1;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            continue;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>          } else {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            while(atStringCharacter &lt; nextValidCharacter) { tokenBuffer[tokenBufferIdx++] = *atStringCharacter; stringHash = calculateHash(stringHash, *atStringCharacter++); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            atStringCharacter--;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            continue;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>          }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>        }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>      } else { // currentChar &lt; 0x20</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        jk_error(parseState, @&quot;Invalid character &lt; 0x20 found in string: 0x%2.2x.&quot;, currentChar); stringState = JSONStringStateError; goto finishedParsing;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>      }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>    } else { // stringState != JSONStringStateParsing</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      int isSurrogate = 1;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      switch(stringState) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>        case JSONStringStateEscape:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          switch(currentChar) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            case &apos;u&apos;: escapedUnicode1 = 0U; escapedUnicode2 = 0U; escapedUnicodeCodePoint = 0U; stringState = JSONStringStateEscapedUnicode1; break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            case &apos;b&apos;:  escapedChar = &apos;\b&apos;; goto parsedEscapedChar;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            case &apos;f&apos;:  escapedChar = &apos;\f&apos;; goto parsedEscapedChar;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            case &apos;n&apos;:  escapedChar = &apos;\n&apos;; goto parsedEscapedChar;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            case &apos;r&apos;:  escapedChar = &apos;\r&apos;; goto parsedEscapedChar;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            case &apos;t&apos;:  escapedChar = &apos;\t&apos;; goto parsedEscapedChar;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            case &apos;\\&apos;: escapedChar = &apos;\\&apos;; goto parsedEscapedChar;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            case &apos;/&apos;:  escapedChar = &apos;/&apos;;  goto parsedEscapedChar;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            case &apos;&quot;&apos;:  escapedChar = &apos;&quot;&apos;;  goto parsedEscapedChar;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>              </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>            parsedEscapedChar:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>              stringState = JSONStringStateParsing;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>              stringHash  = calculateHash(stringHash, escapedChar);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>              tokenBuffer[tokenBufferIdx++] = escapedChar;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>              break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>              </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            default: jk_error(parseState, @&quot;Invalid escape sequence found in \&quot;\&quot; string.&quot;); stringState = JSONStringStateError; goto finishedParsing; break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>          }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>        case JSONStringStateEscapedUnicode1:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>        case JSONStringStateEscapedUnicode2:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>        case JSONStringStateEscapedUnicode3:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        case JSONStringStateEscapedUnicode4:           isSurrogate = 0;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>        case JSONStringStateEscapedUnicodeSurrogate1:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>        case JSONStringStateEscapedUnicodeSurrogate2:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>        case JSONStringStateEscapedUnicodeSurrogate3:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>        case JSONStringStateEscapedUnicodeSurrogate4:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>          {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            uint16_t hexValue = 0U;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            switch(currentChar) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>              case &apos;0&apos; ... &apos;9&apos;: hexValue =  currentChar - &apos;0&apos;;        goto parsedHex;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>              case &apos;a&apos; ... &apos;f&apos;: hexValue = (currentChar - &apos;a&apos;) + 10U; goto parsedHex;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>              case &apos;A&apos; ... &apos;F&apos;: hexValue = (currentChar - &apos;A&apos;) + 10U; goto parsedHex;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>                </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>              parsedHex:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>              if(!isSurrogate) { escapedUnicode1 = (escapedUnicode1 &lt;&lt; 4) | hexValue; } else { escapedUnicode2 = (escapedUnicode2 &lt;&lt; 4) | hexValue; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>                </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>              if(stringState == JSONStringStateEscapedUnicode4) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>                if(((escapedUnicode1 &gt;= 0xD800U) &amp;&amp; (escapedUnicode1 &lt; 0xE000U))) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>                  if((escapedUnicode1 &gt;= 0xD800U) &amp;&amp; (escapedUnicode1 &lt; 0xDC00U)) { stringState = JSONStringStateEscapedNeedEscapeForSurrogate; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>                  else if((escapedUnicode1 &gt;= 0xDC00U) &amp;&amp; (escapedUnicode1 &lt; 0xE000U)) { </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>                    if((parseState-&gt;parseOptionFlags &amp; JKParseOptionLooseUnicode)) { escapedUnicodeCodePoint = UNI_REPLACEMENT_CHAR; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>                    else { jk_error(parseState, @&quot;Illegal \\u Unicode escape sequence.&quot;); stringState = JSONStringStateError; goto finishedParsing; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>                  }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>                }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>                else { escapedUnicodeCodePoint = escapedUnicode1; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>              }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>              if(stringState == JSONStringStateEscapedUnicodeSurrogate4) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>                if((escapedUnicode2 &lt; 0xdc00) || (escapedUnicode2 &gt; 0xdfff)) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>                  if((parseState-&gt;parseOptionFlags &amp; JKParseOptionLooseUnicode)) { escapedUnicodeCodePoint = UNI_REPLACEMENT_CHAR; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>                  else { jk_error(parseState, @&quot;Illegal \\u Unicode escape sequence.&quot;); stringState = JSONStringStateError; goto finishedParsing; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>                }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>                else { escapedUnicodeCodePoint = ((escapedUnicode1 - 0xd800) * 0x400) + (escapedUnicode2 - 0xdc00) + 0x10000; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>              }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>                </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>              if((stringState == JSONStringStateEscapedUnicode4) || (stringState == JSONStringStateEscapedUnicodeSurrogate4)) { </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>                if((isValidCodePoint(&amp;escapedUnicodeCodePoint) == sourceIllegal) &amp;&amp; ((parseState-&gt;parseOptionFlags &amp; JKParseOptionLooseUnicode) == 0)) { jk_error(parseState, @&quot;Illegal \\u Unicode escape sequence.&quot;); stringState = JSONStringStateError; goto finishedParsing; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>                stringState = JSONStringStateParsing;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>                if(jk_string_add_unicodeCodePoint(parseState, escapedUnicodeCodePoint, &amp;tokenBufferIdx, &amp;stringHash)) { jk_error(parseState, @&quot;Internal error: Unable to add UTF8 sequence to internal string buffer. %@ line #%ld&quot;, [NSString stringWithUTF8String:__FILE__], (long)__LINE__); stringState = JSONStringStateError; goto finishedParsing; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>              }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>              else if((stringState &gt;= JSONStringStateEscapedUnicode1) &amp;&amp; (stringState &lt;= JSONStringStateEscapedUnicodeSurrogate4)) { stringState++; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>              break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>              default: jk_error(parseState, @&quot;Unexpected character found in \\u Unicode escape sequence.  Found &apos;%c&apos;, expected [0-9a-fA-F].&quot;, currentChar); stringState = JSONStringStateError; goto finishedParsing; break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>            }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>          }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>        case JSONStringStateEscapedNeedEscapeForSurrogate:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          if(currentChar == &apos;\\&apos;) { stringState = JSONStringStateEscapedNeedEscapedUForSurrogate; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>          else { </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            if((parseState-&gt;parseOptionFlags &amp; JKParseOptionLooseUnicode) == 0) { jk_error(parseState, @&quot;Required a second \\u Unicode escape sequence following a surrogate \\u Unicode escape sequence.&quot;); stringState = JSONStringStateError; goto finishedParsing; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            else { stringState = JSONStringStateParsing; atStringCharacter--;    if(jk_string_add_unicodeCodePoint(parseState, UNI_REPLACEMENT_CHAR, &amp;tokenBufferIdx, &amp;stringHash)) { jk_error(parseState, @&quot;Internal error: Unable to add UTF8 sequence to internal string buffer. %@ line #%ld&quot;, [NSString stringWithUTF8String:__FILE__], (long)__LINE__); stringState = JSONStringStateError; goto finishedParsing; } }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>          }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>        case JSONStringStateEscapedNeedEscapedUForSurrogate:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          if(currentChar == &apos;u&apos;) { stringState = JSONStringStateEscapedUnicodeSurrogate1; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>          else { </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            if((parseState-&gt;parseOptionFlags &amp; JKParseOptionLooseUnicode) == 0) { jk_error(parseState, @&quot;Required a second \\u Unicode escape sequence following a surrogate \\u Unicode escape sequence.&quot;); stringState = JSONStringStateError; goto finishedParsing; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            else { stringState = JSONStringStateParsing; atStringCharacter -= 2; if(jk_string_add_unicodeCodePoint(parseState, UNI_REPLACEMENT_CHAR, &amp;tokenBufferIdx, &amp;stringHash)) { jk_error(parseState, @&quot;Internal error: Unable to add UTF8 sequence to internal string buffer. %@ line #%ld&quot;, [NSString stringWithUTF8String:__FILE__], (long)__LINE__); stringState = JSONStringStateError; goto finishedParsing; } }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>          }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        default: jk_error(parseState, @&quot;Internal error: Unknown stringState. %@ line #%ld&quot;, [NSString stringWithUTF8String:__FILE__], (long)__LINE__); stringState = JSONStringStateError; goto finishedParsing; break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>      }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>    }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>finishedParsing:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(JK_EXPECT_T(stringState == JSONStringStateFinished)) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    NSCParameterAssert((parseState-&gt;stringBuffer.bytes.ptr + tokenStartIndex) &lt; atStringCharacter);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    parseState-&gt;token.tokenPtrRange.ptr    = parseState-&gt;stringBuffer.bytes.ptr + tokenStartIndex;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    parseState-&gt;token.tokenPtrRange.length = (atStringCharacter - parseState-&gt;token.tokenPtrRange.ptr);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if(JK_EXPECT_T(onlySimpleString)) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      NSCParameterAssert(((parseState-&gt;token.tokenPtrRange.ptr + 1) &lt; endOfBuffer) &amp;&amp; (parseState-&gt;token.tokenPtrRange.length &gt;= 2UL) &amp;&amp; (((parseState-&gt;token.tokenPtrRange.ptr + 1) + (parseState-&gt;token.tokenPtrRange.length - 2)) &lt; endOfBuffer));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      parseState-&gt;token.value.ptrRange.ptr    = parseState-&gt;token.tokenPtrRange.ptr    + 1;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      parseState-&gt;token.value.ptrRange.length = parseState-&gt;token.tokenPtrRange.length - 2UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    } else {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      parseState-&gt;token.value.ptrRange.ptr    = parseState-&gt;token.tokenBuffer.bytes.ptr;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      parseState-&gt;token.value.ptrRange.length = tokenBufferIdx;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>    }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>    </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    parseState-&gt;token.value.hash = stringHash;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    parseState-&gt;token.value.type = JKValueTypeString;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    parseState-&gt;atIndex          = (atStringCharacter - parseState-&gt;stringBuffer.bytes.ptr);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(JK_EXPECT_F(stringState != JSONStringStateFinished)) { jk_error(parseState, @&quot;Invalid string.&quot;); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return(JK_EXPECT_T(stringState == JSONStringStateFinished) ? 0 : 1);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>static int jk_parse_number(JKParseState *parseState) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSCParameterAssert((parseState != NULL) &amp;&amp; (JK_AT_STRING_PTR(parseState) &lt;= JK_END_STRING_PTR(parseState)));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  const unsigned char *numberStart       = JK_AT_STRING_PTR(parseState);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  const unsigned char *endOfBuffer       = JK_END_STRING_PTR(parseState);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  const unsigned char *atNumberCharacter = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  int                  numberState       = JSONNumberStateWholeNumberStart, isFloatingPoint = 0, isNegative = 0, backup = 0;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  size_t               startingIndex     = parseState-&gt;atIndex;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  for(atNumberCharacter = numberStart; (JK_EXPECT_T(atNumberCharacter &lt; endOfBuffer)) &amp;&amp; (JK_EXPECT_T(!(JK_EXPECT_F(numberState == JSONNumberStateFinished) || JK_EXPECT_F(numberState == JSONNumberStateError)))); atNumberCharacter++) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    unsigned long currentChar = (unsigned long)(*atNumberCharacter), lowerCaseCC = currentChar | 0x20UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>    </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    switch(numberState) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      case JSONNumberStateWholeNumberStart: if   (currentChar == &apos;-&apos;)                                                                              { numberState = JSONNumberStateWholeNumberMinus;      isNegative      = 1; break; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      case JSONNumberStateWholeNumberMinus: if   (currentChar == &apos;0&apos;)                                                                              { numberState = JSONNumberStateWholeNumberZero;                            break; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>                                       else if(  (currentChar &gt;= &apos;1&apos;) &amp;&amp; (currentChar &lt;= &apos;9&apos;))                                                     { numberState = JSONNumberStateWholeNumber;                                break; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>                                       else                                                     { /* XXX Add error message */                        numberState = JSONNumberStateError;                                      break; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      case JSONNumberStateExponentStart:    if(  (currentChar == &apos;+&apos;) || (currentChar == &apos;-&apos;))                                                     { numberState = JSONNumberStateExponentPlusMinus;                          break; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>      case JSONNumberStateFractionalNumberStart:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      case JSONNumberStateExponentPlusMinus:if(!((currentChar &gt;= &apos;0&apos;) &amp;&amp; (currentChar &lt;= &apos;9&apos;))) { /* XXX Add error message */                        numberState = JSONNumberStateError;                                      break; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>                                       else {                                              if(numberState == JSONNumberStateFractionalNumberStart) { numberState = JSONNumberStateFractionalNumber; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>                                                                                           else                                                    { numberState = JSONNumberStateExponent;         }                         break; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>      case JSONNumberStateWholeNumberZero:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      case JSONNumberStateWholeNumber:      if   (currentChar == &apos;.&apos;)                                                                              { numberState = JSONNumberStateFractionalNumberStart; isFloatingPoint = 1; break; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      case JSONNumberStateFractionalNumber: if   (lowerCaseCC == &apos;e&apos;)                                                                              { numberState = JSONNumberStateExponentStart;         isFloatingPoint = 1; break; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      case JSONNumberStateExponent:         if(!((currentChar &gt;= &apos;0&apos;) &amp;&amp; (currentChar &lt;= &apos;9&apos;)) || (numberState == JSONNumberStateWholeNumberZero)) { numberState = JSONNumberStateFinished;              backup          = 1; break; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      default:                                                                                    /* XXX Add error message */                        numberState = JSONNumberStateError;                                      break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>    }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  parseState-&gt;token.tokenPtrRange.ptr    = parseState-&gt;stringBuffer.bytes.ptr + startingIndex;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  parseState-&gt;token.tokenPtrRange.length = (atNumberCharacter - parseState-&gt;token.tokenPtrRange.ptr) - backup;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  parseState-&gt;atIndex                    = (parseState-&gt;token.tokenPtrRange.ptr + parseState-&gt;token.tokenPtrRange.length) - parseState-&gt;stringBuffer.bytes.ptr;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(JK_EXPECT_T(numberState == JSONNumberStateFinished)) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    unsigned char  numberTempBuf[parseState-&gt;token.tokenPtrRange.length + 4UL];</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    unsigned char *endOfNumber = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    memcpy(numberTempBuf, parseState-&gt;token.tokenPtrRange.ptr, parseState-&gt;token.tokenPtrRange.length);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    numberTempBuf[parseState-&gt;token.tokenPtrRange.length] = 0;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    errno = 0;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>    </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>    // Treat &quot;-0&quot; as a floating point number, which is capable of representing negative zeros.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if(JK_EXPECT_F(parseState-&gt;token.tokenPtrRange.length == 2UL) &amp;&amp; JK_EXPECT_F(numberTempBuf[1] == &apos;0&apos;) &amp;&amp; JK_EXPECT_F(isNegative)) { isFloatingPoint = 1; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if(isFloatingPoint) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      parseState-&gt;token.value.number.doubleValue = strtod((const char *)numberTempBuf, (char **)&amp;endOfNumber); // strtod is documented to return U+2261 (identical to) 0.0 on an underflow error (along with setting errno to ERANGE).</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      parseState-&gt;token.value.type               = JKValueTypeDouble;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      parseState-&gt;token.value.ptrRange.ptr       = (const unsigned char *)&amp;parseState-&gt;token.value.number.doubleValue;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      parseState-&gt;token.value.ptrRange.length    = sizeof(double);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      parseState-&gt;token.value.hash               = (JK_HASH_INIT + parseState-&gt;token.value.type);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    } else {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      if(isNegative) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        parseState-&gt;token.value.number.longLongValue = strtoll((const char *)numberTempBuf, (char **)&amp;endOfNumber, 10);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        parseState-&gt;token.value.type                 = JKValueTypeLongLong;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        parseState-&gt;token.value.ptrRange.ptr         = (const unsigned char *)&amp;parseState-&gt;token.value.number.longLongValue;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        parseState-&gt;token.value.ptrRange.length      = sizeof(long long);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        parseState-&gt;token.value.hash                 = (JK_HASH_INIT + parseState-&gt;token.value.type) + (JKHash)parseState-&gt;token.value.number.longLongValue;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      } else {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        parseState-&gt;token.value.number.unsignedLongLongValue = strtoull((const char *)numberTempBuf, (char **)&amp;endOfNumber, 10);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        parseState-&gt;token.value.type                         = JKValueTypeUnsignedLongLong;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        parseState-&gt;token.value.ptrRange.ptr                 = (const unsigned char *)&amp;parseState-&gt;token.value.number.unsignedLongLongValue;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        parseState-&gt;token.value.ptrRange.length              = sizeof(unsigned long long);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        parseState-&gt;token.value.hash                         = (JK_HASH_INIT + parseState-&gt;token.value.type) + (JKHash)parseState-&gt;token.value.number.unsignedLongLongValue;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>      }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>    }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if(JK_EXPECT_F(errno != 0)) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      numberState = JSONNumberStateError;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      if(errno == ERANGE) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        switch(parseState-&gt;token.value.type) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          case JKValueTypeDouble:           jk_error(parseState, @&quot;The value &apos;%s&apos; could not be represented as a &apos;double&apos; due to %s.&quot;,           numberTempBuf, (parseState-&gt;token.value.number.doubleValue == 0.0) ? &quot;underflow&quot; : &quot;overflow&quot;); break; // see above for == 0.0.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          case JKValueTypeLongLong:         jk_error(parseState, @&quot;The value &apos;%s&apos; exceeded the minimum value that could be represented: %lld.&quot;, numberTempBuf, parseState-&gt;token.value.number.longLongValue);                                   break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          case JKValueTypeUnsignedLongLong: jk_error(parseState, @&quot;The value &apos;%s&apos; exceeded the maximum value that could be represented: %llu.&quot;, numberTempBuf, parseState-&gt;token.value.number.unsignedLongLongValue);                           break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          default:                          jk_error(parseState, @&quot;Internal error: Unknown token value type. %@ line #%ld&quot;,                     [NSString stringWithUTF8String:__FILE__], (long)__LINE__);                                      break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>        }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if(JK_EXPECT_F(endOfNumber != &amp;numberTempBuf[parseState-&gt;token.tokenPtrRange.length]) &amp;&amp; JK_EXPECT_F(numberState != JSONNumberStateError)) { numberState = JSONNumberStateError; jk_error(parseState, @&quot;The conversion function did not consume all of the number tokens characters.&quot;); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    size_t hashIndex = 0UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    for(hashIndex = 0UL; hashIndex &lt; parseState-&gt;token.value.ptrRange.length; hashIndex++) { parseState-&gt;token.value.hash = calculateHash(parseState-&gt;token.value.hash, parseState-&gt;token.value.ptrRange.ptr[hashIndex]); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(JK_EXPECT_F(numberState != JSONNumberStateFinished)) { jk_error(parseState, @&quot;Invalid number.&quot;); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return(JK_EXPECT_T((numberState == JSONNumberStateFinished)) ? 0 : 1);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>JK_STATIC_INLINE void jk_set_parsed_token(JKParseState *parseState, const unsigned char *ptr, size_t length, JKTokenType type, size_t advanceBy) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  parseState-&gt;token.tokenPtrRange.ptr     = ptr;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  parseState-&gt;token.tokenPtrRange.length  = length;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  parseState-&gt;token.type                  = type;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  parseState-&gt;atIndex                    += advanceBy;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>static size_t jk_parse_is_newline(JKParseState *parseState, const unsigned char *atCharacterPtr) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSCParameterAssert((parseState != NULL) &amp;&amp; (atCharacterPtr != NULL) &amp;&amp; (atCharacterPtr &gt;= parseState-&gt;stringBuffer.bytes.ptr) &amp;&amp; (atCharacterPtr &lt; JK_END_STRING_PTR(parseState)));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  const unsigned char *endOfStringPtr = JK_END_STRING_PTR(parseState);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(JK_EXPECT_F(atCharacterPtr &gt;= endOfStringPtr)) { return(0UL); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(JK_EXPECT_F((*(atCharacterPtr + 0)) == &apos;\n&apos;)) { return(1UL); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(JK_EXPECT_F((*(atCharacterPtr + 0)) == &apos;\r&apos;)) { if((JK_EXPECT_T((atCharacterPtr + 1) &lt; endOfStringPtr)) &amp;&amp; ((*(atCharacterPtr + 1)) == &apos;\n&apos;)) { return(2UL); } return(1UL); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(parseState-&gt;parseOptionFlags &amp; JKParseOptionUnicodeNewlines) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if((JK_EXPECT_F((*(atCharacterPtr + 0)) == 0xc2)) &amp;&amp; (((atCharacterPtr + 1) &lt; endOfStringPtr) &amp;&amp; ((*(atCharacterPtr + 1)) == 0x85))) { return(2UL); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if((JK_EXPECT_F((*(atCharacterPtr + 0)) == 0xe2)) &amp;&amp; (((atCharacterPtr + 2) &lt; endOfStringPtr) &amp;&amp; ((*(atCharacterPtr + 1)) == 0x80) &amp;&amp; (((*(atCharacterPtr + 2)) == 0xa8) || ((*(atCharacterPtr + 2)) == 0xa9)))) { return(3UL); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return(0UL);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>JK_STATIC_INLINE int jk_parse_skip_newline(JKParseState *parseState) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  size_t newlineAdvanceAtIndex = 0UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(JK_EXPECT_F((newlineAdvanceAtIndex = jk_parse_is_newline(parseState, JK_AT_STRING_PTR(parseState))) &gt; 0UL)) { parseState-&gt;lineNumber++; parseState-&gt;atIndex += (newlineAdvanceAtIndex - 1UL); parseState-&gt;lineStartIndex = parseState-&gt;atIndex + 1UL; return(1); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return(0);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>JK_STATIC_INLINE void jk_parse_skip_whitespace(JKParseState *parseState) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#ifndef __clang_analyzer__</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSCParameterAssert((parseState != NULL) &amp;&amp; (JK_AT_STRING_PTR(parseState) &lt;= JK_END_STRING_PTR(parseState)));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  const unsigned char *atCharacterPtr   = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  const unsigned char *endOfStringPtr   = JK_END_STRING_PTR(parseState);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  for(atCharacterPtr = JK_AT_STRING_PTR(parseState); (JK_EXPECT_T((atCharacterPtr = JK_AT_STRING_PTR(parseState)) &lt; endOfStringPtr)); parseState-&gt;atIndex++) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if(((*(atCharacterPtr + 0)) == &apos; &apos;) || ((*(atCharacterPtr + 0)) == &apos;\t&apos;)) { continue; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if(jk_parse_skip_newline(parseState)) { continue; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if(parseState-&gt;parseOptionFlags &amp; JKParseOptionComments) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      if((JK_EXPECT_F((*(atCharacterPtr + 0)) == &apos;/&apos;)) &amp;&amp; (JK_EXPECT_T((atCharacterPtr + 1) &lt; endOfStringPtr))) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        if((*(atCharacterPtr + 1)) == &apos;/&apos;) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          parseState-&gt;atIndex++;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          for(atCharacterPtr = JK_AT_STRING_PTR(parseState); (JK_EXPECT_T((atCharacterPtr = JK_AT_STRING_PTR(parseState)) &lt; endOfStringPtr)); parseState-&gt;atIndex++) { if(jk_parse_skip_newline(parseState)) { break; } }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          continue;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>        }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        if((*(atCharacterPtr + 1)) == &apos;*&apos;) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          parseState-&gt;atIndex++;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          for(atCharacterPtr = JK_AT_STRING_PTR(parseState); (JK_EXPECT_T((atCharacterPtr = JK_AT_STRING_PTR(parseState)) &lt; endOfStringPtr)); parseState-&gt;atIndex++) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            if(jk_parse_skip_newline(parseState)) { continue; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            if(((*(atCharacterPtr + 0)) == &apos;*&apos;) &amp;&amp; (((atCharacterPtr + 1) &lt; endOfStringPtr) &amp;&amp; ((*(atCharacterPtr + 1)) == &apos;/&apos;))) { parseState-&gt;atIndex++; break; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          continue;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>        }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#endif</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>static int jk_parse_next_token(JKParseState *parseState) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSCParameterAssert((parseState != NULL) &amp;&amp; (JK_AT_STRING_PTR(parseState) &lt;= JK_END_STRING_PTR(parseState)));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  const unsigned char *atCharacterPtr   = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  const unsigned char *endOfStringPtr   = JK_END_STRING_PTR(parseState);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  unsigned char        currentCharacter = 0U;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  int                  stopParsing      = 0;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  parseState-&gt;prev_atIndex        = parseState-&gt;atIndex;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  parseState-&gt;prev_lineNumber     = parseState-&gt;lineNumber;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  parseState-&gt;prev_lineStartIndex = parseState-&gt;lineStartIndex;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  jk_parse_skip_whitespace(parseState);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if((JK_AT_STRING_PTR(parseState) == endOfStringPtr)) { stopParsing = 1; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if((JK_EXPECT_T(stopParsing == 0)) &amp;&amp; (JK_EXPECT_T((atCharacterPtr = JK_AT_STRING_PTR(parseState)) &lt; endOfStringPtr))) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    currentCharacter = *atCharacterPtr;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>         if(JK_EXPECT_T(currentCharacter == &apos;&quot;&apos;)) { if(JK_EXPECT_T((stopParsing = jk_parse_string(parseState)) == 0)) { jk_set_parsed_token(parseState, parseState-&gt;token.tokenPtrRange.ptr, parseState-&gt;token.tokenPtrRange.length, JKTokenTypeString, 0UL); } }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    else if(JK_EXPECT_T(currentCharacter == &apos;:&apos;)) { jk_set_parsed_token(parseState, atCharacterPtr, 1UL, JKTokenTypeSeparator,   1UL); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    else if(JK_EXPECT_T(currentCharacter == &apos;,&apos;)) { jk_set_parsed_token(parseState, atCharacterPtr, 1UL, JKTokenTypeComma,       1UL); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    else if((JK_EXPECT_T(currentCharacter &gt;= &apos;0&apos;) &amp;&amp; JK_EXPECT_T(currentCharacter &lt;= &apos;9&apos;)) || JK_EXPECT_T(currentCharacter == &apos;-&apos;)) { if(JK_EXPECT_T((stopParsing = jk_parse_number(parseState)) == 0)) { jk_set_parsed_token(parseState, parseState-&gt;token.tokenPtrRange.ptr, parseState-&gt;token.tokenPtrRange.length, JKTokenTypeNumber, 0UL); } }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    else if(JK_EXPECT_T(currentCharacter == &apos;{&apos;)) { jk_set_parsed_token(parseState, atCharacterPtr, 1UL, JKTokenTypeObjectBegin, 1UL); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    else if(JK_EXPECT_T(currentCharacter == &apos;}&apos;)) { jk_set_parsed_token(parseState, atCharacterPtr, 1UL, JKTokenTypeObjectEnd,   1UL); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    else if(JK_EXPECT_T(currentCharacter == &apos;[&apos;)) { jk_set_parsed_token(parseState, atCharacterPtr, 1UL, JKTokenTypeArrayBegin,  1UL); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    else if(JK_EXPECT_T(currentCharacter == &apos;]&apos;)) { jk_set_parsed_token(parseState, atCharacterPtr, 1UL, JKTokenTypeArrayEnd,    1UL); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>    </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    else if(JK_EXPECT_T(currentCharacter == &apos;t&apos;)) { if(!((JK_EXPECT_T((atCharacterPtr + 4UL) &lt; endOfStringPtr)) &amp;&amp; (JK_EXPECT_T(atCharacterPtr[1] == &apos;r&apos;)) &amp;&amp; (JK_EXPECT_T(atCharacterPtr[2] == &apos;u&apos;)) &amp;&amp; (JK_EXPECT_T(atCharacterPtr[3] == &apos;e&apos;))))                                            { stopParsing = 1; /* XXX Add error message */ } else { jk_set_parsed_token(parseState, atCharacterPtr, 4UL, JKTokenTypeTrue,  4UL); } }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    else if(JK_EXPECT_T(currentCharacter == &apos;f&apos;)) { if(!((JK_EXPECT_T((atCharacterPtr + 5UL) &lt; endOfStringPtr)) &amp;&amp; (JK_EXPECT_T(atCharacterPtr[1] == &apos;a&apos;)) &amp;&amp; (JK_EXPECT_T(atCharacterPtr[2] == &apos;l&apos;)) &amp;&amp; (JK_EXPECT_T(atCharacterPtr[3] == &apos;s&apos;)) &amp;&amp; (JK_EXPECT_T(atCharacterPtr[4] == &apos;e&apos;)))) { stopParsing = 1; /* XXX Add error message */ } else { jk_set_parsed_token(parseState, atCharacterPtr, 5UL, JKTokenTypeFalse, 5UL); } }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    else if(JK_EXPECT_T(currentCharacter == &apos;n&apos;)) { if(!((JK_EXPECT_T((atCharacterPtr + 4UL) &lt; endOfStringPtr)) &amp;&amp; (JK_EXPECT_T(atCharacterPtr[1] == &apos;u&apos;)) &amp;&amp; (JK_EXPECT_T(atCharacterPtr[2] == &apos;l&apos;)) &amp;&amp; (JK_EXPECT_T(atCharacterPtr[3] == &apos;l&apos;))))                                            { stopParsing = 1; /* XXX Add error message */ } else { jk_set_parsed_token(parseState, atCharacterPtr, 4UL, JKTokenTypeNull,  4UL); } }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    else { stopParsing = 1; /* XXX Add error message */ }    </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(JK_EXPECT_F(stopParsing)) { jk_error(parseState, @&quot;Unexpected token, wanted &apos;{&apos;, &apos;}&apos;, &apos;[&apos;, &apos;]&apos;, &apos;,&apos;, &apos;:&apos;, &apos;true&apos;, &apos;false&apos;, &apos;null&apos;, &apos;\&quot;STRING\&quot;&apos;, &apos;NUMBER&apos;.&quot;); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return(stopParsing);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>static void jk_error_parse_accept_or3(JKParseState *parseState, int state, NSString *or1String, NSString *or2String, NSString *or3String) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSString *acceptStrings[16];</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  int acceptIdx = 0;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(state &amp; JKParseAcceptValue) { acceptStrings[acceptIdx++] = or1String; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(state &amp; JKParseAcceptComma) { acceptStrings[acceptIdx++] = or2String; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(state &amp; JKParseAcceptEnd)   { acceptStrings[acceptIdx++] = or3String; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>       if(acceptIdx == 1) { jk_error(parseState, @&quot;Expected %@, not &apos;%*.*s&apos;&quot;,           acceptStrings[0],                                     (int)parseState-&gt;token.tokenPtrRange.length, (int)parseState-&gt;token.tokenPtrRange.length, parseState-&gt;token.tokenPtrRange.ptr); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  else if(acceptIdx == 2) { jk_error(parseState, @&quot;Expected %@ or %@, not &apos;%*.*s&apos;&quot;,     acceptStrings[0], acceptStrings[1],                   (int)parseState-&gt;token.tokenPtrRange.length, (int)parseState-&gt;token.tokenPtrRange.length, parseState-&gt;token.tokenPtrRange.ptr); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  else if(acceptIdx == 3) { jk_error(parseState, @&quot;Expected %@, %@, or %@, not &apos;%*.*s&quot;, acceptStrings[0], acceptStrings[1], acceptStrings[2], (int)parseState-&gt;token.tokenPtrRange.length, (int)parseState-&gt;token.tokenPtrRange.length, parseState-&gt;token.tokenPtrRange.ptr); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>static void *jk_parse_array(JKParseState *parseState) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  size_t  startingObjectIndex = parseState-&gt;objectStack.index;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  int     arrayState          = JKParseAcceptValueOrEnd, stopParsing = 0;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  void   *parsedArray         = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  while(JK_EXPECT_T((JK_EXPECT_T(stopParsing == 0)) &amp;&amp; (JK_EXPECT_T(parseState-&gt;atIndex &lt; parseState-&gt;stringBuffer.bytes.length)))) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if(JK_EXPECT_F(parseState-&gt;objectStack.index &gt; (parseState-&gt;objectStack.count - 4UL))) { if(jk_objectStack_resize(&amp;parseState-&gt;objectStack, parseState-&gt;objectStack.count + 128UL)) { jk_error(parseState, @&quot;Internal error: [array] objectsIndex &gt; %zu, resize failed? %@ line %#ld&quot;, (parseState-&gt;objectStack.count - 4UL), [NSString stringWithUTF8String:__FILE__], (long)__LINE__); break; } }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if(JK_EXPECT_T((stopParsing = jk_parse_next_token(parseState)) == 0)) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      void *object = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#ifndef NS_BLOCK_ASSERTIONS</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      parseState-&gt;objectStack.objects[parseState-&gt;objectStack.index] = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      parseState-&gt;objectStack.keys   [parseState-&gt;objectStack.index] = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#endif</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      switch(parseState-&gt;token.type) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>        case JKTokenTypeNumber:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>        case JKTokenTypeString:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>        case JKTokenTypeTrue:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>        case JKTokenTypeFalse:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>        case JKTokenTypeNull:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>        case JKTokenTypeArrayBegin:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>        case JKTokenTypeObjectBegin:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          if(JK_EXPECT_F((arrayState &amp; JKParseAcceptValue)          == 0))    { parseState-&gt;errorIsPrev = 1; jk_error(parseState, @&quot;Unexpected value.&quot;);              stopParsing = 1; break; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          if(JK_EXPECT_F((object = jk_object_for_token(parseState)) == NULL)) {                              jk_error(parseState, @&quot;Internal error: Object == NULL&quot;); stopParsing = 1; break; } else { parseState-&gt;objectStack.objects[parseState-&gt;objectStack.index++] = object; arrayState = JKParseAcceptCommaOrEnd; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        case JKTokenTypeArrayEnd: if(JK_EXPECT_T(arrayState &amp; JKParseAcceptEnd)) { NSCParameterAssert(parseState-&gt;objectStack.index &gt;= startingObjectIndex); parsedArray = (void *)_JKArrayCreate((id *)&amp;parseState-&gt;objectStack.objects[startingObjectIndex], (parseState-&gt;objectStack.index - startingObjectIndex), parseState-&gt;mutableCollections); } else { parseState-&gt;errorIsPrev = 1; jk_error(parseState, @&quot;Unexpected &apos;]&apos;.&quot;); } stopParsing = 1; break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        case JKTokenTypeComma:    if(JK_EXPECT_T(arrayState &amp; JKParseAcceptComma)) { arrayState = JKParseAcceptValue; } else { parseState-&gt;errorIsPrev = 1; jk_error(parseState, @&quot;Unexpected &apos;,&apos;.&quot;); stopParsing = 1; } break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        default: parseState-&gt;errorIsPrev = 1; jk_error_parse_accept_or3(parseState, arrayState, @&quot;a value&quot;, @&quot;a comma&quot;, @&quot;a &apos;]&apos;&quot;); stopParsing = 1; break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>      }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(JK_EXPECT_F(parsedArray == NULL)) { size_t idx = 0UL; for(idx = startingObjectIndex; idx &lt; parseState-&gt;objectStack.index; idx++) { if(parseState-&gt;objectStack.objects[idx] != NULL) { CFRelease(parseState-&gt;objectStack.objects[idx]); parseState-&gt;objectStack.objects[idx] = NULL; } } }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#if !defined(NS_BLOCK_ASSERTIONS)</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  else { size_t idx = 0UL; for(idx = startingObjectIndex; idx &lt; parseState-&gt;objectStack.index; idx++) { parseState-&gt;objectStack.objects[idx] = NULL; parseState-&gt;objectStack.keys[idx] = NULL; } }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#endif</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  parseState-&gt;objectStack.index = startingObjectIndex;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return(parsedArray);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>static void *jk_create_dictionary(JKParseState *parseState, size_t startingObjectIndex) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  void *parsedDictionary = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  parseState-&gt;objectStack.index--;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  parsedDictionary = _JKDictionaryCreate((id *)&amp;parseState-&gt;objectStack.keys[startingObjectIndex], (NSUInteger *)&amp;parseState-&gt;objectStack.cfHashes[startingObjectIndex], (id *)&amp;parseState-&gt;objectStack.objects[startingObjectIndex], (parseState-&gt;objectStack.index - startingObjectIndex), parseState-&gt;mutableCollections);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return(parsedDictionary);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>static void *jk_parse_dictionary(JKParseState *parseState) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  size_t  startingObjectIndex = parseState-&gt;objectStack.index;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  int     dictState           = JKParseAcceptValueOrEnd, stopParsing = 0;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  void   *parsedDictionary    = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  while(JK_EXPECT_T((JK_EXPECT_T(stopParsing == 0)) &amp;&amp; (JK_EXPECT_T(parseState-&gt;atIndex &lt; parseState-&gt;stringBuffer.bytes.length)))) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if(JK_EXPECT_F(parseState-&gt;objectStack.index &gt; (parseState-&gt;objectStack.count - 4UL))) { if(jk_objectStack_resize(&amp;parseState-&gt;objectStack, parseState-&gt;objectStack.count + 128UL)) { jk_error(parseState, @&quot;Internal error: [dictionary] objectsIndex &gt; %zu, resize failed? %@ line #%ld&quot;, (parseState-&gt;objectStack.count - 4UL), [NSString stringWithUTF8String:__FILE__], (long)__LINE__); break; } }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    size_t objectStackIndex = parseState-&gt;objectStack.index++;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    parseState-&gt;objectStack.keys[objectStackIndex]    = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    parseState-&gt;objectStack.objects[objectStackIndex] = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    void *key = NULL, *object = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if(JK_EXPECT_T((JK_EXPECT_T(stopParsing == 0)) &amp;&amp; (JK_EXPECT_T((stopParsing = jk_parse_next_token(parseState)) == 0)))) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      switch(parseState-&gt;token.type) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>        case JKTokenTypeString:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          if(JK_EXPECT_F((dictState &amp; JKParseAcceptValue)        == 0))    { parseState-&gt;errorIsPrev = 1; jk_error(parseState, @&quot;Unexpected string.&quot;);           stopParsing = 1; break; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          if(JK_EXPECT_F((key = jk_object_for_token(parseState)) == NULL)) {                              jk_error(parseState, @&quot;Internal error: Key == NULL.&quot;); stopParsing = 1; break; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>          else {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            parseState-&gt;objectStack.keys[objectStackIndex] = key;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            if(JK_EXPECT_T(parseState-&gt;token.value.cacheItem != NULL)) { if(JK_EXPECT_F(parseState-&gt;token.value.cacheItem-&gt;cfHash == 0UL)) { parseState-&gt;token.value.cacheItem-&gt;cfHash = CFHash(key); } parseState-&gt;objectStack.cfHashes[objectStackIndex] = parseState-&gt;token.value.cacheItem-&gt;cfHash; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            else { parseState-&gt;objectStack.cfHashes[objectStackIndex] = CFHash(key); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>          }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        case JKTokenTypeObjectEnd: if((JK_EXPECT_T(dictState &amp; JKParseAcceptEnd)))   { NSCParameterAssert(parseState-&gt;objectStack.index &gt;= startingObjectIndex); parsedDictionary = jk_create_dictionary(parseState, startingObjectIndex); } else { parseState-&gt;errorIsPrev = 1; jk_error(parseState, @&quot;Unexpected &apos;}&apos;.&quot;); } stopParsing = 1; break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        case JKTokenTypeComma:     if((JK_EXPECT_T(dictState &amp; JKParseAcceptComma))) { dictState = JKParseAcceptValue; parseState-&gt;objectStack.index--; continue; } else { parseState-&gt;errorIsPrev = 1; jk_error(parseState, @&quot;Unexpected &apos;,&apos;.&quot;); stopParsing = 1; } break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        default: parseState-&gt;errorIsPrev = 1; jk_error_parse_accept_or3(parseState, dictState, @&quot;a \&quot;STRING\&quot;&quot;, @&quot;a comma&quot;, @&quot;a &apos;}&apos;&quot;); stopParsing = 1; break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>      }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if(JK_EXPECT_T(stopParsing == 0)) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      if(JK_EXPECT_T((stopParsing = jk_parse_next_token(parseState)) == 0)) { if(JK_EXPECT_F(parseState-&gt;token.type != JKTokenTypeSeparator)) { parseState-&gt;errorIsPrev = 1; jk_error(parseState, @&quot;Expected &apos;:&apos;.&quot;); stopParsing = 1; } }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if((JK_EXPECT_T(stopParsing == 0)) &amp;&amp; (JK_EXPECT_T((stopParsing = jk_parse_next_token(parseState)) == 0))) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      switch(parseState-&gt;token.type) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>        case JKTokenTypeNumber:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>        case JKTokenTypeString:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>        case JKTokenTypeTrue:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>        case JKTokenTypeFalse:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>        case JKTokenTypeNull:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>        case JKTokenTypeArrayBegin:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>        case JKTokenTypeObjectBegin:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          if(JK_EXPECT_F((dictState &amp; JKParseAcceptValue)           == 0))    { parseState-&gt;errorIsPrev = 1; jk_error(parseState, @&quot;Unexpected value.&quot;);               stopParsing = 1; break; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          if(JK_EXPECT_F((object = jk_object_for_token(parseState)) == NULL)) {                              jk_error(parseState, @&quot;Internal error: Object == NULL.&quot;); stopParsing = 1; break; } else { parseState-&gt;objectStack.objects[objectStackIndex] = object; dictState = JKParseAcceptCommaOrEnd; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        default: parseState-&gt;errorIsPrev = 1; jk_error_parse_accept_or3(parseState, dictState, @&quot;a value&quot;, @&quot;a comma&quot;, @&quot;a &apos;}&apos;&quot;); stopParsing = 1; break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>      }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(JK_EXPECT_F(parsedDictionary == NULL)) { size_t idx = 0UL; for(idx = startingObjectIndex; idx &lt; parseState-&gt;objectStack.index; idx++) { if(parseState-&gt;objectStack.keys[idx] != NULL) { CFRelease(parseState-&gt;objectStack.keys[idx]); parseState-&gt;objectStack.keys[idx] = NULL; } if(parseState-&gt;objectStack.objects[idx] != NULL) { CFRelease(parseState-&gt;objectStack.objects[idx]); parseState-&gt;objectStack.objects[idx] = NULL; } } }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#if !defined(NS_BLOCK_ASSERTIONS)</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  else { size_t idx = 0UL; for(idx = startingObjectIndex; idx &lt; parseState-&gt;objectStack.index; idx++) { parseState-&gt;objectStack.objects[idx] = NULL; parseState-&gt;objectStack.keys[idx] = NULL; } }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#endif</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  parseState-&gt;objectStack.index = startingObjectIndex;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return(parsedDictionary);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>static id json_parse_it(JKParseState *parseState) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  id  parsedObject = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  int stopParsing  = 0;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  while((JK_EXPECT_T(stopParsing == 0)) &amp;&amp; (JK_EXPECT_T(parseState-&gt;atIndex &lt; parseState-&gt;stringBuffer.bytes.length))) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if((JK_EXPECT_T(stopParsing == 0)) &amp;&amp; (JK_EXPECT_T((stopParsing = jk_parse_next_token(parseState)) == 0))) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      switch(parseState-&gt;token.type) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>        case JKTokenTypeArrayBegin:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        case JKTokenTypeObjectBegin: parsedObject = [(id)jk_object_for_token(parseState) autorelease]; stopParsing = 1; break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        default:                     jk_error(parseState, @&quot;Expected either &apos;[&apos; or &apos;{&apos;.&quot;);             stopParsing = 1; break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>      }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSCParameterAssert((parseState-&gt;objectStack.index == 0) &amp;&amp; (JK_AT_STRING_PTR(parseState) &lt;= JK_END_STRING_PTR(parseState)));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if((parsedObject == NULL) &amp;&amp; (JK_AT_STRING_PTR(parseState) == JK_END_STRING_PTR(parseState))) { jk_error(parseState, @&quot;Reached the end of the buffer.&quot;); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(parsedObject == NULL) { jk_error(parseState, @&quot;Unable to parse JSON.&quot;); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if((parsedObject != NULL) &amp;&amp; (JK_AT_STRING_PTR(parseState) &lt; JK_END_STRING_PTR(parseState))) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    jk_parse_skip_whitespace(parseState);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if((parsedObject != NULL) &amp;&amp; ((parseState-&gt;parseOptionFlags &amp; JKParseOptionPermitTextAfterValidJSON) == 0) &amp;&amp; (JK_AT_STRING_PTR(parseState) &lt; JK_END_STRING_PTR(parseState))) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      jk_error(parseState, @&quot;A valid JSON object was parsed but there were additional non-white-space characters remaining.&quot;);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      parsedObject = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return(parsedObject);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>////////////</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#pragma mark -</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#pragma mark Object cache</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>// This uses a Galois Linear Feedback Shift Register (LFSR) PRNG to pick which item in the cache to age. It has a period of (2^32)-1.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>// NOTE: A LFSR *MUST* be initialized to a non-zero value and must always have a non-zero value.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>JK_STATIC_INLINE void jk_cache_age(JKParseState *parseState) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSCParameterAssert((parseState != NULL) &amp;&amp; (parseState-&gt;cache.prng_lfsr != 0U));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  parseState-&gt;cache.prng_lfsr = (parseState-&gt;cache.prng_lfsr &gt;&gt; 1) ^ ((0U - (parseState-&gt;cache.prng_lfsr &amp; 1U)) &amp; 0x80200003U);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  parseState-&gt;cache.age[parseState-&gt;cache.prng_lfsr &amp; (parseState-&gt;cache.count - 1UL)] &gt;&gt;= 1;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>// The object cache is nothing more than a hash table with open addressing collision resolution that is bounded by JK_CACHE_PROBES attempts.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>//</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>// The hash table is a linear C array of JKTokenCacheItem.  The terms &quot;item&quot; and &quot;bucket&quot; are synonymous with the index in to the cache array, i.e. cache.items[bucket].</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>//</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>// Items in the cache have an age associated with them.  The age is the number of rightmost 1 bits, i.e. 0000 = 0, 0001 = 1, 0011 = 2, 0111 = 3, 1111 = 4.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>// This allows us to use left and right shifts to add or subtract from an items age.  Add = (age &lt;&lt; 1) | 1.  Subtract = age &gt;&gt; 0.  Subtract is synonymous with &quot;age&quot; (i.e., age an item).</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>// The reason for this is it allows us to perform saturated adds and subtractions and is branchless.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>// The primitive C type MUST be unsigned.  It is currently a &quot;char&quot;, which allows (at a minimum and in practice) 8 bits.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>//</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>// A &quot;useable bucket&quot; is a bucket that is not in use (never populated), or has an age == 0.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>//</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>// When an item is found in the cache, it&apos;s age is incremented.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>// If a useable bucket hasn&apos;t been found, the current item (bucket) is aged along with two random items.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>//</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>// If a value is not found in the cache, and no useable bucket has been found, that value is not added to the cache.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>static void *jk_cachedObjects(JKParseState *parseState) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  unsigned long  bucket     = parseState-&gt;token.value.hash &amp; (parseState-&gt;cache.count - 1UL), setBucket = 0UL, useableBucket = 0UL, x = 0UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  void          *parsedAtom = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>    </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(JK_EXPECT_F(parseState-&gt;token.value.ptrRange.length == 0UL) &amp;&amp; JK_EXPECT_T(parseState-&gt;token.value.type == JKValueTypeString)) { return(@&quot;&quot;); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  for(x = 0UL; x &lt; JK_CACHE_PROBES; x++) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if(JK_EXPECT_F(parseState-&gt;cache.items[bucket].object == NULL)) { setBucket = 1UL; useableBucket = bucket; break; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>    </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if((JK_EXPECT_T(parseState-&gt;cache.items[bucket].hash == parseState-&gt;token.value.hash)) &amp;&amp; (JK_EXPECT_T(parseState-&gt;cache.items[bucket].size == parseState-&gt;token.value.ptrRange.length)) &amp;&amp; (JK_EXPECT_T(parseState-&gt;cache.items[bucket].type == parseState-&gt;token.value.type)) &amp;&amp; (JK_EXPECT_T(parseState-&gt;cache.items[bucket].bytes != NULL)) &amp;&amp; (JK_EXPECT_T(memcmp(parseState-&gt;cache.items[bucket].bytes, parseState-&gt;token.value.ptrRange.ptr, parseState-&gt;token.value.ptrRange.length) == 0U))) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      parseState-&gt;cache.age[bucket]     = (parseState-&gt;cache.age[bucket] &lt;&lt; 1) | 1U;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      parseState-&gt;token.value.cacheItem = &amp;parseState-&gt;cache.items[bucket];</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      NSCParameterAssert(parseState-&gt;cache.items[bucket].object != NULL);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      return((void *)CFRetain(parseState-&gt;cache.items[bucket].object));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>    } else {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      if(JK_EXPECT_F(setBucket == 0UL) &amp;&amp; JK_EXPECT_F(parseState-&gt;cache.age[bucket] == 0U)) { setBucket = 1UL; useableBucket = bucket; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      if(JK_EXPECT_F(setBucket == 0UL))                                                     { parseState-&gt;cache.age[bucket] &gt;&gt;= 1; jk_cache_age(parseState); jk_cache_age(parseState); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>      // This is the open addressing function.  The values length and type are used as a form of &quot;double hashing&quot; to distribute values with the same effective value hash across different object cache buckets.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>      // The values type is a prime number that is relatively coprime to the other primes in the set of value types and the number of hash table buckets.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      bucket = (parseState-&gt;token.value.hash + (parseState-&gt;token.value.ptrRange.length * (x + 1UL)) + (parseState-&gt;token.value.type * (x + 1UL)) + (3UL * (x + 1UL))) &amp; (parseState-&gt;cache.count - 1UL);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>    }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  switch(parseState-&gt;token.value.type) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    case JKValueTypeString:           parsedAtom = (void *)CFStringCreateWithBytes(NULL, parseState-&gt;token.value.ptrRange.ptr, parseState-&gt;token.value.ptrRange.length, kCFStringEncodingUTF8, 0); break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    case JKValueTypeLongLong:         parsedAtom = (void *)CFNumberCreate(NULL, kCFNumberLongLongType, &amp;parseState-&gt;token.value.number.longLongValue);                                             break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>    case JKValueTypeUnsignedLongLong:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      if(parseState-&gt;token.value.number.unsignedLongLongValue &lt;= LLONG_MAX) { parsedAtom = (void *)CFNumberCreate(NULL, kCFNumberLongLongType, &amp;parseState-&gt;token.value.number.unsignedLongLongValue); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      else { parsedAtom = (void *)parseState-&gt;objCImpCache.NSNumberInitWithUnsignedLongLong(parseState-&gt;objCImpCache.NSNumberAlloc(parseState-&gt;objCImpCache.NSNumberClass, @selector(alloc)), @selector(initWithUnsignedLongLong:), parseState-&gt;token.value.number.unsignedLongLongValue); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    case JKValueTypeDouble:           parsedAtom = (void *)CFNumberCreate(NULL, kCFNumberDoubleType,   &amp;parseState-&gt;token.value.number.doubleValue);                                               break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    default: jk_error(parseState, @&quot;Internal error: Unknown token value type. %@ line #%ld&quot;, [NSString stringWithUTF8String:__FILE__], (long)__LINE__); break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(JK_EXPECT_T(setBucket) &amp;&amp; (JK_EXPECT_T(parsedAtom != NULL))) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    bucket = useableBucket;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if(JK_EXPECT_T((parseState-&gt;cache.items[bucket].object != NULL))) { CFRelease(parseState-&gt;cache.items[bucket].object); parseState-&gt;cache.items[bucket].object = NULL; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>    </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if(JK_EXPECT_T((parseState-&gt;cache.items[bucket].bytes = (unsigned char *)reallocf(parseState-&gt;cache.items[bucket].bytes, parseState-&gt;token.value.ptrRange.length)) != NULL)) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      memcpy(parseState-&gt;cache.items[bucket].bytes, parseState-&gt;token.value.ptrRange.ptr, parseState-&gt;token.value.ptrRange.length);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      parseState-&gt;cache.items[bucket].object = (void *)CFRetain(parsedAtom);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      parseState-&gt;cache.items[bucket].hash   = parseState-&gt;token.value.hash;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      parseState-&gt;cache.items[bucket].cfHash = 0UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      parseState-&gt;cache.items[bucket].size   = parseState-&gt;token.value.ptrRange.length;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      parseState-&gt;cache.items[bucket].type   = parseState-&gt;token.value.type;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      parseState-&gt;token.value.cacheItem      = &amp;parseState-&gt;cache.items[bucket];</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      parseState-&gt;cache.age[bucket]          = JK_INIT_CACHE_AGE;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    } else { // The realloc failed, so clear the appropriate fields.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      parseState-&gt;cache.items[bucket].hash   = 0UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      parseState-&gt;cache.items[bucket].cfHash = 0UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      parseState-&gt;cache.items[bucket].size   = 0UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      parseState-&gt;cache.items[bucket].type   = 0UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>    }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return(parsedAtom);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>static void *jk_object_for_token(JKParseState *parseState) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  void *parsedAtom = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  parseState-&gt;token.value.cacheItem = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  switch(parseState-&gt;token.type) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    case JKTokenTypeString:      parsedAtom = jk_cachedObjects(parseState);    break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    case JKTokenTypeNumber:      parsedAtom = jk_cachedObjects(parseState);    break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    case JKTokenTypeObjectBegin: parsedAtom = jk_parse_dictionary(parseState); break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    case JKTokenTypeArrayBegin:  parsedAtom = jk_parse_array(parseState);      break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    case JKTokenTypeTrue:        parsedAtom = (void *)kCFBooleanTrue;          break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    case JKTokenTypeFalse:       parsedAtom = (void *)kCFBooleanFalse;         break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    case JKTokenTypeNull:        parsedAtom = (void *)kCFNull;                 break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    default: jk_error(parseState, @&quot;Internal error: Unknown token type. %@ line #%ld&quot;, [NSString stringWithUTF8String:__FILE__], (long)__LINE__); break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return(parsedAtom);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#pragma mark -</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>@implementation JSONDecoder</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>+ (id)decoder</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return([self decoderWithParseOptions:JKParseOptionStrict]);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>+ (id)decoderWithParseOptions:(JKParseOptionFlags)parseOptionFlags</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return([[[self alloc] initWithParseOptions:parseOptionFlags] autorelease]);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (id)init</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return([self initWithParseOptions:JKParseOptionStrict]);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (id)initWithParseOptions:(JKParseOptionFlags)parseOptionFlags</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if((self = [super init]) == NULL) { return(NULL); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(parseOptionFlags &amp; ~JKParseOptionValidFlags) { [self autorelease]; [NSException raise:NSInvalidArgumentException format:@&quot;Invalid parse options.&quot;]; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if((parseState = (JKParseState *)calloc(1UL, sizeof(JKParseState))) == NULL) { goto errorExit; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  parseState-&gt;parseOptionFlags = parseOptionFlags;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  parseState-&gt;token.tokenBuffer.roundSizeUpToMultipleOf = 4096UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  parseState-&gt;objectStack.roundSizeUpToMultipleOf       = 2048UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  parseState-&gt;objCImpCache.NSNumberClass                    = _jk_NSNumberClass;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  parseState-&gt;objCImpCache.NSNumberAlloc                    = _jk_NSNumberAllocImp;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  parseState-&gt;objCImpCache.NSNumberInitWithUnsignedLongLong = _jk_NSNumberInitWithUnsignedLongLongImp;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  parseState-&gt;cache.prng_lfsr = 1U;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  parseState-&gt;cache.count     = JK_CACHE_SLOTS;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if((parseState-&gt;cache.items = (JKTokenCacheItem *)calloc(1UL, sizeof(JKTokenCacheItem) * parseState-&gt;cache.count)) == NULL) { goto errorExit; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return(self);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> errorExit:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(self) { [self autorelease]; self = NULL; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return(NULL);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>// This is here primarily to support the NSString and NSData convenience functions so the autoreleased JSONDecoder can release most of its resources before the pool pops.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>static void _JSONDecoderCleanup(JSONDecoder *decoder) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if((decoder != NULL) &amp;&amp; (decoder-&gt;parseState != NULL)) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    jk_managedBuffer_release(&amp;decoder-&gt;parseState-&gt;token.tokenBuffer);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    jk_objectStack_release(&amp;decoder-&gt;parseState-&gt;objectStack);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>    </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    [decoder clearCache];</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if(decoder-&gt;parseState-&gt;cache.items != NULL) { free(decoder-&gt;parseState-&gt;cache.items); decoder-&gt;parseState-&gt;cache.items = NULL; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>    </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    free(decoder-&gt;parseState); decoder-&gt;parseState = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (void)dealloc</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  _JSONDecoderCleanup(self);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  [super dealloc];</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (void)clearCache</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(JK_EXPECT_T(parseState != NULL)) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if(JK_EXPECT_T(parseState-&gt;cache.items != NULL)) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      size_t idx = 0UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      for(idx = 0UL; idx &lt; parseState-&gt;cache.count; idx++) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        if(JK_EXPECT_T(parseState-&gt;cache.items[idx].object != NULL)) { CFRelease(parseState-&gt;cache.items[idx].object); parseState-&gt;cache.items[idx].object = NULL; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        if(JK_EXPECT_T(parseState-&gt;cache.items[idx].bytes  != NULL)) { free(parseState-&gt;cache.items[idx].bytes);       parseState-&gt;cache.items[idx].bytes  = NULL; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        memset(&amp;parseState-&gt;cache.items[idx], 0, sizeof(JKTokenCacheItem));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        parseState-&gt;cache.age[idx] = 0U;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>// This needs to be completely rewritten.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>static id _JKParseUTF8String(JKParseState *parseState, BOOL mutableCollections, const unsigned char *string, size_t length, NSError **error) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSCParameterAssert((parseState != NULL) &amp;&amp; (string != NULL) &amp;&amp; (parseState-&gt;cache.prng_lfsr != 0U));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  parseState-&gt;stringBuffer.bytes.ptr    = string;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  parseState-&gt;stringBuffer.bytes.length = length;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  parseState-&gt;atIndex                   = 0UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  parseState-&gt;lineNumber                = 1UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  parseState-&gt;lineStartIndex            = 0UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  parseState-&gt;prev_atIndex              = 0UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  parseState-&gt;prev_lineNumber           = 1UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  parseState-&gt;prev_lineStartIndex       = 0UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  parseState-&gt;error                     = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  parseState-&gt;errorIsPrev               = 0;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  parseState-&gt;mutableCollections        = (mutableCollections == NO) ? NO : YES;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  unsigned char stackTokenBuffer[JK_TOKENBUFFER_SIZE] JK_ALIGNED(64);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  jk_managedBuffer_setToStackBuffer(&amp;parseState-&gt;token.tokenBuffer, stackTokenBuffer, sizeof(stackTokenBuffer));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  void       *stackObjects [JK_STACK_OBJS] JK_ALIGNED(64);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  void       *stackKeys    [JK_STACK_OBJS] JK_ALIGNED(64);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  CFHashCode  stackCFHashes[JK_STACK_OBJS] JK_ALIGNED(64);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  jk_objectStack_setToStackBuffer(&amp;parseState-&gt;objectStack, stackObjects, stackKeys, stackCFHashes, JK_STACK_OBJS);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  id parsedJSON = json_parse_it(parseState);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if((error != NULL) &amp;&amp; (parseState-&gt;error != NULL)) { *error = parseState-&gt;error; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  jk_managedBuffer_release(&amp;parseState-&gt;token.tokenBuffer);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  jk_objectStack_release(&amp;parseState-&gt;objectStack);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  parseState-&gt;stringBuffer.bytes.ptr    = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  parseState-&gt;stringBuffer.bytes.length = 0UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  parseState-&gt;atIndex                   = 0UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  parseState-&gt;lineNumber                = 1UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  parseState-&gt;lineStartIndex            = 0UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  parseState-&gt;prev_atIndex              = 0UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  parseState-&gt;prev_lineNumber           = 1UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  parseState-&gt;prev_lineStartIndex       = 0UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  parseState-&gt;error                     = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  parseState-&gt;errorIsPrev               = 0;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  parseState-&gt;mutableCollections        = NO;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return(parsedJSON);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>////////////</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#pragma mark Deprecated as of v1.4</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>////////////</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>// Deprecated in JSONKit v1.4.  Use objectWithUTF8String:length: instead.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (id)parseUTF8String:(const unsigned char *)string length:(size_t)length</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return([self objectWithUTF8String:string length:length error:NULL]);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>// Deprecated in JSONKit v1.4.  Use objectWithUTF8String:length:error: instead.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (id)parseUTF8String:(const unsigned char *)string length:(size_t)length error:(NSError **)error</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return([self objectWithUTF8String:string length:length error:error]);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>// Deprecated in JSONKit v1.4.  Use objectWithData: instead.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (id)parseJSONData:(NSData *)jsonData</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return([self objectWithData:jsonData error:NULL]);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>// Deprecated in JSONKit v1.4.  Use objectWithData:error: instead.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (id)parseJSONData:(NSData *)jsonData error:(NSError **)error</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return([self objectWithData:jsonData error:error]);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>////////////</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#pragma mark Methods that return immutable collection objects</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>////////////</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (id)objectWithUTF8String:(const unsigned char *)string length:(NSUInteger)length</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return([self objectWithUTF8String:string length:length error:NULL]);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (id)objectWithUTF8String:(const unsigned char *)string length:(NSUInteger)length error:(NSError **)error</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(parseState == NULL) { [NSException raise:NSInternalInconsistencyException format:@&quot;parseState is NULL.&quot;];          }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(string     == NULL) { [NSException raise:NSInvalidArgumentException       format:@&quot;The string argument is NULL.&quot;]; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return(_JKParseUTF8String(parseState, NO, string, (size_t)length, error));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (id)objectWithData:(NSData *)jsonData</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return([self objectWithData:jsonData error:NULL]);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (id)objectWithData:(NSData *)jsonData error:(NSError **)error</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(jsonData == NULL) { [NSException raise:NSInvalidArgumentException format:@&quot;The jsonData argument is NULL.&quot;]; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return([self objectWithUTF8String:(const unsigned char *)[jsonData bytes] length:[jsonData length] error:error]);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>////////////</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#pragma mark Methods that return mutable collection objects</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>////////////</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (id)mutableObjectWithUTF8String:(const unsigned char *)string length:(NSUInteger)length</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return([self mutableObjectWithUTF8String:string length:length error:NULL]);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (id)mutableObjectWithUTF8String:(const unsigned char *)string length:(NSUInteger)length error:(NSError **)error</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(parseState == NULL) { [NSException raise:NSInternalInconsistencyException format:@&quot;parseState is NULL.&quot;];          }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(string     == NULL) { [NSException raise:NSInvalidArgumentException       format:@&quot;The string argument is NULL.&quot;]; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return(_JKParseUTF8String(parseState, YES, string, (size_t)length, error));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (id)mutableObjectWithData:(NSData *)jsonData</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return([self mutableObjectWithData:jsonData error:NULL]);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (id)mutableObjectWithData:(NSData *)jsonData error:(NSError **)error</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(jsonData == NULL) { [NSException raise:NSInvalidArgumentException format:@&quot;The jsonData argument is NULL.&quot;]; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return([self mutableObjectWithUTF8String:(const unsigned char *)[jsonData bytes] length:[jsonData length] error:error]);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>@end</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>/*</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> The NSString and NSData convenience methods need a little bit of explanation.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> Prior to JSONKit v1.4, the NSString -objectFromJSONStringWithParseOptions:error: method looked like</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> const unsigned char *utf8String = (const unsigned char *)[self UTF8String];</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> if(utf8String == NULL) { return(NULL); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> size_t               utf8Length = strlen((const char *)utf8String); </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> return([[JSONDecoder decoderWithParseOptions:parseOptionFlags] parseUTF8String:utf8String length:utf8Length error:error]);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> This changed with v1.4 to a more complicated method.  The reason for this is to keep the amount of memory that is</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> allocated, but not yet freed because it is dependent on the autorelease pool to pop before it can be reclaimed.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> In the simpler v1.3 code, this included all the bytes used to store the -UTF8String along with the JSONDecoder and all its overhead.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> Now we use an autoreleased CFMutableData that is sized to the UTF8 length of the NSString in question and is used to hold the UTF8</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> conversion of said string.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> Once parsed, the CFMutableData has its length set to 0.  This should, hopefully, allow the CFMutableData to realloc and/or free</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> the buffer.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> Another change made was a slight modification to JSONDecoder so that most of the cleanup work that was done in -dealloc was moved</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> to a private, internal function.  These convenience routines keep the pointer to the autoreleased JSONDecoder and calls</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> _JSONDecoderCleanup() to early release the decoders resources since we already know that particular decoder is not going to be used</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> again.  </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> If everything goes smoothly, this will most likely result in perhaps a few hundred bytes that are allocated but waiting for the</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> autorelease pool to pop.  This is compared to the thousands and easily hundreds of thousands of bytes that would have been in</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> autorelease limbo.  It&apos;s more complicated for us, but a win for the user.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> Autorelease objects are used in case things don&apos;t go smoothly.  By having them autoreleased, we effectively guarantee that our</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> requirement to -release the object is always met, not matter what goes wrong.  The downside is having a an object or two in</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> autorelease limbo, but we&apos;ve done our best to minimize that impact, so it all balances out.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> */</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>@implementation NSString (JSONKitDeserializing)</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>static id _NSStringObjectFromJSONString(NSString *jsonString, JKParseOptionFlags parseOptionFlags, NSError **error, BOOL mutableCollection) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  id                returnObject = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  CFMutableDataRef  mutableData  = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  JSONDecoder      *decoder      = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  CFIndex    stringLength     = CFStringGetLength((CFStringRef)jsonString);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSUInteger stringUTF8Length = [jsonString lengthOfBytesUsingEncoding:NSUTF8StringEncoding];</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if((mutableData = (CFMutableDataRef)[(id)CFDataCreateMutable(NULL, (NSUInteger)stringUTF8Length) autorelease]) != NULL) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    UInt8   *utf8String = CFDataGetMutableBytePtr(mutableData);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    CFIndex  usedBytes  = 0L, convertedCount = 0L;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>    </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    convertedCount = CFStringGetBytes((CFStringRef)jsonString, CFRangeMake(0L, stringLength), kCFStringEncodingUTF8, &apos;?&apos;, NO, utf8String, (NSUInteger)stringUTF8Length, &amp;usedBytes);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if(JK_EXPECT_F(convertedCount != stringLength) || JK_EXPECT_F(usedBytes &lt; 0L)) { if(error != NULL) { *error = [NSError errorWithDomain:@&quot;JKErrorDomain&quot; code:-1L userInfo:[NSDictionary dictionaryWithObject:@&quot;An error occurred converting the contents of a NSString to UTF8.&quot; forKey:NSLocalizedDescriptionKey]]; } goto exitNow; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>    </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if(mutableCollection == NO) { returnObject = [(decoder = [JSONDecoder decoderWithParseOptions:parseOptionFlags])        objectWithUTF8String:(const unsigned char *)utf8String length:(size_t)usedBytes error:error]; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    else                        { returnObject = [(decoder = [JSONDecoder decoderWithParseOptions:parseOptionFlags]) mutableObjectWithUTF8String:(const unsigned char *)utf8String length:(size_t)usedBytes error:error]; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>exitNow:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(mutableData != NULL) { CFDataSetLength(mutableData, 0L); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(decoder     != NULL) { _JSONDecoderCleanup(decoder);     }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return(returnObject);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (id)objectFromJSONString</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return([self objectFromJSONStringWithParseOptions:JKParseOptionStrict error:NULL]);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (id)objectFromJSONStringWithParseOptions:(JKParseOptionFlags)parseOptionFlags</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return([self objectFromJSONStringWithParseOptions:parseOptionFlags error:NULL]);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (id)objectFromJSONStringWithParseOptions:(JKParseOptionFlags)parseOptionFlags error:(NSError **)error</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return(_NSStringObjectFromJSONString(self, parseOptionFlags, error, NO));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (id)mutableObjectFromJSONString</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return([self mutableObjectFromJSONStringWithParseOptions:JKParseOptionStrict error:NULL]);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (id)mutableObjectFromJSONStringWithParseOptions:(JKParseOptionFlags)parseOptionFlags</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return([self mutableObjectFromJSONStringWithParseOptions:parseOptionFlags error:NULL]);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (id)mutableObjectFromJSONStringWithParseOptions:(JKParseOptionFlags)parseOptionFlags error:(NSError **)error</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return(_NSStringObjectFromJSONString(self, parseOptionFlags, error, YES));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>@end</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>@implementation NSData (JSONKitDeserializing)</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (id)objectFromJSONData</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return([self objectFromJSONDataWithParseOptions:JKParseOptionStrict error:NULL]);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (id)objectFromJSONDataWithParseOptions:(JKParseOptionFlags)parseOptionFlags</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return([self objectFromJSONDataWithParseOptions:parseOptionFlags error:NULL]);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (id)objectFromJSONDataWithParseOptions:(JKParseOptionFlags)parseOptionFlags error:(NSError **)error</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  JSONDecoder *decoder = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  id returnObject = [(decoder = [JSONDecoder decoderWithParseOptions:parseOptionFlags]) objectWithData:self error:error];</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(decoder != NULL) { _JSONDecoderCleanup(decoder); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return(returnObject);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (id)mutableObjectFromJSONData</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return([self mutableObjectFromJSONDataWithParseOptions:JKParseOptionStrict error:NULL]);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (id)mutableObjectFromJSONDataWithParseOptions:(JKParseOptionFlags)parseOptionFlags</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return([self mutableObjectFromJSONDataWithParseOptions:parseOptionFlags error:NULL]);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (id)mutableObjectFromJSONDataWithParseOptions:(JKParseOptionFlags)parseOptionFlags error:(NSError **)error</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  JSONDecoder *decoder = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  id returnObject = [(decoder = [JSONDecoder decoderWithParseOptions:parseOptionFlags]) mutableObjectWithData:self error:error];</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(decoder != NULL) { _JSONDecoderCleanup(decoder); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return(returnObject);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>@end</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>////////////</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#pragma mark -</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#pragma mark Encoding / deserializing functions</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>static void jk_encode_error(JKEncodeState *encodeState, NSString *format, ...) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSCParameterAssert((encodeState != NULL) &amp;&amp; (format != NULL));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  va_list varArgsList;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  va_start(varArgsList, format);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSString *formatString = [[[NSString alloc] initWithFormat:format arguments:varArgsList] autorelease];</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  va_end(varArgsList);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(encodeState-&gt;error == NULL) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    encodeState-&gt;error = [NSError errorWithDomain:@&quot;JKErrorDomain&quot; code:-1L userInfo:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>                                   [NSDictionary dictionaryWithObjectsAndKeys:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>                                                                              formatString, NSLocalizedDescriptionKey,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>                                                                              NULL]];</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>JK_STATIC_INLINE void jk_encode_updateCache(JKEncodeState *encodeState, JKEncodeCache *cacheSlot, size_t startingAtIndex, id object) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSCParameterAssert(encodeState != NULL);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(JK_EXPECT_T(cacheSlot != NULL)) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    NSCParameterAssert((object != NULL) &amp;&amp; (startingAtIndex &lt;= encodeState-&gt;atIndex));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    cacheSlot-&gt;object = object;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    cacheSlot-&gt;offset = startingAtIndex;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    cacheSlot-&gt;length = (size_t)(encodeState-&gt;atIndex - startingAtIndex);  </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>static int jk_encode_printf(JKEncodeState *encodeState, JKEncodeCache *cacheSlot, size_t startingAtIndex, id object, const char *format, ...) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  va_list varArgsList, varArgsListCopy;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  va_start(varArgsList, format);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  va_copy(varArgsListCopy, varArgsList);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSCParameterAssert((encodeState != NULL) &amp;&amp; (encodeState-&gt;atIndex &lt; encodeState-&gt;stringBuffer.bytes.length) &amp;&amp; (startingAtIndex &lt;= encodeState-&gt;atIndex) &amp;&amp; (format != NULL));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  ssize_t  formattedStringLength = 0L;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  int      returnValue           = 0;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(JK_EXPECT_T((formattedStringLength = vsnprintf((char *)&amp;encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex], (encodeState-&gt;stringBuffer.bytes.length - encodeState-&gt;atIndex), format, varArgsList)) &gt;= (ssize_t)(encodeState-&gt;stringBuffer.bytes.length - encodeState-&gt;atIndex))) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    NSCParameterAssert(((encodeState-&gt;atIndex + (formattedStringLength * 2UL) + 256UL) &gt; encodeState-&gt;stringBuffer.bytes.length));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if(JK_EXPECT_F(((encodeState-&gt;atIndex + (formattedStringLength * 2UL) + 256UL) &gt; encodeState-&gt;stringBuffer.bytes.length)) &amp;&amp; JK_EXPECT_F((jk_managedBuffer_resize(&amp;encodeState-&gt;stringBuffer, encodeState-&gt;atIndex + (formattedStringLength * 2UL)+ 4096UL) == NULL))) { jk_encode_error(encodeState, @&quot;Unable to resize temporary buffer.&quot;); returnValue = 1; goto exitNow; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if(JK_EXPECT_F((formattedStringLength = vsnprintf((char *)&amp;encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex], (encodeState-&gt;stringBuffer.bytes.length - encodeState-&gt;atIndex), format, varArgsListCopy)) &gt;= (ssize_t)(encodeState-&gt;stringBuffer.bytes.length - encodeState-&gt;atIndex))) { jk_encode_error(encodeState, @&quot;vsnprintf failed unexpectedly.&quot;); returnValue = 1; goto exitNow; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>exitNow:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  va_end(varArgsList);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  va_end(varArgsListCopy);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(JK_EXPECT_T(returnValue == 0)) { encodeState-&gt;atIndex += formattedStringLength; jk_encode_updateCache(encodeState, cacheSlot, startingAtIndex, object); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return(returnValue);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>static int jk_encode_write(JKEncodeState *encodeState, JKEncodeCache *cacheSlot, size_t startingAtIndex, id object, const char *format) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSCParameterAssert((encodeState != NULL) &amp;&amp; (encodeState-&gt;atIndex &lt; encodeState-&gt;stringBuffer.bytes.length) &amp;&amp; (startingAtIndex &lt;= encodeState-&gt;atIndex) &amp;&amp; (format != NULL));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(JK_EXPECT_F(((encodeState-&gt;atIndex + strlen(format) + 256UL) &gt; encodeState-&gt;stringBuffer.bytes.length)) &amp;&amp; JK_EXPECT_F((jk_managedBuffer_resize(&amp;encodeState-&gt;stringBuffer, encodeState-&gt;atIndex + strlen(format) + 1024UL) == NULL))) { jk_encode_error(encodeState, @&quot;Unable to resize temporary buffer.&quot;); return(1); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  size_t formatIdx = 0UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  for(formatIdx = 0UL; format[formatIdx] != 0; formatIdx++) { NSCParameterAssert(encodeState-&gt;atIndex &lt; encodeState-&gt;stringBuffer.bytes.length); encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = format[formatIdx]; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  jk_encode_updateCache(encodeState, cacheSlot, startingAtIndex, object);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return(0);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>static int jk_encode_writePrettyPrintWhiteSpace(JKEncodeState *encodeState) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSCParameterAssert((encodeState != NULL) &amp;&amp; ((encodeState-&gt;serializeOptionFlags &amp; JKSerializeOptionPretty) != 0UL));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(JK_EXPECT_F((encodeState-&gt;atIndex + ((encodeState-&gt;depth + 1UL) * 2UL) + 16UL) &gt; encodeState-&gt;stringBuffer.bytes.length) &amp;&amp; JK_EXPECT_T(jk_managedBuffer_resize(&amp;encodeState-&gt;stringBuffer, encodeState-&gt;atIndex + ((encodeState-&gt;depth + 1UL) * 2UL) + 4096UL) == NULL)) { jk_encode_error(encodeState, @&quot;Unable to resize temporary buffer.&quot;); return(1); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = &apos;\n&apos;;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  size_t depthWhiteSpace = 0UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  for(depthWhiteSpace = 0UL; depthWhiteSpace &lt; (encodeState-&gt;depth * 2UL); depthWhiteSpace++) { NSCParameterAssert(encodeState-&gt;atIndex &lt; encodeState-&gt;stringBuffer.bytes.length); encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = &apos; &apos;; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return(0);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>}  </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>static int jk_encode_write1slow(JKEncodeState *encodeState, ssize_t depthChange, const char *format) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSCParameterAssert((encodeState != NULL) &amp;&amp; (encodeState-&gt;atIndex &lt; encodeState-&gt;stringBuffer.bytes.length) &amp;&amp; (format != NULL) &amp;&amp; ((depthChange &gt;= -1L) &amp;&amp; (depthChange &lt;= 1L)) &amp;&amp; ((encodeState-&gt;depth == 0UL) ? (depthChange &gt;= 0L) : 1) &amp;&amp; ((encodeState-&gt;serializeOptionFlags &amp; JKSerializeOptionPretty) != 0UL));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(JK_EXPECT_F((encodeState-&gt;atIndex + ((encodeState-&gt;depth + 1UL) * 2UL) + 16UL) &gt; encodeState-&gt;stringBuffer.bytes.length) &amp;&amp; JK_EXPECT_F(jk_managedBuffer_resize(&amp;encodeState-&gt;stringBuffer, encodeState-&gt;atIndex + ((encodeState-&gt;depth + 1UL) * 2UL) + 4096UL) == NULL)) { jk_encode_error(encodeState, @&quot;Unable to resize temporary buffer.&quot;); return(1); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  encodeState-&gt;depth += depthChange;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(JK_EXPECT_T(format[0] == &apos;:&apos;)) { encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = format[0]; encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = &apos; &apos;; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  else {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if(JK_EXPECT_F(depthChange == -1L)) { if(JK_EXPECT_F(jk_encode_writePrettyPrintWhiteSpace(encodeState))) { return(1); } }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = format[0];</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if(JK_EXPECT_T(depthChange != -1L)) { if(JK_EXPECT_F(jk_encode_writePrettyPrintWhiteSpace(encodeState))) { return(1); } }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSCParameterAssert(encodeState-&gt;atIndex &lt; encodeState-&gt;stringBuffer.bytes.length);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return(0);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>static int jk_encode_write1fast(JKEncodeState *encodeState, ssize_t depthChange JK_UNUSED_ARG, const char *format) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSCParameterAssert((encodeState != NULL) &amp;&amp; (encodeState-&gt;atIndex &lt; encodeState-&gt;stringBuffer.bytes.length) &amp;&amp; ((encodeState-&gt;serializeOptionFlags &amp; JKSerializeOptionPretty) == 0UL));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(JK_EXPECT_T((encodeState-&gt;atIndex + 4UL) &lt; encodeState-&gt;stringBuffer.bytes.length)) { encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = format[0]; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  else { return(jk_encode_write(encodeState, NULL, 0UL, NULL, format)); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return(0);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>static int jk_encode_writen(JKEncodeState *encodeState, JKEncodeCache *cacheSlot, size_t startingAtIndex, id object, const char *format, size_t length) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSCParameterAssert((encodeState != NULL) &amp;&amp; (encodeState-&gt;atIndex &lt; encodeState-&gt;stringBuffer.bytes.length) &amp;&amp; (startingAtIndex &lt;= encodeState-&gt;atIndex));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(JK_EXPECT_F((encodeState-&gt;stringBuffer.bytes.length - encodeState-&gt;atIndex) &lt; (length + 4UL))) { if(jk_managedBuffer_resize(&amp;encodeState-&gt;stringBuffer, encodeState-&gt;atIndex + 4096UL + length) == NULL) { jk_encode_error(encodeState, @&quot;Unable to resize temporary buffer.&quot;); return(1); } }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  memcpy(encodeState-&gt;stringBuffer.bytes.ptr + encodeState-&gt;atIndex, format, length);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  encodeState-&gt;atIndex += length;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  jk_encode_updateCache(encodeState, cacheSlot, startingAtIndex, object);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return(0);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>JK_STATIC_INLINE JKHash jk_encode_object_hash(void *objectPtr) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return( ( (((JKHash)objectPtr) &gt;&gt; 21) ^ (((JKHash)objectPtr) &gt;&gt; 9)   ) + (((JKHash)objectPtr) &gt;&gt; 4) );</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>static int jk_encode_add_atom_to_buffer(JKEncodeState *encodeState, void *objectPtr) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSCParameterAssert((encodeState != NULL) &amp;&amp; (encodeState-&gt;atIndex &lt; encodeState-&gt;stringBuffer.bytes.length) &amp;&amp; (objectPtr != NULL));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  id     object          = (id)objectPtr, encodeCacheObject = object;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  int    isClass         = JKClassUnknown;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  size_t startingAtIndex = encodeState-&gt;atIndex;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  JKHash         objectHash = jk_encode_object_hash(objectPtr);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  JKEncodeCache *cacheSlot  = &amp;encodeState-&gt;cache[objectHash % JK_ENCODE_CACHE_SLOTS];</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(JK_EXPECT_T(cacheSlot-&gt;object == object)) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    NSCParameterAssert((cacheSlot-&gt;object != NULL) &amp;&amp;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>                       (cacheSlot-&gt;offset &lt; encodeState-&gt;atIndex)                   &amp;&amp; ((cacheSlot-&gt;offset + cacheSlot-&gt;length) &lt; encodeState-&gt;atIndex)                                    &amp;&amp;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>                       (cacheSlot-&gt;offset &lt; encodeState-&gt;stringBuffer.bytes.length) &amp;&amp; ((cacheSlot-&gt;offset + cacheSlot-&gt;length) &lt; encodeState-&gt;stringBuffer.bytes.length)                  &amp;&amp;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>                       ((encodeState-&gt;stringBuffer.bytes.ptr + encodeState-&gt;atIndex)                     &lt; (encodeState-&gt;stringBuffer.bytes.ptr + encodeState-&gt;stringBuffer.bytes.length)) &amp;&amp;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>                       ((encodeState-&gt;stringBuffer.bytes.ptr + cacheSlot-&gt;offset)                        &lt; (encodeState-&gt;stringBuffer.bytes.ptr + encodeState-&gt;stringBuffer.bytes.length)) &amp;&amp;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>                       ((encodeState-&gt;stringBuffer.bytes.ptr + cacheSlot-&gt;offset + cacheSlot-&gt;length)    &lt; (encodeState-&gt;stringBuffer.bytes.ptr + encodeState-&gt;stringBuffer.bytes.length)));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if(JK_EXPECT_F(((encodeState-&gt;atIndex + cacheSlot-&gt;length + 256UL) &gt; encodeState-&gt;stringBuffer.bytes.length)) &amp;&amp; JK_EXPECT_F((jk_managedBuffer_resize(&amp;encodeState-&gt;stringBuffer, encodeState-&gt;atIndex + cacheSlot-&gt;length + 1024UL) == NULL))) { jk_encode_error(encodeState, @&quot;Unable to resize temporary buffer.&quot;); return(1); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    NSCParameterAssert(((encodeState-&gt;atIndex + cacheSlot-&gt;length) &lt; encodeState-&gt;stringBuffer.bytes.length) &amp;&amp;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>                       ((encodeState-&gt;stringBuffer.bytes.ptr + encodeState-&gt;atIndex)                     &lt; (encodeState-&gt;stringBuffer.bytes.ptr + encodeState-&gt;stringBuffer.bytes.length)) &amp;&amp;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>                       ((encodeState-&gt;stringBuffer.bytes.ptr + encodeState-&gt;atIndex + cacheSlot-&gt;length) &lt; (encodeState-&gt;stringBuffer.bytes.ptr + encodeState-&gt;stringBuffer.bytes.length)) &amp;&amp;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>                       ((encodeState-&gt;stringBuffer.bytes.ptr + cacheSlot-&gt;offset)                        &lt; (encodeState-&gt;stringBuffer.bytes.ptr + encodeState-&gt;stringBuffer.bytes.length)) &amp;&amp;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>                       ((encodeState-&gt;stringBuffer.bytes.ptr + cacheSlot-&gt;offset + cacheSlot-&gt;length)    &lt; (encodeState-&gt;stringBuffer.bytes.ptr + encodeState-&gt;stringBuffer.bytes.length)) &amp;&amp;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>                       ((encodeState-&gt;stringBuffer.bytes.ptr + cacheSlot-&gt;offset + cacheSlot-&gt;length)    &lt; (encodeState-&gt;stringBuffer.bytes.ptr + encodeState-&gt;atIndex)));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    memcpy(encodeState-&gt;stringBuffer.bytes.ptr + encodeState-&gt;atIndex, encodeState-&gt;stringBuffer.bytes.ptr + cacheSlot-&gt;offset, cacheSlot-&gt;length);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    encodeState-&gt;atIndex += cacheSlot-&gt;length;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    return(0);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  // When we encounter a class that we do not handle, and we have either a delegate or block that the user supplied to format unsupported classes,</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  // we &quot;re-run&quot; the object check.  However, we re-run the object check exactly ONCE.  If the user supplies an object that isn&apos;t one of the</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  // supported classes, we fail the second time (i.e., double fault error).</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  BOOL rerunningAfterClassFormatter = NO;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'> rerunAfterClassFormatter:;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  // XXX XXX XXX XXX</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  //     </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  //     We need to work around a bug in 10.7, which breaks ABI compatibility with Objective-C going back not just to 10.0, but OpenStep and even NextStep.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  //     </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  //     It has long been documented that &quot;the very first thing that a pointer to an Objective-C object &quot;points to&quot; is a pointer to that objects class&quot;.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  //     </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  //     This is euphemistically called &quot;tagged pointers&quot;.  There are a number of highly technical problems with this, most involving long passages from</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  //     the C standard(s).  In short, one can make a strong case, couched from the perspective of the C standard(s), that that 10.7 &quot;tagged pointers&quot; are</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  //     fundamentally Wrong and Broken, and should have never been implemented.  Assuming those points are glossed over, because the change is very clearly</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  //     breaking ABI compatibility, this should have resulted in a minimum of a &quot;minimum version required&quot; bump in various shared libraries to prevent</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  //     causes code that used to work just fine to suddenly break without warning.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  //</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  //     In fact, the C standard says that the hack below is &quot;undefined behavior&quot;- there is no requirement that the 10.7 tagged pointer hack of setting the</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  //     &quot;lower, unused bits&quot; must be preserved when casting the result to an integer type, but this &quot;works&quot; because for most architectures</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  //     `sizeof(long) == sizeof(void *)` and the compiler uses the same representation for both.  (note: this is informal, not meant to be</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  //     normative or pedantically correct).</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  //     </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  //     In other words, while this &quot;works&quot; for now, technically the compiler is not obligated to do &quot;what we want&quot;, and a later version of the compiler</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  //     is not required in any way to produce the same results or behavior that earlier versions of the compiler did for the statement below.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  //</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  //     Fan-fucking-tastic.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  //     </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  //     Why not just use `object_getClass()`?  Because `object-&gt;isa` reduces to (typically) a *single* instruction.  Calling `object_getClass()` requires</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  //     that the compiler potentially spill registers, establish a function call frame / environment, and finally execute a &quot;jump subroutine&quot; instruction.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  //     Then, the called subroutine must spend half a dozen instructions in its prolog, however many instructions doing whatever it does, then half a dozen</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  //     instructions in its prolog.  One instruction compared to dozens, maybe a hundred instructions.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  //     </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  //     Yes, that&apos;s one to two orders of magnitude difference.  Which is compelling in its own right.  When going for performance, you&apos;re often happy with</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  //     gains in the two to three percent range.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  //     </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  // XXX XXX XXX XXX</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  BOOL workAroundMacOSXABIBreakingBug = NO;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(JK_EXPECT_F(((NSUInteger)object) &amp; 0x1)) { workAroundMacOSXABIBreakingBug = YES; goto slowClassLookup; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>       if(JK_EXPECT_T(object-&gt;isa == encodeState-&gt;fastClassLookup.stringClass))     { isClass = JKClassString;     }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  else if(JK_EXPECT_T(object-&gt;isa == encodeState-&gt;fastClassLookup.numberClass))     { isClass = JKClassNumber;     }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  else if(JK_EXPECT_T(object-&gt;isa == encodeState-&gt;fastClassLookup.dictionaryClass)) { isClass = JKClassDictionary; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  else if(JK_EXPECT_T(object-&gt;isa == encodeState-&gt;fastClassLookup.arrayClass))      { isClass = JKClassArray;      }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  else if(JK_EXPECT_T(object-&gt;isa == encodeState-&gt;fastClassLookup.nullClass))       { isClass = JKClassNull;       }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  else {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  slowClassLookup:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>         if(JK_EXPECT_T([object isKindOfClass:[NSString     class]])) { if(workAroundMacOSXABIBreakingBug == NO) { encodeState-&gt;fastClassLookup.stringClass     = object-&gt;isa; } isClass = JKClassString;     }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    else if(JK_EXPECT_T([object isKindOfClass:[NSNumber     class]])) { if(workAroundMacOSXABIBreakingBug == NO) { encodeState-&gt;fastClassLookup.numberClass     = object-&gt;isa; } isClass = JKClassNumber;     }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    else if(JK_EXPECT_T([object isKindOfClass:[NSDictionary class]])) { if(workAroundMacOSXABIBreakingBug == NO) { encodeState-&gt;fastClassLookup.dictionaryClass = object-&gt;isa; } isClass = JKClassDictionary; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    else if(JK_EXPECT_T([object isKindOfClass:[NSArray      class]])) { if(workAroundMacOSXABIBreakingBug == NO) { encodeState-&gt;fastClassLookup.arrayClass      = object-&gt;isa; } isClass = JKClassArray;      }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    else if(JK_EXPECT_T([object isKindOfClass:[NSNull       class]])) { if(workAroundMacOSXABIBreakingBug == NO) { encodeState-&gt;fastClassLookup.nullClass       = object-&gt;isa; } isClass = JKClassNull;       }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>    else {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      if((rerunningAfterClassFormatter == NO) &amp;&amp; (</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#ifdef __BLOCKS__</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>           ((encodeState-&gt;classFormatterBlock) &amp;&amp; ((object = encodeState-&gt;classFormatterBlock(object))                                                                         != NULL)) ||</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#endif</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>           ((encodeState-&gt;classFormatterIMP)   &amp;&amp; ((object = encodeState-&gt;classFormatterIMP(encodeState-&gt;classFormatterDelegate, encodeState-&gt;classFormatterSelector, object)) != NULL))    )) { rerunningAfterClassFormatter = YES; goto rerunAfterClassFormatter; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>      </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      if(rerunningAfterClassFormatter == NO) { jk_encode_error(encodeState, @&quot;Unable to serialize object class %@.&quot;, NSStringFromClass([encodeCacheObject class])); return(1); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      else { jk_encode_error(encodeState, @&quot;Unable to serialize object class %@ that was returned by the unsupported class formatter.  Original object class was %@.&quot;, (object == NULL) ? @&quot;NULL&quot; : NSStringFromClass([object class]), NSStringFromClass([encodeCacheObject class])); return(1); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>    }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  // This is here for the benefit of the optimizer.  It allows the optimizer to do loop invariant code motion for the JKClassArray</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  // and JKClassDictionary cases when printing simple, single characters via jk_encode_write(), which is actually a macro:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  // #define jk_encode_write1(es, dc, f) (_jk_encode_prettyPrint ? jk_encode_write1slow(es, dc, f) : jk_encode_write1fast(es, dc, f))</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  int _jk_encode_prettyPrint = JK_EXPECT_T((encodeState-&gt;serializeOptionFlags &amp; JKSerializeOptionPretty) == 0) ? 0 : 1;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  switch(isClass) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>    case JKClassString:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>      {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>        {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          const unsigned char *cStringPtr = (const unsigned char *)CFStringGetCStringPtr((CFStringRef)object, kCFStringEncodingMacRoman);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          if(cStringPtr != NULL) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            const unsigned char *utf8String = cStringPtr;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            size_t               utf8Idx    = 0UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            CFIndex stringLength = CFStringGetLength((CFStringRef)object);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            if(JK_EXPECT_F(((encodeState-&gt;atIndex + (stringLength * 2UL) + 256UL) &gt; encodeState-&gt;stringBuffer.bytes.length)) &amp;&amp; JK_EXPECT_F((jk_managedBuffer_resize(&amp;encodeState-&gt;stringBuffer, encodeState-&gt;atIndex + (stringLength * 2UL) + 1024UL) == NULL))) { jk_encode_error(encodeState, @&quot;Unable to resize temporary buffer.&quot;); return(1); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            if(JK_EXPECT_T((encodeState-&gt;encodeOption &amp; JKEncodeOptionStringObjTrimQuotes) == 0UL)) { encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = &apos;\&quot;&apos;; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            for(utf8Idx = 0UL; utf8String[utf8Idx] != 0U; utf8Idx++) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>              NSCParameterAssert(((&amp;encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex]) - encodeState-&gt;stringBuffer.bytes.ptr) &lt; (ssize_t)encodeState-&gt;stringBuffer.bytes.length);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>              NSCParameterAssert(encodeState-&gt;atIndex &lt; encodeState-&gt;stringBuffer.bytes.length);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>              if(JK_EXPECT_F(utf8String[utf8Idx] &gt;= 0x80U)) { encodeState-&gt;atIndex = startingAtIndex; goto slowUTF8Path; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>              if(JK_EXPECT_F(utf8String[utf8Idx] &lt;  0x20U)) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>                switch(utf8String[utf8Idx]) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>                  case &apos;\b&apos;: encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = &apos;\\&apos;; encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = &apos;b&apos;; break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>                  case &apos;\f&apos;: encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = &apos;\\&apos;; encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = &apos;f&apos;; break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>                  case &apos;\n&apos;: encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = &apos;\\&apos;; encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = &apos;n&apos;; break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>                  case &apos;\r&apos;: encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = &apos;\\&apos;; encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = &apos;r&apos;; break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>                  case &apos;\t&apos;: encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = &apos;\\&apos;; encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = &apos;t&apos;; break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>                  default: if(JK_EXPECT_F(jk_encode_printf(encodeState, NULL, 0UL, NULL, &quot;\\u%4.4x&quot;, utf8String[utf8Idx]))) { return(1); } break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>                }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>              } else {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>                if(JK_EXPECT_F(utf8String[utf8Idx] == &apos;\&quot;&apos;) || JK_EXPECT_F(utf8String[utf8Idx] == &apos;\\&apos;) || (JK_EXPECT_F(encodeState-&gt;serializeOptionFlags &amp; JKSerializeOptionEscapeForwardSlashes) &amp;&amp; JK_EXPECT_F(utf8String[utf8Idx] == &apos;/&apos;))) { encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = &apos;\\&apos;; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>                encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = utf8String[utf8Idx];</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>              }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            NSCParameterAssert((encodeState-&gt;atIndex + 1UL) &lt; encodeState-&gt;stringBuffer.bytes.length);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            if(JK_EXPECT_T((encodeState-&gt;encodeOption &amp; JKEncodeOptionStringObjTrimQuotes) == 0UL)) { encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = &apos;\&quot;&apos;; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            jk_encode_updateCache(encodeState, cacheSlot, startingAtIndex, encodeCacheObject);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            return(0);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>          }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>      slowUTF8Path:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>        {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          CFIndex stringLength        = CFStringGetLength((CFStringRef)object);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          CFIndex maxStringUTF8Length = CFStringGetMaximumSizeForEncoding(stringLength, kCFStringEncodingUTF8) + 32L;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>        </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          if(JK_EXPECT_F((size_t)maxStringUTF8Length &gt; encodeState-&gt;utf8ConversionBuffer.bytes.length) &amp;&amp; JK_EXPECT_F(jk_managedBuffer_resize(&amp;encodeState-&gt;utf8ConversionBuffer, maxStringUTF8Length + 1024UL) == NULL)) { jk_encode_error(encodeState, @&quot;Unable to resize temporary buffer.&quot;); return(1); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>        </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          CFIndex usedBytes = 0L, convertedCount = 0L;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          convertedCount = CFStringGetBytes((CFStringRef)object, CFRangeMake(0L, stringLength), kCFStringEncodingUTF8, &apos;?&apos;, NO, encodeState-&gt;utf8ConversionBuffer.bytes.ptr, encodeState-&gt;utf8ConversionBuffer.bytes.length - 16L, &amp;usedBytes);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          if(JK_EXPECT_F(convertedCount != stringLength) || JK_EXPECT_F(usedBytes &lt; 0L)) { jk_encode_error(encodeState, @&quot;An error occurred converting the contents of a NSString to UTF8.&quot;); return(1); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>        </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          if(JK_EXPECT_F((encodeState-&gt;atIndex + (maxStringUTF8Length * 2UL) + 256UL) &gt; encodeState-&gt;stringBuffer.bytes.length) &amp;&amp; JK_EXPECT_F(jk_managedBuffer_resize(&amp;encodeState-&gt;stringBuffer, encodeState-&gt;atIndex + (maxStringUTF8Length * 2UL) + 1024UL) == NULL)) { jk_encode_error(encodeState, @&quot;Unable to resize temporary buffer.&quot;); return(1); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>        </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          const unsigned char *utf8String = encodeState-&gt;utf8ConversionBuffer.bytes.ptr;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>        </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          size_t utf8Idx = 0UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          if(JK_EXPECT_T((encodeState-&gt;encodeOption &amp; JKEncodeOptionStringObjTrimQuotes) == 0UL)) { encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = &apos;\&quot;&apos;; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          for(utf8Idx = 0UL; utf8Idx &lt; (size_t)usedBytes; utf8Idx++) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            NSCParameterAssert(((&amp;encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex]) - encodeState-&gt;stringBuffer.bytes.ptr) &lt; (ssize_t)encodeState-&gt;stringBuffer.bytes.length);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            NSCParameterAssert(encodeState-&gt;atIndex &lt; encodeState-&gt;stringBuffer.bytes.length);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            NSCParameterAssert((CFIndex)utf8Idx &lt; usedBytes);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            if(JK_EXPECT_F(utf8String[utf8Idx] &lt; 0x20U)) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>              switch(utf8String[utf8Idx]) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>                case &apos;\b&apos;: encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = &apos;\\&apos;; encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = &apos;b&apos;; break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>                case &apos;\f&apos;: encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = &apos;\\&apos;; encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = &apos;f&apos;; break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>                case &apos;\n&apos;: encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = &apos;\\&apos;; encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = &apos;n&apos;; break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>                case &apos;\r&apos;: encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = &apos;\\&apos;; encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = &apos;r&apos;; break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>                case &apos;\t&apos;: encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = &apos;\\&apos;; encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = &apos;t&apos;; break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>                default: if(JK_EXPECT_F(jk_encode_printf(encodeState, NULL, 0UL, NULL, &quot;\\u%4.4x&quot;, utf8String[utf8Idx]))) { return(1); } break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>              }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            } else {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>              if(JK_EXPECT_F(utf8String[utf8Idx] &gt;= 0x80U) &amp;&amp; (encodeState-&gt;serializeOptionFlags &amp; JKSerializeOptionEscapeUnicode)) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>                const unsigned char *nextValidCharacter = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>                UTF32                u32ch              = 0U;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>                ConversionResult     result;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>                if(JK_EXPECT_F((result = ConvertSingleCodePointInUTF8(&amp;utf8String[utf8Idx], &amp;utf8String[usedBytes], (UTF8 const **)&amp;nextValidCharacter, &amp;u32ch)) != conversionOK)) { jk_encode_error(encodeState, @&quot;Error converting UTF8.&quot;); return(1); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>                else {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>                  utf8Idx = (nextValidCharacter - utf8String) - 1UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>                  if(JK_EXPECT_T(u32ch &lt;= 0xffffU)) { if(JK_EXPECT_F(jk_encode_printf(encodeState, NULL, 0UL, NULL, &quot;\\u%4.4x&quot;, u32ch)))                                                           { return(1); } }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>                  else                              { if(JK_EXPECT_F(jk_encode_printf(encodeState, NULL, 0UL, NULL, &quot;\\u%4.4x\\u%4.4x&quot;, (0xd7c0U + (u32ch &gt;&gt; 10)), (0xdc00U + (u32ch &amp; 0x3ffU))))) { return(1); } }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>                }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>              } else {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>                if(JK_EXPECT_F(utf8String[utf8Idx] == &apos;\&quot;&apos;) || JK_EXPECT_F(utf8String[utf8Idx] == &apos;\\&apos;) || (JK_EXPECT_F(encodeState-&gt;serializeOptionFlags &amp; JKSerializeOptionEscapeForwardSlashes) &amp;&amp; JK_EXPECT_F(utf8String[utf8Idx] == &apos;/&apos;))) { encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = &apos;\\&apos;; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>                encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = utf8String[utf8Idx];</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>              }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>            }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          NSCParameterAssert((encodeState-&gt;atIndex + 1UL) &lt; encodeState-&gt;stringBuffer.bytes.length);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          if(JK_EXPECT_T((encodeState-&gt;encodeOption &amp; JKEncodeOptionStringObjTrimQuotes) == 0UL)) { encodeState-&gt;stringBuffer.bytes.ptr[encodeState-&gt;atIndex++] = &apos;\&quot;&apos;; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          jk_encode_updateCache(encodeState, cacheSlot, startingAtIndex, encodeCacheObject);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          return(0);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>        }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>      }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>      break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>    case JKClassNumber:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>      {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>             if(object == (id)kCFBooleanTrue)  { return(jk_encode_writen(encodeState, cacheSlot, startingAtIndex, encodeCacheObject, &quot;true&quot;,  4UL)); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        else if(object == (id)kCFBooleanFalse) { return(jk_encode_writen(encodeState, cacheSlot, startingAtIndex, encodeCacheObject, &quot;false&quot;, 5UL)); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>        </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        const char         *objCType = [object objCType];</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        char                anum[256], *aptr = &amp;anum[255];</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        int                 isNegative = 0;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        unsigned long long  ullv;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        long long           llv;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>        </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        if(JK_EXPECT_F(objCType == NULL) || JK_EXPECT_F(objCType[0] == 0) || JK_EXPECT_F(objCType[1] != 0)) { jk_encode_error(encodeState, @&quot;NSNumber conversion error, unknown type.  Type: &apos;%s&apos;&quot;, (objCType == NULL) ? &quot;&lt;NULL&gt;&quot; : objCType); return(1); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>        </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        switch(objCType[0]) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>          case &apos;c&apos;: case &apos;i&apos;: case &apos;s&apos;: case &apos;l&apos;: case &apos;q&apos;:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            if(JK_EXPECT_T(CFNumberGetValue((CFNumberRef)object, kCFNumberLongLongType, &amp;llv)))  {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>              if(llv &lt; 0LL)  { ullv = -llv; isNegative = 1; } else { ullv = llv; isNegative = 0; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>              goto convertNumber;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            } else { jk_encode_error(encodeState, @&quot;Unable to get scalar value from number object.&quot;); return(1); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>            break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>          case &apos;C&apos;: case &apos;I&apos;: case &apos;S&apos;: case &apos;L&apos;: case &apos;Q&apos;: case &apos;B&apos;:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            if(JK_EXPECT_T(CFNumberGetValue((CFNumberRef)object, kCFNumberLongLongType, &amp;ullv))) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>            convertNumber:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>              if(JK_EXPECT_F(ullv &lt; 10ULL)) { *--aptr = ullv + &apos;0&apos;; } else { while(JK_EXPECT_T(ullv &gt; 0ULL)) { *--aptr = (ullv % 10ULL) + &apos;0&apos;; ullv /= 10ULL; NSCParameterAssert(aptr &gt; anum); } }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>              if(isNegative) { *--aptr = &apos;-&apos;; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>              NSCParameterAssert(aptr &gt; anum);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>              return(jk_encode_writen(encodeState, cacheSlot, startingAtIndex, encodeCacheObject, aptr, &amp;anum[255] - aptr));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            } else { jk_encode_error(encodeState, @&quot;Unable to get scalar value from number object.&quot;); return(1); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>            break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>          case &apos;f&apos;: case &apos;d&apos;:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>            {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>              double dv;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>              if(JK_EXPECT_T(CFNumberGetValue((CFNumberRef)object, kCFNumberDoubleType, &amp;dv))) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>                if(JK_EXPECT_F(!isfinite(dv))) { jk_encode_error(encodeState, @&quot;Floating point values must be finite.  JSON does not support NaN or Infinity.&quot;); return(1); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>                return(jk_encode_printf(encodeState, cacheSlot, startingAtIndex, encodeCacheObject, &quot;%.17g&quot;, dv));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>              } else { jk_encode_error(encodeState, @&quot;Unable to get floating point value from number object.&quot;); return(1); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>            }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>            break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          default: jk_encode_error(encodeState, @&quot;NSNumber conversion error, unknown type.  Type: &apos;%c&apos; / 0x%2.2x&quot;, objCType[0], objCType[0]); return(1); break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>        }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>      }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>      break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>    </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>    case JKClassArray:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>      {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        int     printComma = 0;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        CFIndex arrayCount = CFArrayGetCount((CFArrayRef)object), idx = 0L;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        if(JK_EXPECT_F(jk_encode_write1(encodeState, 1L, &quot;[&quot;))) { return(1); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        if(JK_EXPECT_F(arrayCount &gt; 1020L)) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          for(id arrayObject in object)          { if(JK_EXPECT_T(printComma)) { if(JK_EXPECT_F(jk_encode_write1(encodeState, 0L, &quot;,&quot;))) { return(1); } } printComma = 1; if(JK_EXPECT_F(jk_encode_add_atom_to_buffer(encodeState, arrayObject)))  { return(1); } }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        } else {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          void *objects[1024];</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          CFArrayGetValues((CFArrayRef)object, CFRangeMake(0L, arrayCount), (const void **)objects);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          for(idx = 0L; idx &lt; arrayCount; idx++) { if(JK_EXPECT_T(printComma)) { if(JK_EXPECT_F(jk_encode_write1(encodeState, 0L, &quot;,&quot;))) { return(1); } } printComma = 1; if(JK_EXPECT_F(jk_encode_add_atom_to_buffer(encodeState, objects[idx]))) { return(1); } }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>        }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        return(jk_encode_write1(encodeState, -1L, &quot;]&quot;));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>      }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>      break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>    case JKClassDictionary:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>      {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        int     printComma      = 0;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        CFIndex dictionaryCount = CFDictionaryGetCount((CFDictionaryRef)object), idx = 0L;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        id      enumerateObject = JK_EXPECT_F(_jk_encode_prettyPrint) ? [[object allKeys] sortedArrayUsingSelector:@selector(compare:)] : object;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        if(JK_EXPECT_F(jk_encode_write1(encodeState, 1L, &quot;{&quot;))) { return(1); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        if(JK_EXPECT_F(_jk_encode_prettyPrint) || JK_EXPECT_F(dictionaryCount &gt; 1020L)) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          for(id keyObject in enumerateObject) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            if(JK_EXPECT_T(printComma)) { if(JK_EXPECT_F(jk_encode_write1(encodeState, 0L, &quot;,&quot;))) { return(1); } }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            printComma = 1;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            if(JK_EXPECT_F((keyObject-&gt;isa      != encodeState-&gt;fastClassLookup.stringClass)) &amp;&amp; JK_EXPECT_F(([keyObject   isKindOfClass:[NSString class]] == NO))) { jk_encode_error(encodeState, @&quot;Key must be a string object.&quot;); return(1); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            if(JK_EXPECT_F(jk_encode_add_atom_to_buffer(encodeState, keyObject)))                                                        { return(1); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            if(JK_EXPECT_F(jk_encode_write1(encodeState, 0L, &quot;:&quot;)))                                                                      { return(1); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            if(JK_EXPECT_F(jk_encode_add_atom_to_buffer(encodeState, (void *)CFDictionaryGetValue((CFDictionaryRef)object, keyObject)))) { return(1); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        } else {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          void *keys[1024], *objects[1024];</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          CFDictionaryGetKeysAndValues((CFDictionaryRef)object, (const void **)keys, (const void **)objects);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          for(idx = 0L; idx &lt; dictionaryCount; idx++) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            if(JK_EXPECT_T(printComma)) { if(JK_EXPECT_F(jk_encode_write1(encodeState, 0L, &quot;,&quot;))) { return(1); } }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            printComma = 1;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            if(JK_EXPECT_F(((id)keys[idx])-&gt;isa != encodeState-&gt;fastClassLookup.stringClass) &amp;&amp; JK_EXPECT_F([(id)keys[idx] isKindOfClass:[NSString class]] == NO)) { jk_encode_error(encodeState, @&quot;Key must be a string object.&quot;); return(1); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            if(JK_EXPECT_F(jk_encode_add_atom_to_buffer(encodeState, keys[idx])))    { return(1); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            if(JK_EXPECT_F(jk_encode_write1(encodeState, 0L, &quot;:&quot;)))                  { return(1); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>            if(JK_EXPECT_F(jk_encode_add_atom_to_buffer(encodeState, objects[idx]))) { return(1); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>          }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>        }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        return(jk_encode_write1(encodeState, -1L, &quot;}&quot;));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>      }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>      break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    case JKClassNull: return(jk_encode_writen(encodeState, cacheSlot, startingAtIndex, encodeCacheObject, &quot;null&quot;, 4UL)); break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    default: jk_encode_error(encodeState, @&quot;Unable to serialize object class %@.&quot;, NSStringFromClass([object class])); return(1); break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>  return(0);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>@implementation JKSerializer</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>+ (id)serializeObject:(id)object options:(JKSerializeOptionFlags)optionFlags encodeOption:(JKEncodeOptionType)encodeOption block:(JKSERIALIZER_BLOCKS_PROTO)block delegate:(id)delegate selector:(SEL)selector error:(NSError **)error</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return([[[[self alloc] init] autorelease] serializeObject:object options:optionFlags encodeOption:encodeOption block:block delegate:delegate selector:selector error:error]);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (id)serializeObject:(id)object options:(JKSerializeOptionFlags)optionFlags encodeOption:(JKEncodeOptionType)encodeOption block:(JKSERIALIZER_BLOCKS_PROTO)block delegate:(id)delegate selector:(SEL)selector error:(NSError **)error</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#ifndef __BLOCKS__</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#pragma unused(block)</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#endif</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  NSParameterAssert((object != NULL) &amp;&amp; (encodeState == NULL) &amp;&amp; ((delegate != NULL) ? (block == NULL) : 1) &amp;&amp; ((block != NULL) ? (delegate == NULL) : 1) &amp;&amp;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>                    (((encodeOption &amp; JKEncodeOptionCollectionObj) != 0UL) ? (((encodeOption &amp; JKEncodeOptionStringObj)     == 0UL) &amp;&amp; ((encodeOption &amp; JKEncodeOptionStringObjTrimQuotes) == 0UL)) : 1) &amp;&amp;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>                    (((encodeOption &amp; JKEncodeOptionStringObj)     != 0UL) ?  ((encodeOption &amp; JKEncodeOptionCollectionObj) == 0UL)                                                                 : 1));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  id returnObject = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(encodeState != NULL) { [self releaseState]; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if((encodeState = (struct JKEncodeState *)calloc(1UL, sizeof(JKEncodeState))) == NULL) { [NSException raise:NSMallocException format:@&quot;Unable to allocate state structure.&quot;]; return(NULL); }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if((error != NULL) &amp;&amp; (*error != NULL)) { *error = NULL; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(delegate != NULL) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if(selector                               == NULL) { [NSException raise:NSInvalidArgumentException format:@&quot;The delegate argument is not NULL, but the selector argument is NULL.&quot;]; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if([delegate respondsToSelector:selector] == NO)   { [NSException raise:NSInvalidArgumentException format:@&quot;The serializeUnsupportedClassesUsingDelegate: delegate does not respond to the selector argument.&quot;]; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    encodeState-&gt;classFormatterDelegate = delegate;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    encodeState-&gt;classFormatterSelector = selector;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    encodeState-&gt;classFormatterIMP      = (JKClassFormatterIMP)[delegate methodForSelector:selector];</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    NSCParameterAssert(encodeState-&gt;classFormatterIMP != NULL);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#ifdef __BLOCKS__</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  encodeState-&gt;classFormatterBlock                          = block;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#endif</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  encodeState-&gt;serializeOptionFlags                         = optionFlags;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  encodeState-&gt;encodeOption                                 = encodeOption;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  encodeState-&gt;stringBuffer.roundSizeUpToMultipleOf         = (1024UL * 32UL);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  encodeState-&gt;utf8ConversionBuffer.roundSizeUpToMultipleOf = 4096UL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>    </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  unsigned char stackJSONBuffer[JK_JSONBUFFER_SIZE] JK_ALIGNED(64);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  jk_managedBuffer_setToStackBuffer(&amp;encodeState-&gt;stringBuffer,         stackJSONBuffer, sizeof(stackJSONBuffer));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  unsigned char stackUTF8Buffer[JK_UTF8BUFFER_SIZE] JK_ALIGNED(64);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  jk_managedBuffer_setToStackBuffer(&amp;encodeState-&gt;utf8ConversionBuffer, stackUTF8Buffer, sizeof(stackUTF8Buffer));</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(((encodeOption &amp; JKEncodeOptionCollectionObj) != 0UL) &amp;&amp; (([object isKindOfClass:[NSArray  class]] == NO) &amp;&amp; ([object isKindOfClass:[NSDictionary class]] == NO))) { jk_encode_error(encodeState, @&quot;Unable to serialize object class %@, expected a NSArray or NSDictionary.&quot;, NSStringFromClass([object class])); goto errorExit; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(((encodeOption &amp; JKEncodeOptionStringObj)     != 0UL) &amp;&amp;  ([object isKindOfClass:[NSString class]] == NO))                                                         { jk_encode_error(encodeState, @&quot;Unable to serialize object class %@, expected a NSString.&quot;, NSStringFromClass([object class])); goto errorExit; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(jk_encode_add_atom_to_buffer(encodeState, object) == 0) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    BOOL stackBuffer = ((encodeState-&gt;stringBuffer.flags &amp; JKManagedBufferMustFree) == 0UL) ? YES : NO;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>    </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if((encodeState-&gt;atIndex &lt; 2UL))</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if((stackBuffer == NO) &amp;&amp; ((encodeState-&gt;stringBuffer.bytes.ptr = (unsigned char *)reallocf(encodeState-&gt;stringBuffer.bytes.ptr, encodeState-&gt;atIndex + 16UL)) == NULL)) { jk_encode_error(encodeState, @&quot;Unable to realloc buffer&quot;); goto errorExit; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    switch((encodeOption &amp; JKEncodeOptionAsTypeMask)) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>      case JKEncodeOptionAsData:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        if(stackBuffer == YES) { if((returnObject = [(id)CFDataCreate(                 NULL,                encodeState-&gt;stringBuffer.bytes.ptr, (CFIndex)encodeState-&gt;atIndex)                                  autorelease]) == NULL) { jk_encode_error(encodeState, @&quot;Unable to create NSData object&quot;); } }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        else                   { if((returnObject = [(id)CFDataCreateWithBytesNoCopy(  NULL,                encodeState-&gt;stringBuffer.bytes.ptr, (CFIndex)encodeState-&gt;atIndex, NULL)                            autorelease]) == NULL) { jk_encode_error(encodeState, @&quot;Unable to create NSData object&quot;); } }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>      case JKEncodeOptionAsString:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        if(stackBuffer == YES) { if((returnObject = [(id)CFStringCreateWithBytes(      NULL, (const UInt8 *)encodeState-&gt;stringBuffer.bytes.ptr, (CFIndex)encodeState-&gt;atIndex, kCFStringEncodingUTF8, NO)       autorelease]) == NULL) { jk_encode_error(encodeState, @&quot;Unable to create NSString object&quot;); } }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        else                   { if((returnObject = [(id)CFStringCreateWithBytesNoCopy(NULL, (const UInt8 *)encodeState-&gt;stringBuffer.bytes.ptr, (CFIndex)encodeState-&gt;atIndex, kCFStringEncodingUTF8, NO, NULL) autorelease]) == NULL) { jk_encode_error(encodeState, @&quot;Unable to create NSString object&quot;); } }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>        break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>      default: jk_encode_error(encodeState, @&quot;Unknown encode as type.&quot;); break;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>    }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    if((returnObject != NULL) &amp;&amp; (stackBuffer == NO)) { encodeState-&gt;stringBuffer.flags &amp;= ~JKManagedBufferMustFree; encodeState-&gt;stringBuffer.bytes.ptr = NULL; encodeState-&gt;stringBuffer.bytes.length = 0UL; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>errorExit:</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if((encodeState != NULL) &amp;&amp; (error != NULL) &amp;&amp; (encodeState-&gt;error != NULL)) { *error = encodeState-&gt;error; encodeState-&gt;error = NULL; }</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  [self releaseState];</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return(returnObject);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (void)releaseState</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  if(encodeState != NULL) {</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    jk_managedBuffer_release(&amp;encodeState-&gt;stringBuffer);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    jk_managedBuffer_release(&amp;encodeState-&gt;utf8ConversionBuffer);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>    free(encodeState); encodeState = NULL;</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  }  </td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (void)dealloc</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  [self releaseState];</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  [super dealloc];</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>@end</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>@implementation NSString (JSONKitSerializing)</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>////////////</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#pragma mark Methods for serializing a single NSString.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>////////////</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>// Useful for those who need to serialize just a NSString.  Otherwise you would have to do something like [NSArray arrayWithObject:stringToBeJSONSerialized], serializing the array, and then chopping of the extra ^\[.*\]$ square brackets.</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>// NSData returning methods...</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (NSData *)JSONData</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return([self JSONDataWithOptions:JKSerializeOptionNone includeQuotes:YES error:NULL]);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (NSData *)JSONDataWithOptions:(JKSerializeOptionFlags)serializeOptions includeQuotes:(BOOL)includeQuotes error:(NSError **)error</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return([JKSerializer serializeObject:self options:serializeOptions encodeOption:(JKEncodeOptionAsData | ((includeQuotes == NO) ? JKEncodeOptionStringObjTrimQuotes : 0UL) | JKEncodeOptionStringObj) block:NULL delegate:NULL selector:NULL error:error]);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>// NSString returning methods...</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (NSString *)JSONString</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return([self JSONStringWithOptions:JKSerializeOptionNone includeQuotes:YES error:NULL]);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (NSString *)JSONStringWithOptions:(JKSerializeOptionFlags)serializeOptions includeQuotes:(BOOL)includeQuotes error:(NSError **)error</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return([JKSerializer serializeObject:self options:serializeOptions encodeOption:(JKEncodeOptionAsString | ((includeQuotes == NO) ? JKEncodeOptionStringObjTrimQuotes : 0UL) | JKEncodeOptionStringObj) block:NULL delegate:NULL selector:NULL error:error]);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>@end</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>@implementation NSArray (JSONKitSerializing)</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>// NSData returning methods...</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (NSData *)JSONData</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return([JKSerializer serializeObject:self options:JKSerializeOptionNone encodeOption:(JKEncodeOptionAsData | JKEncodeOptionCollectionObj) block:NULL delegate:NULL selector:NULL error:NULL]);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (NSData *)JSONDataWithOptions:(JKSerializeOptionFlags)serializeOptions error:(NSError **)error</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return([JKSerializer serializeObject:self options:serializeOptions encodeOption:(JKEncodeOptionAsData | JKEncodeOptionCollectionObj) block:NULL delegate:NULL selector:NULL error:error]);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (NSData *)JSONDataWithOptions:(JKSerializeOptionFlags)serializeOptions serializeUnsupportedClassesUsingDelegate:(id)delegate selector:(SEL)selector error:(NSError **)error</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return([JKSerializer serializeObject:self options:serializeOptions encodeOption:(JKEncodeOptionAsData | JKEncodeOptionCollectionObj) block:NULL delegate:delegate selector:selector error:error]);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>// NSString returning methods...</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (NSString *)JSONString</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return([JKSerializer serializeObject:self options:JKSerializeOptionNone encodeOption:(JKEncodeOptionAsString | JKEncodeOptionCollectionObj) block:NULL delegate:NULL selector:NULL error:NULL]);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (NSString *)JSONStringWithOptions:(JKSerializeOptionFlags)serializeOptions error:(NSError **)error</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return([JKSerializer serializeObject:self options:serializeOptions encodeOption:(JKEncodeOptionAsString | JKEncodeOptionCollectionObj) block:NULL delegate:NULL selector:NULL error:error]);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (NSString *)JSONStringWithOptions:(JKSerializeOptionFlags)serializeOptions serializeUnsupportedClassesUsingDelegate:(id)delegate selector:(SEL)selector error:(NSError **)error</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return([JKSerializer serializeObject:self options:serializeOptions encodeOption:(JKEncodeOptionAsString | JKEncodeOptionCollectionObj) block:NULL delegate:delegate selector:selector error:error]);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>@end</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>@implementation NSDictionary (JSONKitSerializing)</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>// NSData returning methods...</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (NSData *)JSONData</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return([JKSerializer serializeObject:self options:JKSerializeOptionNone encodeOption:(JKEncodeOptionAsData | JKEncodeOptionCollectionObj) block:NULL delegate:NULL selector:NULL error:NULL]);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (NSData *)JSONDataWithOptions:(JKSerializeOptionFlags)serializeOptions error:(NSError **)error</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return([JKSerializer serializeObject:self options:serializeOptions encodeOption:(JKEncodeOptionAsData | JKEncodeOptionCollectionObj) block:NULL delegate:NULL selector:NULL error:error]);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (NSData *)JSONDataWithOptions:(JKSerializeOptionFlags)serializeOptions serializeUnsupportedClassesUsingDelegate:(id)delegate selector:(SEL)selector error:(NSError **)error</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return([JKSerializer serializeObject:self options:serializeOptions encodeOption:(JKEncodeOptionAsData | JKEncodeOptionCollectionObj) block:NULL delegate:delegate selector:selector error:error]);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>// NSString returning methods...</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (NSString *)JSONString</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return([JKSerializer serializeObject:self options:JKSerializeOptionNone encodeOption:(JKEncodeOptionAsString | JKEncodeOptionCollectionObj) block:NULL delegate:NULL selector:NULL error:NULL]);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (NSString *)JSONStringWithOptions:(JKSerializeOptionFlags)serializeOptions error:(NSError **)error</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return([JKSerializer serializeObject:self options:serializeOptions encodeOption:(JKEncodeOptionAsString | JKEncodeOptionCollectionObj) block:NULL delegate:NULL selector:NULL error:error]);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (NSString *)JSONStringWithOptions:(JKSerializeOptionFlags)serializeOptions serializeUnsupportedClassesUsingDelegate:(id)delegate selector:(SEL)selector error:(NSError **)error</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return([JKSerializer serializeObject:self options:serializeOptions encodeOption:(JKEncodeOptionAsString | JKEncodeOptionCollectionObj) block:NULL delegate:delegate selector:selector error:error]);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>@end</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#ifdef __BLOCKS__</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>@implementation NSArray (JSONKitSerializingBlockAdditions)</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (NSData *)JSONDataWithOptions:(JKSerializeOptionFlags)serializeOptions serializeUnsupportedClassesUsingBlock:(id(^)(id object))block error:(NSError **)error</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return([JKSerializer serializeObject:self options:serializeOptions encodeOption:(JKEncodeOptionAsData | JKEncodeOptionCollectionObj) block:block delegate:NULL selector:NULL error:error]);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (NSString *)JSONStringWithOptions:(JKSerializeOptionFlags)serializeOptions serializeUnsupportedClassesUsingBlock:(id(^)(id object))block error:(NSError **)error</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return([JKSerializer serializeObject:self options:serializeOptions encodeOption:(JKEncodeOptionAsString | JKEncodeOptionCollectionObj) block:block delegate:NULL selector:NULL error:error]);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>@end</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>@implementation NSDictionary (JSONKitSerializingBlockAdditions)</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (NSData *)JSONDataWithOptions:(JKSerializeOptionFlags)serializeOptions serializeUnsupportedClassesUsingBlock:(id(^)(id object))block error:(NSError **)error</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return([JKSerializer serializeObject:self options:serializeOptions encodeOption:(JKEncodeOptionAsData | JKEncodeOptionCollectionObj) block:block delegate:NULL selector:NULL error:error]);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>- (NSString *)JSONStringWithOptions:(JKSerializeOptionFlags)serializeOptions serializeUnsupportedClassesUsingBlock:(id(^)(id object))block error:(NSError **)error</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>{</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'>0</td>
<td class='sourcelinemissed'>  return([JKSerializer serializeObject:self options:serializeOptions encodeOption:(JKEncodeOptionAsString | JKEncodeOptionCollectionObj) block:block delegate:NULL selector:NULL error:error]);</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>}</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>@end</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'>#endif // __BLOCKS__</td>
</tr>
<tr class='sourceline'>
<td class='sourcelinehitcount'></td>
<td class='sourcelineskipped'></td>
</tr>

          </table>
        </div>
      </div>
    </body>
  </html>